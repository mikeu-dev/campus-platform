
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model announcements
 * 
 */
export type announcements = $Result.DefaultSelection<Prisma.$announcementsPayload>
/**
 * Model attendances
 * 
 */
export type attendances = $Result.DefaultSelection<Prisma.$attendancesPayload>
/**
 * Model certificate_requests
 * 
 */
export type certificate_requests = $Result.DefaultSelection<Prisma.$certificate_requestsPayload>
/**
 * Model class_schedules
 * 
 */
export type class_schedules = $Result.DefaultSelection<Prisma.$class_schedulesPayload>
/**
 * Model classes
 * 
 */
export type classes = $Result.DefaultSelection<Prisma.$classesPayload>
/**
 * Model courses
 * 
 */
export type courses = $Result.DefaultSelection<Prisma.$coursesPayload>
/**
 * Model enrollments
 * 
 */
export type enrollments = $Result.DefaultSelection<Prisma.$enrollmentsPayload>
/**
 * Model exams
 * 
 */
export type exams = $Result.DefaultSelection<Prisma.$examsPayload>
/**
 * Model financial_bills
 * 
 */
export type financial_bills = $Result.DefaultSelection<Prisma.$financial_billsPayload>
/**
 * Model grades
 * 
 */
export type grades = $Result.DefaultSelection<Prisma.$gradesPayload>
/**
 * Model lecturers
 * 
 */
export type lecturers = $Result.DefaultSelection<Prisma.$lecturersPayload>
/**
 * Model research_proposals
 * 
 */
export type research_proposals = $Result.DefaultSelection<Prisma.$research_proposalsPayload>
/**
 * Model student_profiles
 * 
 */
export type student_profiles = $Result.DefaultSelection<Prisma.$student_profilesPayload>
/**
 * Model students
 * 
 */
export type students = $Result.DefaultSelection<Prisma.$studentsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Announcements
 * const announcements = await prisma.announcements.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Announcements
   * const announcements = await prisma.announcements.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.announcements`: Exposes CRUD operations for the **announcements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcements.findMany()
    * ```
    */
  get announcements(): Prisma.announcementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendances`: Exposes CRUD operations for the **attendances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendances.findMany()
    * ```
    */
  get attendances(): Prisma.attendancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate_requests`: Exposes CRUD operations for the **certificate_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificate_requests
    * const certificate_requests = await prisma.certificate_requests.findMany()
    * ```
    */
  get certificate_requests(): Prisma.certificate_requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class_schedules`: Exposes CRUD operations for the **class_schedules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Class_schedules
    * const class_schedules = await prisma.class_schedules.findMany()
    * ```
    */
  get class_schedules(): Prisma.class_schedulesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classes`: Exposes CRUD operations for the **classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classes.findMany()
    * ```
    */
  get classes(): Prisma.classesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.coursesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollments`: Exposes CRUD operations for the **enrollments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollments.findMany()
    * ```
    */
  get enrollments(): Prisma.enrollmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exams`: Exposes CRUD operations for the **exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exams.findMany()
    * ```
    */
  get exams(): Prisma.examsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financial_bills`: Exposes CRUD operations for the **financial_bills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Financial_bills
    * const financial_bills = await prisma.financial_bills.findMany()
    * ```
    */
  get financial_bills(): Prisma.financial_billsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grades`: Exposes CRUD operations for the **grades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grades.findMany()
    * ```
    */
  get grades(): Prisma.gradesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lecturers`: Exposes CRUD operations for the **lecturers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecturers
    * const lecturers = await prisma.lecturers.findMany()
    * ```
    */
  get lecturers(): Prisma.lecturersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.research_proposals`: Exposes CRUD operations for the **research_proposals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Research_proposals
    * const research_proposals = await prisma.research_proposals.findMany()
    * ```
    */
  get research_proposals(): Prisma.research_proposalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student_profiles`: Exposes CRUD operations for the **student_profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_profiles
    * const student_profiles = await prisma.student_profiles.findMany()
    * ```
    */
  get student_profiles(): Prisma.student_profilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.studentsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.1
   * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    announcements: 'announcements',
    attendances: 'attendances',
    certificate_requests: 'certificate_requests',
    class_schedules: 'class_schedules',
    classes: 'classes',
    courses: 'courses',
    enrollments: 'enrollments',
    exams: 'exams',
    financial_bills: 'financial_bills',
    grades: 'grades',
    lecturers: 'lecturers',
    research_proposals: 'research_proposals',
    student_profiles: 'student_profiles',
    students: 'students'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "announcements" | "attendances" | "certificate_requests" | "class_schedules" | "classes" | "courses" | "enrollments" | "exams" | "financial_bills" | "grades" | "lecturers" | "research_proposals" | "student_profiles" | "students"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      announcements: {
        payload: Prisma.$announcementsPayload<ExtArgs>
        fields: Prisma.announcementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.announcementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.announcementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findFirst: {
            args: Prisma.announcementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.announcementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findMany: {
            args: Prisma.announcementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          create: {
            args: Prisma.announcementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          createMany: {
            args: Prisma.announcementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.announcementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          delete: {
            args: Prisma.announcementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          update: {
            args: Prisma.announcementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          deleteMany: {
            args: Prisma.announcementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.announcementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.announcementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          upsert: {
            args: Prisma.announcementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncements>
          }
          groupBy: {
            args: Prisma.announcementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.announcementsCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsCountAggregateOutputType> | number
          }
        }
      }
      attendances: {
        payload: Prisma.$attendancesPayload<ExtArgs>
        fields: Prisma.attendancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          findFirst: {
            args: Prisma.attendancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          findMany: {
            args: Prisma.attendancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>[]
          }
          create: {
            args: Prisma.attendancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          createMany: {
            args: Prisma.attendancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.attendancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>[]
          }
          delete: {
            args: Prisma.attendancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          update: {
            args: Prisma.attendancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          deleteMany: {
            args: Prisma.attendancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.attendancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>[]
          }
          upsert: {
            args: Prisma.attendancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          aggregate: {
            args: Prisma.AttendancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendances>
          }
          groupBy: {
            args: Prisma.attendancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendancesCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancesCountAggregateOutputType> | number
          }
        }
      }
      certificate_requests: {
        payload: Prisma.$certificate_requestsPayload<ExtArgs>
        fields: Prisma.certificate_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificate_requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificate_requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>
          }
          findFirst: {
            args: Prisma.certificate_requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificate_requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>
          }
          findMany: {
            args: Prisma.certificate_requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>[]
          }
          create: {
            args: Prisma.certificate_requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>
          }
          createMany: {
            args: Prisma.certificate_requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.certificate_requestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>[]
          }
          delete: {
            args: Prisma.certificate_requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>
          }
          update: {
            args: Prisma.certificate_requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>
          }
          deleteMany: {
            args: Prisma.certificate_requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificate_requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.certificate_requestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>[]
          }
          upsert: {
            args: Prisma.certificate_requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificate_requestsPayload>
          }
          aggregate: {
            args: Prisma.Certificate_requestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate_requests>
          }
          groupBy: {
            args: Prisma.certificate_requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Certificate_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificate_requestsCountArgs<ExtArgs>
            result: $Utils.Optional<Certificate_requestsCountAggregateOutputType> | number
          }
        }
      }
      class_schedules: {
        payload: Prisma.$class_schedulesPayload<ExtArgs>
        fields: Prisma.class_schedulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.class_schedulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.class_schedulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>
          }
          findFirst: {
            args: Prisma.class_schedulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.class_schedulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>
          }
          findMany: {
            args: Prisma.class_schedulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>[]
          }
          create: {
            args: Prisma.class_schedulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>
          }
          createMany: {
            args: Prisma.class_schedulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.class_schedulesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>[]
          }
          delete: {
            args: Prisma.class_schedulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>
          }
          update: {
            args: Prisma.class_schedulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>
          }
          deleteMany: {
            args: Prisma.class_schedulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.class_schedulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.class_schedulesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>[]
          }
          upsert: {
            args: Prisma.class_schedulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_schedulesPayload>
          }
          aggregate: {
            args: Prisma.Class_schedulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass_schedules>
          }
          groupBy: {
            args: Prisma.class_schedulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Class_schedulesGroupByOutputType>[]
          }
          count: {
            args: Prisma.class_schedulesCountArgs<ExtArgs>
            result: $Utils.Optional<Class_schedulesCountAggregateOutputType> | number
          }
        }
      }
      classes: {
        payload: Prisma.$classesPayload<ExtArgs>
        fields: Prisma.classesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.classesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.classesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          findFirst: {
            args: Prisma.classesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.classesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          findMany: {
            args: Prisma.classesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>[]
          }
          create: {
            args: Prisma.classesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          createMany: {
            args: Prisma.classesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.classesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>[]
          }
          delete: {
            args: Prisma.classesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          update: {
            args: Prisma.classesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          deleteMany: {
            args: Prisma.classesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.classesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.classesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>[]
          }
          upsert: {
            args: Prisma.classesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          aggregate: {
            args: Prisma.ClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasses>
          }
          groupBy: {
            args: Prisma.classesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.classesCountArgs<ExtArgs>
            result: $Utils.Optional<ClassesCountAggregateOutputType> | number
          }
        }
      }
      courses: {
        payload: Prisma.$coursesPayload<ExtArgs>
        fields: Prisma.coursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coursesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coursesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          findFirst: {
            args: Prisma.coursesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coursesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          findMany: {
            args: Prisma.coursesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          create: {
            args: Prisma.coursesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          createMany: {
            args: Prisma.coursesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.coursesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          delete: {
            args: Prisma.coursesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          update: {
            args: Prisma.coursesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          deleteMany: {
            args: Prisma.coursesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coursesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.coursesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          upsert: {
            args: Prisma.coursesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          aggregate: {
            args: Prisma.CoursesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourses>
          }
          groupBy: {
            args: Prisma.coursesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.coursesCountArgs<ExtArgs>
            result: $Utils.Optional<CoursesCountAggregateOutputType> | number
          }
        }
      }
      enrollments: {
        payload: Prisma.$enrollmentsPayload<ExtArgs>
        fields: Prisma.enrollmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enrollmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enrollmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          findFirst: {
            args: Prisma.enrollmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enrollmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          findMany: {
            args: Prisma.enrollmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          create: {
            args: Prisma.enrollmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          createMany: {
            args: Prisma.enrollmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.enrollmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          delete: {
            args: Prisma.enrollmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          update: {
            args: Prisma.enrollmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          deleteMany: {
            args: Prisma.enrollmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enrollmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.enrollmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          upsert: {
            args: Prisma.enrollmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollments>
          }
          groupBy: {
            args: Prisma.enrollmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.enrollmentsCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentsCountAggregateOutputType> | number
          }
        }
      }
      exams: {
        payload: Prisma.$examsPayload<ExtArgs>
        fields: Prisma.examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          findFirst: {
            args: Prisma.examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          findMany: {
            args: Prisma.examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          create: {
            args: Prisma.examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          createMany: {
            args: Prisma.examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.examsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          delete: {
            args: Prisma.examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          update: {
            args: Prisma.examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          deleteMany: {
            args: Prisma.examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.examsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          upsert: {
            args: Prisma.examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          aggregate: {
            args: Prisma.ExamsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExams>
          }
          groupBy: {
            args: Prisma.examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamsGroupByOutputType>[]
          }
          count: {
            args: Prisma.examsCountArgs<ExtArgs>
            result: $Utils.Optional<ExamsCountAggregateOutputType> | number
          }
        }
      }
      financial_bills: {
        payload: Prisma.$financial_billsPayload<ExtArgs>
        fields: Prisma.financial_billsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.financial_billsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.financial_billsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>
          }
          findFirst: {
            args: Prisma.financial_billsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.financial_billsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>
          }
          findMany: {
            args: Prisma.financial_billsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>[]
          }
          create: {
            args: Prisma.financial_billsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>
          }
          createMany: {
            args: Prisma.financial_billsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.financial_billsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>[]
          }
          delete: {
            args: Prisma.financial_billsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>
          }
          update: {
            args: Prisma.financial_billsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>
          }
          deleteMany: {
            args: Prisma.financial_billsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.financial_billsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.financial_billsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>[]
          }
          upsert: {
            args: Prisma.financial_billsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financial_billsPayload>
          }
          aggregate: {
            args: Prisma.Financial_billsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancial_bills>
          }
          groupBy: {
            args: Prisma.financial_billsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Financial_billsGroupByOutputType>[]
          }
          count: {
            args: Prisma.financial_billsCountArgs<ExtArgs>
            result: $Utils.Optional<Financial_billsCountAggregateOutputType> | number
          }
        }
      }
      grades: {
        payload: Prisma.$gradesPayload<ExtArgs>
        fields: Prisma.gradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gradesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gradesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>
          }
          findFirst: {
            args: Prisma.gradesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gradesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>
          }
          findMany: {
            args: Prisma.gradesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>[]
          }
          create: {
            args: Prisma.gradesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>
          }
          createMany: {
            args: Prisma.gradesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gradesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>[]
          }
          delete: {
            args: Prisma.gradesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>
          }
          update: {
            args: Prisma.gradesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>
          }
          deleteMany: {
            args: Prisma.gradesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gradesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.gradesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>[]
          }
          upsert: {
            args: Prisma.gradesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradesPayload>
          }
          aggregate: {
            args: Prisma.GradesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrades>
          }
          groupBy: {
            args: Prisma.gradesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.gradesCountArgs<ExtArgs>
            result: $Utils.Optional<GradesCountAggregateOutputType> | number
          }
        }
      }
      lecturers: {
        payload: Prisma.$lecturersPayload<ExtArgs>
        fields: Prisma.lecturersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lecturersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lecturersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          findFirst: {
            args: Prisma.lecturersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lecturersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          findMany: {
            args: Prisma.lecturersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>[]
          }
          create: {
            args: Prisma.lecturersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          createMany: {
            args: Prisma.lecturersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lecturersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>[]
          }
          delete: {
            args: Prisma.lecturersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          update: {
            args: Prisma.lecturersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          deleteMany: {
            args: Prisma.lecturersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lecturersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lecturersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>[]
          }
          upsert: {
            args: Prisma.lecturersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          aggregate: {
            args: Prisma.LecturersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLecturers>
          }
          groupBy: {
            args: Prisma.lecturersGroupByArgs<ExtArgs>
            result: $Utils.Optional<LecturersGroupByOutputType>[]
          }
          count: {
            args: Prisma.lecturersCountArgs<ExtArgs>
            result: $Utils.Optional<LecturersCountAggregateOutputType> | number
          }
        }
      }
      research_proposals: {
        payload: Prisma.$research_proposalsPayload<ExtArgs>
        fields: Prisma.research_proposalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.research_proposalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.research_proposalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>
          }
          findFirst: {
            args: Prisma.research_proposalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.research_proposalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>
          }
          findMany: {
            args: Prisma.research_proposalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>[]
          }
          create: {
            args: Prisma.research_proposalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>
          }
          createMany: {
            args: Prisma.research_proposalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.research_proposalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>[]
          }
          delete: {
            args: Prisma.research_proposalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>
          }
          update: {
            args: Prisma.research_proposalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>
          }
          deleteMany: {
            args: Prisma.research_proposalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.research_proposalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.research_proposalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>[]
          }
          upsert: {
            args: Prisma.research_proposalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$research_proposalsPayload>
          }
          aggregate: {
            args: Prisma.Research_proposalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearch_proposals>
          }
          groupBy: {
            args: Prisma.research_proposalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Research_proposalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.research_proposalsCountArgs<ExtArgs>
            result: $Utils.Optional<Research_proposalsCountAggregateOutputType> | number
          }
        }
      }
      student_profiles: {
        payload: Prisma.$student_profilesPayload<ExtArgs>
        fields: Prisma.student_profilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_profilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_profilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>
          }
          findFirst: {
            args: Prisma.student_profilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_profilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>
          }
          findMany: {
            args: Prisma.student_profilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>[]
          }
          create: {
            args: Prisma.student_profilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>
          }
          createMany: {
            args: Prisma.student_profilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_profilesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>[]
          }
          delete: {
            args: Prisma.student_profilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>
          }
          update: {
            args: Prisma.student_profilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>
          }
          deleteMany: {
            args: Prisma.student_profilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_profilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.student_profilesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>[]
          }
          upsert: {
            args: Prisma.student_profilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_profilesPayload>
          }
          aggregate: {
            args: Prisma.Student_profilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_profiles>
          }
          groupBy: {
            args: Prisma.student_profilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_profilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_profilesCountArgs<ExtArgs>
            result: $Utils.Optional<Student_profilesCountAggregateOutputType> | number
          }
        }
      }
      students: {
        payload: Prisma.$studentsPayload<ExtArgs>
        fields: Prisma.studentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findFirst: {
            args: Prisma.studentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findMany: {
            args: Prisma.studentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          create: {
            args: Prisma.studentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          createMany: {
            args: Prisma.studentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          delete: {
            args: Prisma.studentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          update: {
            args: Prisma.studentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          deleteMany: {
            args: Prisma.studentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.studentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          upsert: {
            args: Prisma.studentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.studentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    announcements?: announcementsOmit
    attendances?: attendancesOmit
    certificate_requests?: certificate_requestsOmit
    class_schedules?: class_schedulesOmit
    classes?: classesOmit
    courses?: coursesOmit
    enrollments?: enrollmentsOmit
    exams?: examsOmit
    financial_bills?: financial_billsOmit
    grades?: gradesOmit
    lecturers?: lecturersOmit
    research_proposals?: research_proposalsOmit
    student_profiles?: student_profilesOmit
    students?: studentsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClassesCountOutputType
   */

  export type ClassesCountOutputType = {
    attendances: number
    class_schedules: number
    enrollments: number
    exams: number
  }

  export type ClassesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | ClassesCountOutputTypeCountAttendancesArgs
    class_schedules?: boolean | ClassesCountOutputTypeCountClass_schedulesArgs
    enrollments?: boolean | ClassesCountOutputTypeCountEnrollmentsArgs
    exams?: boolean | ClassesCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassesCountOutputType
     */
    select?: ClassesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountClass_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_schedulesWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
  }


  /**
   * Count Type CoursesCountOutputType
   */

  export type CoursesCountOutputType = {
    classes: number
  }

  export type CoursesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | CoursesCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     */
    select?: CoursesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
  }


  /**
   * Count Type EnrollmentsCountOutputType
   */

  export type EnrollmentsCountOutputType = {
    grades: number
  }

  export type EnrollmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | EnrollmentsCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * EnrollmentsCountOutputType without action
   */
  export type EnrollmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentsCountOutputType
     */
    select?: EnrollmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnrollmentsCountOutputType without action
   */
  export type EnrollmentsCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gradesWhereInput
  }


  /**
   * Count Type LecturersCountOutputType
   */

  export type LecturersCountOutputType = {
    classes: number
  }

  export type LecturersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | LecturersCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * LecturersCountOutputType without action
   */
  export type LecturersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LecturersCountOutputType
     */
    select?: LecturersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LecturersCountOutputType without action
   */
  export type LecturersCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    attendances: number
    certificate_requests: number
    enrollments: number
    financial_bills: number
    research_proposals: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | StudentsCountOutputTypeCountAttendancesArgs
    certificate_requests?: boolean | StudentsCountOutputTypeCountCertificate_requestsArgs
    enrollments?: boolean | StudentsCountOutputTypeCountEnrollmentsArgs
    financial_bills?: boolean | StudentsCountOutputTypeCountFinancial_billsArgs
    research_proposals?: boolean | StudentsCountOutputTypeCountResearch_proposalsArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountCertificate_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificate_requestsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountFinancial_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: financial_billsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountResearch_proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: research_proposalsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model announcements
   */

  export type AggregateAnnouncements = {
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  export type AnnouncementsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    title: string | null
    content: string | null
    type: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type AnnouncementsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    title: string | null
    content: string | null
    type: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type AnnouncementsCountAggregateOutputType = {
    id: number
    tenant_id: number
    title: number
    content: number
    type: number
    is_active: number
    created_at: number
    _all: number
  }


  export type AnnouncementsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    title?: true
    content?: true
    type?: true
    is_active?: true
    created_at?: true
  }

  export type AnnouncementsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    title?: true
    content?: true
    type?: true
    is_active?: true
    created_at?: true
  }

  export type AnnouncementsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    title?: true
    content?: true
    type?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type AnnouncementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to aggregate.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned announcements
    **/
    _count?: true | AnnouncementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type GetAnnouncementsAggregateType<T extends AnnouncementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncements[P]>
      : GetScalarType<T[P], AggregateAnnouncements[P]>
  }




  export type announcementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementsWhereInput
    orderBy?: announcementsOrderByWithAggregationInput | announcementsOrderByWithAggregationInput[]
    by: AnnouncementsScalarFieldEnum[] | AnnouncementsScalarFieldEnum
    having?: announcementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementsCountAggregateInputType | true
    _min?: AnnouncementsMinAggregateInputType
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type AnnouncementsGroupByOutputType = {
    id: string
    tenant_id: string
    title: string
    content: string
    type: string | null
    is_active: boolean | null
    created_at: Date | null
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  type GetAnnouncementsGroupByPayload<T extends announcementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
        }
      >
    >


  export type announcementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
  }

  export type announcementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "title" | "content" | "type" | "is_active" | "created_at", ExtArgs["result"]["announcements"]>

  export type $announcementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "announcements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      title: string
      content: string
      type: string | null
      is_active: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["announcements"]>
    composites: {}
  }

  type announcementsGetPayload<S extends boolean | null | undefined | announcementsDefaultArgs> = $Result.GetResult<Prisma.$announcementsPayload, S>

  type announcementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<announcementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementsCountAggregateInputType | true
    }

  export interface announcementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['announcements'], meta: { name: 'announcements' } }
    /**
     * Find zero or one Announcements that matches the filter.
     * @param {announcementsFindUniqueArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends announcementsFindUniqueArgs>(args: SelectSubset<T, announcementsFindUniqueArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {announcementsFindUniqueOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends announcementsFindUniqueOrThrowArgs>(args: SelectSubset<T, announcementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends announcementsFindFirstArgs>(args?: SelectSubset<T, announcementsFindFirstArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends announcementsFindFirstOrThrowArgs>(args?: SelectSubset<T, announcementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcements.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementsWithIdOnly = await prisma.announcements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends announcementsFindManyArgs>(args?: SelectSubset<T, announcementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcements.
     * @param {announcementsCreateArgs} args - Arguments to create a Announcements.
     * @example
     * // Create one Announcements
     * const Announcements = await prisma.announcements.create({
     *   data: {
     *     // ... data to create a Announcements
     *   }
     * })
     * 
     */
    create<T extends announcementsCreateArgs>(args: SelectSubset<T, announcementsCreateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {announcementsCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends announcementsCreateManyArgs>(args?: SelectSubset<T, announcementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {announcementsCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends announcementsCreateManyAndReturnArgs>(args?: SelectSubset<T, announcementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcements.
     * @param {announcementsDeleteArgs} args - Arguments to delete one Announcements.
     * @example
     * // Delete one Announcements
     * const Announcements = await prisma.announcements.delete({
     *   where: {
     *     // ... filter to delete one Announcements
     *   }
     * })
     * 
     */
    delete<T extends announcementsDeleteArgs>(args: SelectSubset<T, announcementsDeleteArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcements.
     * @param {announcementsUpdateArgs} args - Arguments to update one Announcements.
     * @example
     * // Update one Announcements
     * const announcements = await prisma.announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends announcementsUpdateArgs>(args: SelectSubset<T, announcementsUpdateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {announcementsDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends announcementsDeleteManyArgs>(args?: SelectSubset<T, announcementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends announcementsUpdateManyArgs>(args: SelectSubset<T, announcementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {announcementsUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends announcementsUpdateManyAndReturnArgs>(args: SelectSubset<T, announcementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcements.
     * @param {announcementsUpsertArgs} args - Arguments to update or create a Announcements.
     * @example
     * // Update or create a Announcements
     * const announcements = await prisma.announcements.upsert({
     *   create: {
     *     // ... data to create a Announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcements we want to update
     *   }
     * })
     */
    upsert<T extends announcementsUpsertArgs>(args: SelectSubset<T, announcementsUpsertArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcements.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends announcementsCountArgs>(
      args?: Subset<T, announcementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementsAggregateArgs>(args: Subset<T, AnnouncementsAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementsAggregateType<T>>

    /**
     * Group by Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends announcementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: announcementsGroupByArgs['orderBy'] }
        : { orderBy?: announcementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, announcementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the announcements model
   */
  readonly fields: announcementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__announcementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the announcements model
   */
  interface announcementsFieldRefs {
    readonly id: FieldRef<"announcements", 'String'>
    readonly tenant_id: FieldRef<"announcements", 'String'>
    readonly title: FieldRef<"announcements", 'String'>
    readonly content: FieldRef<"announcements", 'String'>
    readonly type: FieldRef<"announcements", 'String'>
    readonly is_active: FieldRef<"announcements", 'Boolean'>
    readonly created_at: FieldRef<"announcements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * announcements findUnique
   */
  export type announcementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findUniqueOrThrow
   */
  export type announcementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findFirst
   */
  export type announcementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findFirstOrThrow
   */
  export type announcementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findMany
   */
  export type announcementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements create
   */
  export type announcementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data needed to create a announcements.
     */
    data: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
  }

  /**
   * announcements createMany
   */
  export type announcementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * announcements createManyAndReturn
   */
  export type announcementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * announcements update
   */
  export type announcementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data needed to update a announcements.
     */
    data: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
    /**
     * Choose, which announcements to update.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements updateMany
   */
  export type announcementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcements updateManyAndReturn
   */
  export type announcementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcements upsert
   */
  export type announcementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The filter to search for the announcements to update in case it exists.
     */
    where: announcementsWhereUniqueInput
    /**
     * In case the announcements found by the `where` argument doesn't exist, create a new announcements with this data.
     */
    create: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
    /**
     * In case the announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
  }

  /**
   * announcements delete
   */
  export type announcementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter which announcements to delete.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements deleteMany
   */
  export type announcementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to delete
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to delete.
     */
    limit?: number
  }

  /**
   * announcements without action
   */
  export type announcementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
  }


  /**
   * Model attendances
   */

  export type AggregateAttendances = {
    _count: AttendancesCountAggregateOutputType | null
    _avg: AttendancesAvgAggregateOutputType | null
    _sum: AttendancesSumAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  export type AttendancesAvgAggregateOutputType = {
    meeting_number: number | null
  }

  export type AttendancesSumAggregateOutputType = {
    meeting_number: number | null
  }

  export type AttendancesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    class_id: string | null
    student_id: string | null
    meeting_number: number | null
    status: string | null
    created_at: Date | null
  }

  export type AttendancesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    class_id: string | null
    student_id: string | null
    meeting_number: number | null
    status: string | null
    created_at: Date | null
  }

  export type AttendancesCountAggregateOutputType = {
    id: number
    tenant_id: number
    class_id: number
    student_id: number
    meeting_number: number
    status: number
    created_at: number
    _all: number
  }


  export type AttendancesAvgAggregateInputType = {
    meeting_number?: true
  }

  export type AttendancesSumAggregateInputType = {
    meeting_number?: true
  }

  export type AttendancesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    student_id?: true
    meeting_number?: true
    status?: true
    created_at?: true
  }

  export type AttendancesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    student_id?: true
    meeting_number?: true
    status?: true
    created_at?: true
  }

  export type AttendancesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    student_id?: true
    meeting_number?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type AttendancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to aggregate.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendances
    **/
    _count?: true | AttendancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancesMaxAggregateInputType
  }

  export type GetAttendancesAggregateType<T extends AttendancesAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendances[P]>
      : GetScalarType<T[P], AggregateAttendances[P]>
  }




  export type attendancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesWhereInput
    orderBy?: attendancesOrderByWithAggregationInput | attendancesOrderByWithAggregationInput[]
    by: AttendancesScalarFieldEnum[] | AttendancesScalarFieldEnum
    having?: attendancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancesCountAggregateInputType | true
    _avg?: AttendancesAvgAggregateInputType
    _sum?: AttendancesSumAggregateInputType
    _min?: AttendancesMinAggregateInputType
    _max?: AttendancesMaxAggregateInputType
  }

  export type AttendancesGroupByOutputType = {
    id: string
    tenant_id: string
    class_id: string
    student_id: string
    meeting_number: number
    status: string | null
    created_at: Date | null
    _count: AttendancesCountAggregateOutputType | null
    _avg: AttendancesAvgAggregateOutputType | null
    _sum: AttendancesSumAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  type GetAttendancesGroupByPayload<T extends attendancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
        }
      >
    >


  export type attendancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    student_id?: boolean
    meeting_number?: boolean
    status?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type attendancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    student_id?: boolean
    meeting_number?: boolean
    status?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type attendancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    student_id?: boolean
    meeting_number?: boolean
    status?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>

  export type attendancesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    student_id?: boolean
    meeting_number?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type attendancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "class_id" | "student_id" | "meeting_number" | "status" | "created_at", ExtArgs["result"]["attendances"]>
  export type attendancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type attendancesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type attendancesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $attendancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendances"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      class_id: string
      student_id: string
      meeting_number: number
      status: string | null
      created_at: Date | null
    }, ExtArgs["result"]["attendances"]>
    composites: {}
  }

  type attendancesGetPayload<S extends boolean | null | undefined | attendancesDefaultArgs> = $Result.GetResult<Prisma.$attendancesPayload, S>

  type attendancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendancesCountAggregateInputType | true
    }

  export interface attendancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendances'], meta: { name: 'attendances' } }
    /**
     * Find zero or one Attendances that matches the filter.
     * @param {attendancesFindUniqueArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendancesFindUniqueArgs>(args: SelectSubset<T, attendancesFindUniqueArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendancesFindUniqueOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendancesFindUniqueOrThrowArgs>(args: SelectSubset<T, attendancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesFindFirstArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendancesFindFirstArgs>(args?: SelectSubset<T, attendancesFindFirstArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesFindFirstOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendancesFindFirstOrThrowArgs>(args?: SelectSubset<T, attendancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendances.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancesWithIdOnly = await prisma.attendances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendancesFindManyArgs>(args?: SelectSubset<T, attendancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendances.
     * @param {attendancesCreateArgs} args - Arguments to create a Attendances.
     * @example
     * // Create one Attendances
     * const Attendances = await prisma.attendances.create({
     *   data: {
     *     // ... data to create a Attendances
     *   }
     * })
     * 
     */
    create<T extends attendancesCreateArgs>(args: SelectSubset<T, attendancesCreateArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {attendancesCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendancesCreateManyArgs>(args?: SelectSubset<T, attendancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {attendancesCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendancesWithIdOnly = await prisma.attendances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends attendancesCreateManyAndReturnArgs>(args?: SelectSubset<T, attendancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendances.
     * @param {attendancesDeleteArgs} args - Arguments to delete one Attendances.
     * @example
     * // Delete one Attendances
     * const Attendances = await prisma.attendances.delete({
     *   where: {
     *     // ... filter to delete one Attendances
     *   }
     * })
     * 
     */
    delete<T extends attendancesDeleteArgs>(args: SelectSubset<T, attendancesDeleteArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendances.
     * @param {attendancesUpdateArgs} args - Arguments to update one Attendances.
     * @example
     * // Update one Attendances
     * const attendances = await prisma.attendances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendancesUpdateArgs>(args: SelectSubset<T, attendancesUpdateArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {attendancesDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendancesDeleteManyArgs>(args?: SelectSubset<T, attendancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendancesUpdateManyArgs>(args: SelectSubset<T, attendancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {attendancesUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendancesWithIdOnly = await prisma.attendances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends attendancesUpdateManyAndReturnArgs>(args: SelectSubset<T, attendancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendances.
     * @param {attendancesUpsertArgs} args - Arguments to update or create a Attendances.
     * @example
     * // Update or create a Attendances
     * const attendances = await prisma.attendances.upsert({
     *   create: {
     *     // ... data to create a Attendances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendances we want to update
     *   }
     * })
     */
    upsert<T extends attendancesUpsertArgs>(args: SelectSubset<T, attendancesUpsertArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendances.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends attendancesCountArgs>(
      args?: Subset<T, attendancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancesAggregateArgs>(args: Subset<T, AttendancesAggregateArgs>): Prisma.PrismaPromise<GetAttendancesAggregateType<T>>

    /**
     * Group by Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendancesGroupByArgs['orderBy'] }
        : { orderBy?: attendancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendances model
   */
  readonly fields: attendancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends classesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classesDefaultArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendances model
   */
  interface attendancesFieldRefs {
    readonly id: FieldRef<"attendances", 'String'>
    readonly tenant_id: FieldRef<"attendances", 'String'>
    readonly class_id: FieldRef<"attendances", 'String'>
    readonly student_id: FieldRef<"attendances", 'String'>
    readonly meeting_number: FieldRef<"attendances", 'Int'>
    readonly status: FieldRef<"attendances", 'String'>
    readonly created_at: FieldRef<"attendances", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attendances findUnique
   */
  export type attendancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances findUniqueOrThrow
   */
  export type attendancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances findFirst
   */
  export type attendancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * attendances findFirstOrThrow
   */
  export type attendancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * attendances findMany
   */
  export type attendancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendances.
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * attendances create
   */
  export type attendancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * The data needed to create a attendances.
     */
    data: XOR<attendancesCreateInput, attendancesUncheckedCreateInput>
  }

  /**
   * attendances createMany
   */
  export type attendancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendances.
     */
    data: attendancesCreateManyInput | attendancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendances createManyAndReturn
   */
  export type attendancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * The data used to create many attendances.
     */
    data: attendancesCreateManyInput | attendancesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * attendances update
   */
  export type attendancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * The data needed to update a attendances.
     */
    data: XOR<attendancesUpdateInput, attendancesUncheckedUpdateInput>
    /**
     * Choose, which attendances to update.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances updateMany
   */
  export type attendancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendances.
     */
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendancesWhereInput
    /**
     * Limit how many attendances to update.
     */
    limit?: number
  }

  /**
   * attendances updateManyAndReturn
   */
  export type attendancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * The data used to update attendances.
     */
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendancesWhereInput
    /**
     * Limit how many attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * attendances upsert
   */
  export type attendancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * The filter to search for the attendances to update in case it exists.
     */
    where: attendancesWhereUniqueInput
    /**
     * In case the attendances found by the `where` argument doesn't exist, create a new attendances with this data.
     */
    create: XOR<attendancesCreateInput, attendancesUncheckedCreateInput>
    /**
     * In case the attendances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendancesUpdateInput, attendancesUncheckedUpdateInput>
  }

  /**
   * attendances delete
   */
  export type attendancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter which attendances to delete.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances deleteMany
   */
  export type attendancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to delete
     */
    where?: attendancesWhereInput
    /**
     * Limit how many attendances to delete.
     */
    limit?: number
  }

  /**
   * attendances without action
   */
  export type attendancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
  }


  /**
   * Model certificate_requests
   */

  export type AggregateCertificate_requests = {
    _count: Certificate_requestsCountAggregateOutputType | null
    _avg: Certificate_requestsAvgAggregateOutputType | null
    _sum: Certificate_requestsSumAggregateOutputType | null
    _min: Certificate_requestsMinAggregateOutputType | null
    _max: Certificate_requestsMaxAggregateOutputType | null
  }

  export type Certificate_requestsAvgAggregateOutputType = {
    quantity: number | null
  }

  export type Certificate_requestsSumAggregateOutputType = {
    quantity: number | null
  }

  export type Certificate_requestsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    type: string | null
    purpose: string | null
    quantity: number | null
    notes: string | null
    status: string | null
    rejection_reason: string | null
    download_url: string | null
    created_at: Date | null
  }

  export type Certificate_requestsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    type: string | null
    purpose: string | null
    quantity: number | null
    notes: string | null
    status: string | null
    rejection_reason: string | null
    download_url: string | null
    created_at: Date | null
  }

  export type Certificate_requestsCountAggregateOutputType = {
    id: number
    tenant_id: number
    student_id: number
    type: number
    purpose: number
    quantity: number
    notes: number
    status: number
    rejection_reason: number
    download_url: number
    created_at: number
    _all: number
  }


  export type Certificate_requestsAvgAggregateInputType = {
    quantity?: true
  }

  export type Certificate_requestsSumAggregateInputType = {
    quantity?: true
  }

  export type Certificate_requestsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    type?: true
    purpose?: true
    quantity?: true
    notes?: true
    status?: true
    rejection_reason?: true
    download_url?: true
    created_at?: true
  }

  export type Certificate_requestsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    type?: true
    purpose?: true
    quantity?: true
    notes?: true
    status?: true
    rejection_reason?: true
    download_url?: true
    created_at?: true
  }

  export type Certificate_requestsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    type?: true
    purpose?: true
    quantity?: true
    notes?: true
    status?: true
    rejection_reason?: true
    download_url?: true
    created_at?: true
    _all?: true
  }

  export type Certificate_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificate_requests to aggregate.
     */
    where?: certificate_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificate_requests to fetch.
     */
    orderBy?: certificate_requestsOrderByWithRelationInput | certificate_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificate_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificate_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificate_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificate_requests
    **/
    _count?: true | Certificate_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Certificate_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Certificate_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Certificate_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Certificate_requestsMaxAggregateInputType
  }

  export type GetCertificate_requestsAggregateType<T extends Certificate_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate_requests[P]>
      : GetScalarType<T[P], AggregateCertificate_requests[P]>
  }




  export type certificate_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificate_requestsWhereInput
    orderBy?: certificate_requestsOrderByWithAggregationInput | certificate_requestsOrderByWithAggregationInput[]
    by: Certificate_requestsScalarFieldEnum[] | Certificate_requestsScalarFieldEnum
    having?: certificate_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Certificate_requestsCountAggregateInputType | true
    _avg?: Certificate_requestsAvgAggregateInputType
    _sum?: Certificate_requestsSumAggregateInputType
    _min?: Certificate_requestsMinAggregateInputType
    _max?: Certificate_requestsMaxAggregateInputType
  }

  export type Certificate_requestsGroupByOutputType = {
    id: string
    tenant_id: string
    student_id: string
    type: string
    purpose: string | null
    quantity: number | null
    notes: string | null
    status: string | null
    rejection_reason: string | null
    download_url: string | null
    created_at: Date | null
    _count: Certificate_requestsCountAggregateOutputType | null
    _avg: Certificate_requestsAvgAggregateOutputType | null
    _sum: Certificate_requestsSumAggregateOutputType | null
    _min: Certificate_requestsMinAggregateOutputType | null
    _max: Certificate_requestsMaxAggregateOutputType | null
  }

  type GetCertificate_requestsGroupByPayload<T extends certificate_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Certificate_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Certificate_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Certificate_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Certificate_requestsGroupByOutputType[P]>
        }
      >
    >


  export type certificate_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    type?: boolean
    purpose?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    rejection_reason?: boolean
    download_url?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate_requests"]>

  export type certificate_requestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    type?: boolean
    purpose?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    rejection_reason?: boolean
    download_url?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate_requests"]>

  export type certificate_requestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    type?: boolean
    purpose?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    rejection_reason?: boolean
    download_url?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate_requests"]>

  export type certificate_requestsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    type?: boolean
    purpose?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    rejection_reason?: boolean
    download_url?: boolean
    created_at?: boolean
  }

  export type certificate_requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "student_id" | "type" | "purpose" | "quantity" | "notes" | "status" | "rejection_reason" | "download_url" | "created_at", ExtArgs["result"]["certificate_requests"]>
  export type certificate_requestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type certificate_requestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type certificate_requestsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $certificate_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificate_requests"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      student_id: string
      type: string
      purpose: string | null
      quantity: number | null
      notes: string | null
      status: string | null
      rejection_reason: string | null
      download_url: string | null
      created_at: Date | null
    }, ExtArgs["result"]["certificate_requests"]>
    composites: {}
  }

  type certificate_requestsGetPayload<S extends boolean | null | undefined | certificate_requestsDefaultArgs> = $Result.GetResult<Prisma.$certificate_requestsPayload, S>

  type certificate_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<certificate_requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Certificate_requestsCountAggregateInputType | true
    }

  export interface certificate_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificate_requests'], meta: { name: 'certificate_requests' } }
    /**
     * Find zero or one Certificate_requests that matches the filter.
     * @param {certificate_requestsFindUniqueArgs} args - Arguments to find a Certificate_requests
     * @example
     * // Get one Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificate_requestsFindUniqueArgs>(args: SelectSubset<T, certificate_requestsFindUniqueArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate_requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {certificate_requestsFindUniqueOrThrowArgs} args - Arguments to find a Certificate_requests
     * @example
     * // Get one Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificate_requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, certificate_requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificate_requestsFindFirstArgs} args - Arguments to find a Certificate_requests
     * @example
     * // Get one Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificate_requestsFindFirstArgs>(args?: SelectSubset<T, certificate_requestsFindFirstArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificate_requestsFindFirstOrThrowArgs} args - Arguments to find a Certificate_requests
     * @example
     * // Get one Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificate_requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, certificate_requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificate_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificate_requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.findMany()
     * 
     * // Get first 10 Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificate_requestsWithIdOnly = await prisma.certificate_requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificate_requestsFindManyArgs>(args?: SelectSubset<T, certificate_requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate_requests.
     * @param {certificate_requestsCreateArgs} args - Arguments to create a Certificate_requests.
     * @example
     * // Create one Certificate_requests
     * const Certificate_requests = await prisma.certificate_requests.create({
     *   data: {
     *     // ... data to create a Certificate_requests
     *   }
     * })
     * 
     */
    create<T extends certificate_requestsCreateArgs>(args: SelectSubset<T, certificate_requestsCreateArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificate_requests.
     * @param {certificate_requestsCreateManyArgs} args - Arguments to create many Certificate_requests.
     * @example
     * // Create many Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificate_requestsCreateManyArgs>(args?: SelectSubset<T, certificate_requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificate_requests and returns the data saved in the database.
     * @param {certificate_requestsCreateManyAndReturnArgs} args - Arguments to create many Certificate_requests.
     * @example
     * // Create many Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificate_requests and only return the `id`
     * const certificate_requestsWithIdOnly = await prisma.certificate_requests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends certificate_requestsCreateManyAndReturnArgs>(args?: SelectSubset<T, certificate_requestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate_requests.
     * @param {certificate_requestsDeleteArgs} args - Arguments to delete one Certificate_requests.
     * @example
     * // Delete one Certificate_requests
     * const Certificate_requests = await prisma.certificate_requests.delete({
     *   where: {
     *     // ... filter to delete one Certificate_requests
     *   }
     * })
     * 
     */
    delete<T extends certificate_requestsDeleteArgs>(args: SelectSubset<T, certificate_requestsDeleteArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate_requests.
     * @param {certificate_requestsUpdateArgs} args - Arguments to update one Certificate_requests.
     * @example
     * // Update one Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificate_requestsUpdateArgs>(args: SelectSubset<T, certificate_requestsUpdateArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificate_requests.
     * @param {certificate_requestsDeleteManyArgs} args - Arguments to filter Certificate_requests to delete.
     * @example
     * // Delete a few Certificate_requests
     * const { count } = await prisma.certificate_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificate_requestsDeleteManyArgs>(args?: SelectSubset<T, certificate_requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificate_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificate_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificate_requestsUpdateManyArgs>(args: SelectSubset<T, certificate_requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificate_requests and returns the data updated in the database.
     * @param {certificate_requestsUpdateManyAndReturnArgs} args - Arguments to update many Certificate_requests.
     * @example
     * // Update many Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificate_requests and only return the `id`
     * const certificate_requestsWithIdOnly = await prisma.certificate_requests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends certificate_requestsUpdateManyAndReturnArgs>(args: SelectSubset<T, certificate_requestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate_requests.
     * @param {certificate_requestsUpsertArgs} args - Arguments to update or create a Certificate_requests.
     * @example
     * // Update or create a Certificate_requests
     * const certificate_requests = await prisma.certificate_requests.upsert({
     *   create: {
     *     // ... data to create a Certificate_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate_requests we want to update
     *   }
     * })
     */
    upsert<T extends certificate_requestsUpsertArgs>(args: SelectSubset<T, certificate_requestsUpsertArgs<ExtArgs>>): Prisma__certificate_requestsClient<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificate_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificate_requestsCountArgs} args - Arguments to filter Certificate_requests to count.
     * @example
     * // Count the number of Certificate_requests
     * const count = await prisma.certificate_requests.count({
     *   where: {
     *     // ... the filter for the Certificate_requests we want to count
     *   }
     * })
    **/
    count<T extends certificate_requestsCountArgs>(
      args?: Subset<T, certificate_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Certificate_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Certificate_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Certificate_requestsAggregateArgs>(args: Subset<T, Certificate_requestsAggregateArgs>): Prisma.PrismaPromise<GetCertificate_requestsAggregateType<T>>

    /**
     * Group by Certificate_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificate_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificate_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificate_requestsGroupByArgs['orderBy'] }
        : { orderBy?: certificate_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificate_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificate_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificate_requests model
   */
  readonly fields: certificate_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificate_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificate_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificate_requests model
   */
  interface certificate_requestsFieldRefs {
    readonly id: FieldRef<"certificate_requests", 'String'>
    readonly tenant_id: FieldRef<"certificate_requests", 'String'>
    readonly student_id: FieldRef<"certificate_requests", 'String'>
    readonly type: FieldRef<"certificate_requests", 'String'>
    readonly purpose: FieldRef<"certificate_requests", 'String'>
    readonly quantity: FieldRef<"certificate_requests", 'Int'>
    readonly notes: FieldRef<"certificate_requests", 'String'>
    readonly status: FieldRef<"certificate_requests", 'String'>
    readonly rejection_reason: FieldRef<"certificate_requests", 'String'>
    readonly download_url: FieldRef<"certificate_requests", 'String'>
    readonly created_at: FieldRef<"certificate_requests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * certificate_requests findUnique
   */
  export type certificate_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * Filter, which certificate_requests to fetch.
     */
    where: certificate_requestsWhereUniqueInput
  }

  /**
   * certificate_requests findUniqueOrThrow
   */
  export type certificate_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * Filter, which certificate_requests to fetch.
     */
    where: certificate_requestsWhereUniqueInput
  }

  /**
   * certificate_requests findFirst
   */
  export type certificate_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * Filter, which certificate_requests to fetch.
     */
    where?: certificate_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificate_requests to fetch.
     */
    orderBy?: certificate_requestsOrderByWithRelationInput | certificate_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificate_requests.
     */
    cursor?: certificate_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificate_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificate_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificate_requests.
     */
    distinct?: Certificate_requestsScalarFieldEnum | Certificate_requestsScalarFieldEnum[]
  }

  /**
   * certificate_requests findFirstOrThrow
   */
  export type certificate_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * Filter, which certificate_requests to fetch.
     */
    where?: certificate_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificate_requests to fetch.
     */
    orderBy?: certificate_requestsOrderByWithRelationInput | certificate_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificate_requests.
     */
    cursor?: certificate_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificate_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificate_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificate_requests.
     */
    distinct?: Certificate_requestsScalarFieldEnum | Certificate_requestsScalarFieldEnum[]
  }

  /**
   * certificate_requests findMany
   */
  export type certificate_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * Filter, which certificate_requests to fetch.
     */
    where?: certificate_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificate_requests to fetch.
     */
    orderBy?: certificate_requestsOrderByWithRelationInput | certificate_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificate_requests.
     */
    cursor?: certificate_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificate_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificate_requests.
     */
    skip?: number
    distinct?: Certificate_requestsScalarFieldEnum | Certificate_requestsScalarFieldEnum[]
  }

  /**
   * certificate_requests create
   */
  export type certificate_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * The data needed to create a certificate_requests.
     */
    data: XOR<certificate_requestsCreateInput, certificate_requestsUncheckedCreateInput>
  }

  /**
   * certificate_requests createMany
   */
  export type certificate_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificate_requests.
     */
    data: certificate_requestsCreateManyInput | certificate_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certificate_requests createManyAndReturn
   */
  export type certificate_requestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * The data used to create many certificate_requests.
     */
    data: certificate_requestsCreateManyInput | certificate_requestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificate_requests update
   */
  export type certificate_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * The data needed to update a certificate_requests.
     */
    data: XOR<certificate_requestsUpdateInput, certificate_requestsUncheckedUpdateInput>
    /**
     * Choose, which certificate_requests to update.
     */
    where: certificate_requestsWhereUniqueInput
  }

  /**
   * certificate_requests updateMany
   */
  export type certificate_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificate_requests.
     */
    data: XOR<certificate_requestsUpdateManyMutationInput, certificate_requestsUncheckedUpdateManyInput>
    /**
     * Filter which certificate_requests to update
     */
    where?: certificate_requestsWhereInput
    /**
     * Limit how many certificate_requests to update.
     */
    limit?: number
  }

  /**
   * certificate_requests updateManyAndReturn
   */
  export type certificate_requestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * The data used to update certificate_requests.
     */
    data: XOR<certificate_requestsUpdateManyMutationInput, certificate_requestsUncheckedUpdateManyInput>
    /**
     * Filter which certificate_requests to update
     */
    where?: certificate_requestsWhereInput
    /**
     * Limit how many certificate_requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificate_requests upsert
   */
  export type certificate_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * The filter to search for the certificate_requests to update in case it exists.
     */
    where: certificate_requestsWhereUniqueInput
    /**
     * In case the certificate_requests found by the `where` argument doesn't exist, create a new certificate_requests with this data.
     */
    create: XOR<certificate_requestsCreateInput, certificate_requestsUncheckedCreateInput>
    /**
     * In case the certificate_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificate_requestsUpdateInput, certificate_requestsUncheckedUpdateInput>
  }

  /**
   * certificate_requests delete
   */
  export type certificate_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    /**
     * Filter which certificate_requests to delete.
     */
    where: certificate_requestsWhereUniqueInput
  }

  /**
   * certificate_requests deleteMany
   */
  export type certificate_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificate_requests to delete
     */
    where?: certificate_requestsWhereInput
    /**
     * Limit how many certificate_requests to delete.
     */
    limit?: number
  }

  /**
   * certificate_requests without action
   */
  export type certificate_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
  }


  /**
   * Model class_schedules
   */

  export type AggregateClass_schedules = {
    _count: Class_schedulesCountAggregateOutputType | null
    _min: Class_schedulesMinAggregateOutputType | null
    _max: Class_schedulesMaxAggregateOutputType | null
  }

  export type Class_schedulesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    class_id: string | null
    day: string | null
    start_time: Date | null
    end_time: Date | null
    room: string | null
    type: string | null
    created_at: Date | null
  }

  export type Class_schedulesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    class_id: string | null
    day: string | null
    start_time: Date | null
    end_time: Date | null
    room: string | null
    type: string | null
    created_at: Date | null
  }

  export type Class_schedulesCountAggregateOutputType = {
    id: number
    tenant_id: number
    class_id: number
    day: number
    start_time: number
    end_time: number
    room: number
    type: number
    created_at: number
    _all: number
  }


  export type Class_schedulesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    day?: true
    start_time?: true
    end_time?: true
    room?: true
    type?: true
    created_at?: true
  }

  export type Class_schedulesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    day?: true
    start_time?: true
    end_time?: true
    room?: true
    type?: true
    created_at?: true
  }

  export type Class_schedulesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    day?: true
    start_time?: true
    end_time?: true
    room?: true
    type?: true
    created_at?: true
    _all?: true
  }

  export type Class_schedulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_schedules to aggregate.
     */
    where?: class_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_schedules to fetch.
     */
    orderBy?: class_schedulesOrderByWithRelationInput | class_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: class_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned class_schedules
    **/
    _count?: true | Class_schedulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Class_schedulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Class_schedulesMaxAggregateInputType
  }

  export type GetClass_schedulesAggregateType<T extends Class_schedulesAggregateArgs> = {
        [P in keyof T & keyof AggregateClass_schedules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass_schedules[P]>
      : GetScalarType<T[P], AggregateClass_schedules[P]>
  }




  export type class_schedulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_schedulesWhereInput
    orderBy?: class_schedulesOrderByWithAggregationInput | class_schedulesOrderByWithAggregationInput[]
    by: Class_schedulesScalarFieldEnum[] | Class_schedulesScalarFieldEnum
    having?: class_schedulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Class_schedulesCountAggregateInputType | true
    _min?: Class_schedulesMinAggregateInputType
    _max?: Class_schedulesMaxAggregateInputType
  }

  export type Class_schedulesGroupByOutputType = {
    id: string
    tenant_id: string
    class_id: string
    day: string
    start_time: Date
    end_time: Date
    room: string | null
    type: string | null
    created_at: Date | null
    _count: Class_schedulesCountAggregateOutputType | null
    _min: Class_schedulesMinAggregateOutputType | null
    _max: Class_schedulesMaxAggregateOutputType | null
  }

  type GetClass_schedulesGroupByPayload<T extends class_schedulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Class_schedulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Class_schedulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Class_schedulesGroupByOutputType[P]>
            : GetScalarType<T[P], Class_schedulesGroupByOutputType[P]>
        }
      >
    >


  export type class_schedulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    type?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_schedules"]>

  export type class_schedulesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    type?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_schedules"]>

  export type class_schedulesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    type?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_schedules"]>

  export type class_schedulesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    day?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    type?: boolean
    created_at?: boolean
  }

  export type class_schedulesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "class_id" | "day" | "start_time" | "end_time" | "room" | "type" | "created_at", ExtArgs["result"]["class_schedules"]>
  export type class_schedulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }
  export type class_schedulesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }
  export type class_schedulesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }

  export type $class_schedulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "class_schedules"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      class_id: string
      day: string
      start_time: Date
      end_time: Date
      room: string | null
      type: string | null
      created_at: Date | null
    }, ExtArgs["result"]["class_schedules"]>
    composites: {}
  }

  type class_schedulesGetPayload<S extends boolean | null | undefined | class_schedulesDefaultArgs> = $Result.GetResult<Prisma.$class_schedulesPayload, S>

  type class_schedulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<class_schedulesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Class_schedulesCountAggregateInputType | true
    }

  export interface class_schedulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['class_schedules'], meta: { name: 'class_schedules' } }
    /**
     * Find zero or one Class_schedules that matches the filter.
     * @param {class_schedulesFindUniqueArgs} args - Arguments to find a Class_schedules
     * @example
     * // Get one Class_schedules
     * const class_schedules = await prisma.class_schedules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends class_schedulesFindUniqueArgs>(args: SelectSubset<T, class_schedulesFindUniqueArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class_schedules that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {class_schedulesFindUniqueOrThrowArgs} args - Arguments to find a Class_schedules
     * @example
     * // Get one Class_schedules
     * const class_schedules = await prisma.class_schedules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends class_schedulesFindUniqueOrThrowArgs>(args: SelectSubset<T, class_schedulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_schedulesFindFirstArgs} args - Arguments to find a Class_schedules
     * @example
     * // Get one Class_schedules
     * const class_schedules = await prisma.class_schedules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends class_schedulesFindFirstArgs>(args?: SelectSubset<T, class_schedulesFindFirstArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_schedules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_schedulesFindFirstOrThrowArgs} args - Arguments to find a Class_schedules
     * @example
     * // Get one Class_schedules
     * const class_schedules = await prisma.class_schedules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends class_schedulesFindFirstOrThrowArgs>(args?: SelectSubset<T, class_schedulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Class_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_schedulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Class_schedules
     * const class_schedules = await prisma.class_schedules.findMany()
     * 
     * // Get first 10 Class_schedules
     * const class_schedules = await prisma.class_schedules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const class_schedulesWithIdOnly = await prisma.class_schedules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends class_schedulesFindManyArgs>(args?: SelectSubset<T, class_schedulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class_schedules.
     * @param {class_schedulesCreateArgs} args - Arguments to create a Class_schedules.
     * @example
     * // Create one Class_schedules
     * const Class_schedules = await prisma.class_schedules.create({
     *   data: {
     *     // ... data to create a Class_schedules
     *   }
     * })
     * 
     */
    create<T extends class_schedulesCreateArgs>(args: SelectSubset<T, class_schedulesCreateArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Class_schedules.
     * @param {class_schedulesCreateManyArgs} args - Arguments to create many Class_schedules.
     * @example
     * // Create many Class_schedules
     * const class_schedules = await prisma.class_schedules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends class_schedulesCreateManyArgs>(args?: SelectSubset<T, class_schedulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Class_schedules and returns the data saved in the database.
     * @param {class_schedulesCreateManyAndReturnArgs} args - Arguments to create many Class_schedules.
     * @example
     * // Create many Class_schedules
     * const class_schedules = await prisma.class_schedules.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Class_schedules and only return the `id`
     * const class_schedulesWithIdOnly = await prisma.class_schedules.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends class_schedulesCreateManyAndReturnArgs>(args?: SelectSubset<T, class_schedulesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class_schedules.
     * @param {class_schedulesDeleteArgs} args - Arguments to delete one Class_schedules.
     * @example
     * // Delete one Class_schedules
     * const Class_schedules = await prisma.class_schedules.delete({
     *   where: {
     *     // ... filter to delete one Class_schedules
     *   }
     * })
     * 
     */
    delete<T extends class_schedulesDeleteArgs>(args: SelectSubset<T, class_schedulesDeleteArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class_schedules.
     * @param {class_schedulesUpdateArgs} args - Arguments to update one Class_schedules.
     * @example
     * // Update one Class_schedules
     * const class_schedules = await prisma.class_schedules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends class_schedulesUpdateArgs>(args: SelectSubset<T, class_schedulesUpdateArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Class_schedules.
     * @param {class_schedulesDeleteManyArgs} args - Arguments to filter Class_schedules to delete.
     * @example
     * // Delete a few Class_schedules
     * const { count } = await prisma.class_schedules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends class_schedulesDeleteManyArgs>(args?: SelectSubset<T, class_schedulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_schedulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Class_schedules
     * const class_schedules = await prisma.class_schedules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends class_schedulesUpdateManyArgs>(args: SelectSubset<T, class_schedulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_schedules and returns the data updated in the database.
     * @param {class_schedulesUpdateManyAndReturnArgs} args - Arguments to update many Class_schedules.
     * @example
     * // Update many Class_schedules
     * const class_schedules = await prisma.class_schedules.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Class_schedules and only return the `id`
     * const class_schedulesWithIdOnly = await prisma.class_schedules.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends class_schedulesUpdateManyAndReturnArgs>(args: SelectSubset<T, class_schedulesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class_schedules.
     * @param {class_schedulesUpsertArgs} args - Arguments to update or create a Class_schedules.
     * @example
     * // Update or create a Class_schedules
     * const class_schedules = await prisma.class_schedules.upsert({
     *   create: {
     *     // ... data to create a Class_schedules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class_schedules we want to update
     *   }
     * })
     */
    upsert<T extends class_schedulesUpsertArgs>(args: SelectSubset<T, class_schedulesUpsertArgs<ExtArgs>>): Prisma__class_schedulesClient<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Class_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_schedulesCountArgs} args - Arguments to filter Class_schedules to count.
     * @example
     * // Count the number of Class_schedules
     * const count = await prisma.class_schedules.count({
     *   where: {
     *     // ... the filter for the Class_schedules we want to count
     *   }
     * })
    **/
    count<T extends class_schedulesCountArgs>(
      args?: Subset<T, class_schedulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Class_schedulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_schedulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Class_schedulesAggregateArgs>(args: Subset<T, Class_schedulesAggregateArgs>): Prisma.PrismaPromise<GetClass_schedulesAggregateType<T>>

    /**
     * Group by Class_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_schedulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends class_schedulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: class_schedulesGroupByArgs['orderBy'] }
        : { orderBy?: class_schedulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, class_schedulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClass_schedulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the class_schedules model
   */
  readonly fields: class_schedulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for class_schedules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__class_schedulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends classesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classesDefaultArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the class_schedules model
   */
  interface class_schedulesFieldRefs {
    readonly id: FieldRef<"class_schedules", 'String'>
    readonly tenant_id: FieldRef<"class_schedules", 'String'>
    readonly class_id: FieldRef<"class_schedules", 'String'>
    readonly day: FieldRef<"class_schedules", 'String'>
    readonly start_time: FieldRef<"class_schedules", 'DateTime'>
    readonly end_time: FieldRef<"class_schedules", 'DateTime'>
    readonly room: FieldRef<"class_schedules", 'String'>
    readonly type: FieldRef<"class_schedules", 'String'>
    readonly created_at: FieldRef<"class_schedules", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * class_schedules findUnique
   */
  export type class_schedulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which class_schedules to fetch.
     */
    where: class_schedulesWhereUniqueInput
  }

  /**
   * class_schedules findUniqueOrThrow
   */
  export type class_schedulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which class_schedules to fetch.
     */
    where: class_schedulesWhereUniqueInput
  }

  /**
   * class_schedules findFirst
   */
  export type class_schedulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which class_schedules to fetch.
     */
    where?: class_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_schedules to fetch.
     */
    orderBy?: class_schedulesOrderByWithRelationInput | class_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_schedules.
     */
    cursor?: class_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_schedules.
     */
    distinct?: Class_schedulesScalarFieldEnum | Class_schedulesScalarFieldEnum[]
  }

  /**
   * class_schedules findFirstOrThrow
   */
  export type class_schedulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which class_schedules to fetch.
     */
    where?: class_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_schedules to fetch.
     */
    orderBy?: class_schedulesOrderByWithRelationInput | class_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_schedules.
     */
    cursor?: class_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_schedules.
     */
    distinct?: Class_schedulesScalarFieldEnum | Class_schedulesScalarFieldEnum[]
  }

  /**
   * class_schedules findMany
   */
  export type class_schedulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which class_schedules to fetch.
     */
    where?: class_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_schedules to fetch.
     */
    orderBy?: class_schedulesOrderByWithRelationInput | class_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing class_schedules.
     */
    cursor?: class_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_schedules.
     */
    skip?: number
    distinct?: Class_schedulesScalarFieldEnum | Class_schedulesScalarFieldEnum[]
  }

  /**
   * class_schedules create
   */
  export type class_schedulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * The data needed to create a class_schedules.
     */
    data: XOR<class_schedulesCreateInput, class_schedulesUncheckedCreateInput>
  }

  /**
   * class_schedules createMany
   */
  export type class_schedulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many class_schedules.
     */
    data: class_schedulesCreateManyInput | class_schedulesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * class_schedules createManyAndReturn
   */
  export type class_schedulesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * The data used to create many class_schedules.
     */
    data: class_schedulesCreateManyInput | class_schedulesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_schedules update
   */
  export type class_schedulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * The data needed to update a class_schedules.
     */
    data: XOR<class_schedulesUpdateInput, class_schedulesUncheckedUpdateInput>
    /**
     * Choose, which class_schedules to update.
     */
    where: class_schedulesWhereUniqueInput
  }

  /**
   * class_schedules updateMany
   */
  export type class_schedulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update class_schedules.
     */
    data: XOR<class_schedulesUpdateManyMutationInput, class_schedulesUncheckedUpdateManyInput>
    /**
     * Filter which class_schedules to update
     */
    where?: class_schedulesWhereInput
    /**
     * Limit how many class_schedules to update.
     */
    limit?: number
  }

  /**
   * class_schedules updateManyAndReturn
   */
  export type class_schedulesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * The data used to update class_schedules.
     */
    data: XOR<class_schedulesUpdateManyMutationInput, class_schedulesUncheckedUpdateManyInput>
    /**
     * Filter which class_schedules to update
     */
    where?: class_schedulesWhereInput
    /**
     * Limit how many class_schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_schedules upsert
   */
  export type class_schedulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * The filter to search for the class_schedules to update in case it exists.
     */
    where: class_schedulesWhereUniqueInput
    /**
     * In case the class_schedules found by the `where` argument doesn't exist, create a new class_schedules with this data.
     */
    create: XOR<class_schedulesCreateInput, class_schedulesUncheckedCreateInput>
    /**
     * In case the class_schedules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<class_schedulesUpdateInput, class_schedulesUncheckedUpdateInput>
  }

  /**
   * class_schedules delete
   */
  export type class_schedulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    /**
     * Filter which class_schedules to delete.
     */
    where: class_schedulesWhereUniqueInput
  }

  /**
   * class_schedules deleteMany
   */
  export type class_schedulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_schedules to delete
     */
    where?: class_schedulesWhereInput
    /**
     * Limit how many class_schedules to delete.
     */
    limit?: number
  }

  /**
   * class_schedules without action
   */
  export type class_schedulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
  }


  /**
   * Model classes
   */

  export type AggregateClasses = {
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  export type ClassesAvgAggregateOutputType = {
    year: number | null
    capacity: number | null
  }

  export type ClassesSumAggregateOutputType = {
    year: number | null
    capacity: number | null
  }

  export type ClassesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    course_id: string | null
    lecturer_id: string | null
    semester: string | null
    year: number | null
    capacity: number | null
    created_at: Date | null
  }

  export type ClassesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    course_id: string | null
    lecturer_id: string | null
    semester: string | null
    year: number | null
    capacity: number | null
    created_at: Date | null
  }

  export type ClassesCountAggregateOutputType = {
    id: number
    tenant_id: number
    course_id: number
    lecturer_id: number
    semester: number
    year: number
    capacity: number
    created_at: number
    _all: number
  }


  export type ClassesAvgAggregateInputType = {
    year?: true
    capacity?: true
  }

  export type ClassesSumAggregateInputType = {
    year?: true
    capacity?: true
  }

  export type ClassesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    course_id?: true
    lecturer_id?: true
    semester?: true
    year?: true
    capacity?: true
    created_at?: true
  }

  export type ClassesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    course_id?: true
    lecturer_id?: true
    semester?: true
    year?: true
    capacity?: true
    created_at?: true
  }

  export type ClassesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    course_id?: true
    lecturer_id?: true
    semester?: true
    year?: true
    capacity?: true
    created_at?: true
    _all?: true
  }

  export type ClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes to aggregate.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned classes
    **/
    _count?: true | ClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassesMaxAggregateInputType
  }

  export type GetClassesAggregateType<T extends ClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses[P]>
      : GetScalarType<T[P], AggregateClasses[P]>
  }




  export type classesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
    orderBy?: classesOrderByWithAggregationInput | classesOrderByWithAggregationInput[]
    by: ClassesScalarFieldEnum[] | ClassesScalarFieldEnum
    having?: classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassesCountAggregateInputType | true
    _avg?: ClassesAvgAggregateInputType
    _sum?: ClassesSumAggregateInputType
    _min?: ClassesMinAggregateInputType
    _max?: ClassesMaxAggregateInputType
  }

  export type ClassesGroupByOutputType = {
    id: string
    tenant_id: string
    course_id: string
    lecturer_id: string | null
    semester: string
    year: number
    capacity: number | null
    created_at: Date | null
    _count: ClassesCountAggregateOutputType | null
    _avg: ClassesAvgAggregateOutputType | null
    _sum: ClassesSumAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  type GetClassesGroupByPayload<T extends classesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassesGroupByOutputType[P]>
            : GetScalarType<T[P], ClassesGroupByOutputType[P]>
        }
      >
    >


  export type classesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    course_id?: boolean
    lecturer_id?: boolean
    semester?: boolean
    year?: boolean
    capacity?: boolean
    created_at?: boolean
    attendances?: boolean | classes$attendancesArgs<ExtArgs>
    class_schedules?: boolean | classes$class_schedulesArgs<ExtArgs>
    courses?: boolean | coursesDefaultArgs<ExtArgs>
    lecturers?: boolean | classes$lecturersArgs<ExtArgs>
    enrollments?: boolean | classes$enrollmentsArgs<ExtArgs>
    exams?: boolean | classes$examsArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>

  export type classesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    course_id?: boolean
    lecturer_id?: boolean
    semester?: boolean
    year?: boolean
    capacity?: boolean
    created_at?: boolean
    courses?: boolean | coursesDefaultArgs<ExtArgs>
    lecturers?: boolean | classes$lecturersArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>

  export type classesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    course_id?: boolean
    lecturer_id?: boolean
    semester?: boolean
    year?: boolean
    capacity?: boolean
    created_at?: boolean
    courses?: boolean | coursesDefaultArgs<ExtArgs>
    lecturers?: boolean | classes$lecturersArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>

  export type classesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    course_id?: boolean
    lecturer_id?: boolean
    semester?: boolean
    year?: boolean
    capacity?: boolean
    created_at?: boolean
  }

  export type classesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "course_id" | "lecturer_id" | "semester" | "year" | "capacity" | "created_at", ExtArgs["result"]["classes"]>
  export type classesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | classes$attendancesArgs<ExtArgs>
    class_schedules?: boolean | classes$class_schedulesArgs<ExtArgs>
    courses?: boolean | coursesDefaultArgs<ExtArgs>
    lecturers?: boolean | classes$lecturersArgs<ExtArgs>
    enrollments?: boolean | classes$enrollmentsArgs<ExtArgs>
    exams?: boolean | classes$examsArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type classesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | coursesDefaultArgs<ExtArgs>
    lecturers?: boolean | classes$lecturersArgs<ExtArgs>
  }
  export type classesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | coursesDefaultArgs<ExtArgs>
    lecturers?: boolean | classes$lecturersArgs<ExtArgs>
  }

  export type $classesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "classes"
    objects: {
      attendances: Prisma.$attendancesPayload<ExtArgs>[]
      class_schedules: Prisma.$class_schedulesPayload<ExtArgs>[]
      courses: Prisma.$coursesPayload<ExtArgs>
      lecturers: Prisma.$lecturersPayload<ExtArgs> | null
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      course_id: string
      lecturer_id: string | null
      semester: string
      year: number
      capacity: number | null
      created_at: Date | null
    }, ExtArgs["result"]["classes"]>
    composites: {}
  }

  type classesGetPayload<S extends boolean | null | undefined | classesDefaultArgs> = $Result.GetResult<Prisma.$classesPayload, S>

  type classesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<classesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassesCountAggregateInputType | true
    }

  export interface classesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['classes'], meta: { name: 'classes' } }
    /**
     * Find zero or one Classes that matches the filter.
     * @param {classesFindUniqueArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classesFindUniqueArgs>(args: SelectSubset<T, classesFindUniqueArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classesFindUniqueOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classesFindUniqueOrThrowArgs>(args: SelectSubset<T, classesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classesFindFirstArgs>(args?: SelectSubset<T, classesFindFirstArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classesFindFirstOrThrowArgs>(args?: SelectSubset<T, classesFindFirstOrThrowArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classes.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classesWithIdOnly = await prisma.classes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends classesFindManyArgs>(args?: SelectSubset<T, classesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classes.
     * @param {classesCreateArgs} args - Arguments to create a Classes.
     * @example
     * // Create one Classes
     * const Classes = await prisma.classes.create({
     *   data: {
     *     // ... data to create a Classes
     *   }
     * })
     * 
     */
    create<T extends classesCreateArgs>(args: SelectSubset<T, classesCreateArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {classesCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends classesCreateManyArgs>(args?: SelectSubset<T, classesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {classesCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classesWithIdOnly = await prisma.classes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends classesCreateManyAndReturnArgs>(args?: SelectSubset<T, classesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classes.
     * @param {classesDeleteArgs} args - Arguments to delete one Classes.
     * @example
     * // Delete one Classes
     * const Classes = await prisma.classes.delete({
     *   where: {
     *     // ... filter to delete one Classes
     *   }
     * })
     * 
     */
    delete<T extends classesDeleteArgs>(args: SelectSubset<T, classesDeleteArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classes.
     * @param {classesUpdateArgs} args - Arguments to update one Classes.
     * @example
     * // Update one Classes
     * const classes = await prisma.classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends classesUpdateArgs>(args: SelectSubset<T, classesUpdateArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {classesDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends classesDeleteManyArgs>(args?: SelectSubset<T, classesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends classesUpdateManyArgs>(args: SelectSubset<T, classesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {classesUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classesWithIdOnly = await prisma.classes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends classesUpdateManyAndReturnArgs>(args: SelectSubset<T, classesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classes.
     * @param {classesUpsertArgs} args - Arguments to update or create a Classes.
     * @example
     * // Update or create a Classes
     * const classes = await prisma.classes.upsert({
     *   create: {
     *     // ... data to create a Classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes we want to update
     *   }
     * })
     */
    upsert<T extends classesUpsertArgs>(args: SelectSubset<T, classesUpsertArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classes.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends classesCountArgs>(
      args?: Subset<T, classesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassesAggregateArgs>(args: Subset<T, ClassesAggregateArgs>): Prisma.PrismaPromise<GetClassesAggregateType<T>>

    /**
     * Group by Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends classesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classesGroupByArgs['orderBy'] }
        : { orderBy?: classesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, classesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the classes model
   */
  readonly fields: classesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends classes$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, classes$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class_schedules<T extends classes$class_schedulesArgs<ExtArgs> = {}>(args?: Subset<T, classes$class_schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_schedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends coursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, coursesDefaultArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturers<T extends classes$lecturersArgs<ExtArgs> = {}>(args?: Subset<T, classes$lecturersArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends classes$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, classes$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends classes$examsArgs<ExtArgs> = {}>(args?: Subset<T, classes$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the classes model
   */
  interface classesFieldRefs {
    readonly id: FieldRef<"classes", 'String'>
    readonly tenant_id: FieldRef<"classes", 'String'>
    readonly course_id: FieldRef<"classes", 'String'>
    readonly lecturer_id: FieldRef<"classes", 'String'>
    readonly semester: FieldRef<"classes", 'String'>
    readonly year: FieldRef<"classes", 'Int'>
    readonly capacity: FieldRef<"classes", 'Int'>
    readonly created_at: FieldRef<"classes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * classes findUnique
   */
  export type classesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes findUniqueOrThrow
   */
  export type classesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes findFirst
   */
  export type classesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes findFirstOrThrow
   */
  export type classesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes findMany
   */
  export type classesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes create
   */
  export type classesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The data needed to create a classes.
     */
    data: XOR<classesCreateInput, classesUncheckedCreateInput>
  }

  /**
   * classes createMany
   */
  export type classesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many classes.
     */
    data: classesCreateManyInput | classesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * classes createManyAndReturn
   */
  export type classesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * The data used to create many classes.
     */
    data: classesCreateManyInput | classesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * classes update
   */
  export type classesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The data needed to update a classes.
     */
    data: XOR<classesUpdateInput, classesUncheckedUpdateInput>
    /**
     * Choose, which classes to update.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes updateMany
   */
  export type classesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update classes.
     */
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyInput>
    /**
     * Filter which classes to update
     */
    where?: classesWhereInput
    /**
     * Limit how many classes to update.
     */
    limit?: number
  }

  /**
   * classes updateManyAndReturn
   */
  export type classesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * The data used to update classes.
     */
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyInput>
    /**
     * Filter which classes to update
     */
    where?: classesWhereInput
    /**
     * Limit how many classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * classes upsert
   */
  export type classesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The filter to search for the classes to update in case it exists.
     */
    where: classesWhereUniqueInput
    /**
     * In case the classes found by the `where` argument doesn't exist, create a new classes with this data.
     */
    create: XOR<classesCreateInput, classesUncheckedCreateInput>
    /**
     * In case the classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classesUpdateInput, classesUncheckedUpdateInput>
  }

  /**
   * classes delete
   */
  export type classesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter which classes to delete.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes deleteMany
   */
  export type classesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes to delete
     */
    where?: classesWhereInput
    /**
     * Limit how many classes to delete.
     */
    limit?: number
  }

  /**
   * classes.attendances
   */
  export type classes$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    where?: attendancesWhereInput
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    cursor?: attendancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * classes.class_schedules
   */
  export type classes$class_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_schedules
     */
    select?: class_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_schedules
     */
    omit?: class_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_schedulesInclude<ExtArgs> | null
    where?: class_schedulesWhereInput
    orderBy?: class_schedulesOrderByWithRelationInput | class_schedulesOrderByWithRelationInput[]
    cursor?: class_schedulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Class_schedulesScalarFieldEnum | Class_schedulesScalarFieldEnum[]
  }

  /**
   * classes.lecturers
   */
  export type classes$lecturersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    where?: lecturersWhereInput
  }

  /**
   * classes.enrollments
   */
  export type classes$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * classes.exams
   */
  export type classes$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    cursor?: examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * classes without action
   */
  export type classesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
  }


  /**
   * Model courses
   */

  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesAvgAggregateOutputType = {
    credits: number | null
  }

  export type CoursesSumAggregateOutputType = {
    credits: number | null
  }

  export type CoursesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    code: string | null
    name: string | null
    credits: number | null
    created_at: Date | null
  }

  export type CoursesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    code: string | null
    name: string | null
    credits: number | null
    created_at: Date | null
  }

  export type CoursesCountAggregateOutputType = {
    id: number
    tenant_id: number
    code: number
    name: number
    credits: number
    created_at: number
    _all: number
  }


  export type CoursesAvgAggregateInputType = {
    credits?: true
  }

  export type CoursesSumAggregateInputType = {
    credits?: true
  }

  export type CoursesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    code?: true
    name?: true
    credits?: true
    created_at?: true
  }

  export type CoursesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    code?: true
    name?: true
    credits?: true
    created_at?: true
  }

  export type CoursesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    code?: true
    name?: true
    credits?: true
    created_at?: true
    _all?: true
  }

  export type CoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to aggregate.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type coursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coursesWhereInput
    orderBy?: coursesOrderByWithAggregationInput | coursesOrderByWithAggregationInput[]
    by: CoursesScalarFieldEnum[] | CoursesScalarFieldEnum
    having?: coursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _avg?: CoursesAvgAggregateInputType
    _sum?: CoursesSumAggregateInputType
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }

  export type CoursesGroupByOutputType = {
    id: string
    tenant_id: string
    code: string
    name: string
    credits: number
    created_at: Date | null
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends coursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type coursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    credits?: boolean
    created_at?: boolean
    classes?: boolean | courses$classesArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    credits?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    credits?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    credits?: boolean
    created_at?: boolean
  }

  export type coursesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "code" | "name" | "credits" | "created_at", ExtArgs["result"]["courses"]>
  export type coursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | courses$classesArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type coursesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type coursesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $coursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "courses"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      code: string
      name: string
      credits: number
      created_at: Date | null
    }, ExtArgs["result"]["courses"]>
    composites: {}
  }

  type coursesGetPayload<S extends boolean | null | undefined | coursesDefaultArgs> = $Result.GetResult<Prisma.$coursesPayload, S>

  type coursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coursesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoursesCountAggregateInputType | true
    }

  export interface coursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['courses'], meta: { name: 'courses' } }
    /**
     * Find zero or one Courses that matches the filter.
     * @param {coursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coursesFindUniqueArgs>(args: SelectSubset<T, coursesFindUniqueArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Courses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coursesFindUniqueOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coursesFindUniqueOrThrowArgs>(args: SelectSubset<T, coursesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coursesFindFirstArgs>(args?: SelectSubset<T, coursesFindFirstArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindFirstOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coursesFindFirstOrThrowArgs>(args?: SelectSubset<T, coursesFindFirstOrThrowArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursesWithIdOnly = await prisma.courses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coursesFindManyArgs>(args?: SelectSubset<T, coursesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Courses.
     * @param {coursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
     */
    create<T extends coursesCreateArgs>(args: SelectSubset<T, coursesCreateArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {coursesCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coursesCreateManyArgs>(args?: SelectSubset<T, coursesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {coursesCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const coursesWithIdOnly = await prisma.courses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends coursesCreateManyAndReturnArgs>(args?: SelectSubset<T, coursesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Courses.
     * @param {coursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
     */
    delete<T extends coursesDeleteArgs>(args: SelectSubset<T, coursesDeleteArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Courses.
     * @param {coursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coursesUpdateArgs>(args: SelectSubset<T, coursesUpdateArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {coursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coursesDeleteManyArgs>(args?: SelectSubset<T, coursesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coursesUpdateManyArgs>(args: SelectSubset<T, coursesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {coursesUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const coursesWithIdOnly = await prisma.courses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends coursesUpdateManyAndReturnArgs>(args: SelectSubset<T, coursesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Courses.
     * @param {coursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
     */
    upsert<T extends coursesUpsertArgs>(args: SelectSubset<T, coursesUpsertArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends coursesCountArgs>(
      args?: Subset<T, coursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): Prisma.PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coursesGroupByArgs['orderBy'] }
        : { orderBy?: coursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the courses model
   */
  readonly fields: coursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends courses$classesArgs<ExtArgs> = {}>(args?: Subset<T, courses$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the courses model
   */
  interface coursesFieldRefs {
    readonly id: FieldRef<"courses", 'String'>
    readonly tenant_id: FieldRef<"courses", 'String'>
    readonly code: FieldRef<"courses", 'String'>
    readonly name: FieldRef<"courses", 'String'>
    readonly credits: FieldRef<"courses", 'Int'>
    readonly created_at: FieldRef<"courses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * courses findUnique
   */
  export type coursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses findUniqueOrThrow
   */
  export type coursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses findFirst
   */
  export type coursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses findFirstOrThrow
   */
  export type coursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses findMany
   */
  export type coursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses create
   */
  export type coursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The data needed to create a courses.
     */
    data: XOR<coursesCreateInput, coursesUncheckedCreateInput>
  }

  /**
   * courses createMany
   */
  export type coursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courses.
     */
    data: coursesCreateManyInput | coursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courses createManyAndReturn
   */
  export type coursesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * The data used to create many courses.
     */
    data: coursesCreateManyInput | coursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courses update
   */
  export type coursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The data needed to update a courses.
     */
    data: XOR<coursesUpdateInput, coursesUncheckedUpdateInput>
    /**
     * Choose, which courses to update.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses updateMany
   */
  export type coursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courses.
     */
    data: XOR<coursesUpdateManyMutationInput, coursesUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     */
    where?: coursesWhereInput
    /**
     * Limit how many courses to update.
     */
    limit?: number
  }

  /**
   * courses updateManyAndReturn
   */
  export type coursesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * The data used to update courses.
     */
    data: XOR<coursesUpdateManyMutationInput, coursesUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     */
    where?: coursesWhereInput
    /**
     * Limit how many courses to update.
     */
    limit?: number
  }

  /**
   * courses upsert
   */
  export type coursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The filter to search for the courses to update in case it exists.
     */
    where: coursesWhereUniqueInput
    /**
     * In case the courses found by the `where` argument doesn't exist, create a new courses with this data.
     */
    create: XOR<coursesCreateInput, coursesUncheckedCreateInput>
    /**
     * In case the courses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coursesUpdateInput, coursesUncheckedUpdateInput>
  }

  /**
   * courses delete
   */
  export type coursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter which courses to delete.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses deleteMany
   */
  export type coursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to delete
     */
    where?: coursesWhereInput
    /**
     * Limit how many courses to delete.
     */
    limit?: number
  }

  /**
   * courses.classes
   */
  export type courses$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    cursor?: classesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * courses without action
   */
  export type coursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
  }


  /**
   * Model enrollments
   */

  export type AggregateEnrollments = {
    _count: EnrollmentsCountAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  export type EnrollmentsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    class_id: string | null
    status: string | null
    created_at: Date | null
  }

  export type EnrollmentsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    class_id: string | null
    status: string | null
    created_at: Date | null
  }

  export type EnrollmentsCountAggregateOutputType = {
    id: number
    tenant_id: number
    student_id: number
    class_id: number
    status: number
    created_at: number
    _all: number
  }


  export type EnrollmentsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    class_id?: true
    status?: true
    created_at?: true
  }

  export type EnrollmentsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    class_id?: true
    status?: true
    created_at?: true
  }

  export type EnrollmentsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    class_id?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type EnrollmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to aggregate.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enrollments
    **/
    _count?: true | EnrollmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type GetEnrollmentsAggregateType<T extends EnrollmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollments[P]>
      : GetScalarType<T[P], AggregateEnrollments[P]>
  }




  export type enrollmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithAggregationInput | enrollmentsOrderByWithAggregationInput[]
    by: EnrollmentsScalarFieldEnum[] | EnrollmentsScalarFieldEnum
    having?: enrollmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentsCountAggregateInputType | true
    _min?: EnrollmentsMinAggregateInputType
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type EnrollmentsGroupByOutputType = {
    id: string
    tenant_id: string
    student_id: string
    class_id: string
    status: string | null
    created_at: Date | null
    _count: EnrollmentsCountAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  type GetEnrollmentsGroupByPayload<T extends enrollmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
        }
      >
    >


  export type enrollmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    class_id?: boolean
    status?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    grades?: boolean | enrollments$gradesArgs<ExtArgs>
    _count?: boolean | EnrollmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    class_id?: boolean
    status?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    class_id?: boolean
    status?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    class_id?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type enrollmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "student_id" | "class_id" | "status" | "created_at", ExtArgs["result"]["enrollments"]>
  export type enrollmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    grades?: boolean | enrollments$gradesArgs<ExtArgs>
    _count?: boolean | EnrollmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type enrollmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type enrollmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $enrollmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "enrollments"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
      grades: Prisma.$gradesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      student_id: string
      class_id: string
      status: string | null
      created_at: Date | null
    }, ExtArgs["result"]["enrollments"]>
    composites: {}
  }

  type enrollmentsGetPayload<S extends boolean | null | undefined | enrollmentsDefaultArgs> = $Result.GetResult<Prisma.$enrollmentsPayload, S>

  type enrollmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<enrollmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentsCountAggregateInputType | true
    }

  export interface enrollmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['enrollments'], meta: { name: 'enrollments' } }
    /**
     * Find zero or one Enrollments that matches the filter.
     * @param {enrollmentsFindUniqueArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enrollmentsFindUniqueArgs>(args: SelectSubset<T, enrollmentsFindUniqueArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {enrollmentsFindUniqueOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enrollmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, enrollmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindFirstArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enrollmentsFindFirstArgs>(args?: SelectSubset<T, enrollmentsFindFirstArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindFirstOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enrollmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, enrollmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollments.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends enrollmentsFindManyArgs>(args?: SelectSubset<T, enrollmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollments.
     * @param {enrollmentsCreateArgs} args - Arguments to create a Enrollments.
     * @example
     * // Create one Enrollments
     * const Enrollments = await prisma.enrollments.create({
     *   data: {
     *     // ... data to create a Enrollments
     *   }
     * })
     * 
     */
    create<T extends enrollmentsCreateArgs>(args: SelectSubset<T, enrollmentsCreateArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {enrollmentsCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enrollmentsCreateManyArgs>(args?: SelectSubset<T, enrollmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {enrollmentsCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends enrollmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, enrollmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollments.
     * @param {enrollmentsDeleteArgs} args - Arguments to delete one Enrollments.
     * @example
     * // Delete one Enrollments
     * const Enrollments = await prisma.enrollments.delete({
     *   where: {
     *     // ... filter to delete one Enrollments
     *   }
     * })
     * 
     */
    delete<T extends enrollmentsDeleteArgs>(args: SelectSubset<T, enrollmentsDeleteArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollments.
     * @param {enrollmentsUpdateArgs} args - Arguments to update one Enrollments.
     * @example
     * // Update one Enrollments
     * const enrollments = await prisma.enrollments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enrollmentsUpdateArgs>(args: SelectSubset<T, enrollmentsUpdateArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {enrollmentsDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enrollmentsDeleteManyArgs>(args?: SelectSubset<T, enrollmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enrollmentsUpdateManyArgs>(args: SelectSubset<T, enrollmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {enrollmentsUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends enrollmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, enrollmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollments.
     * @param {enrollmentsUpsertArgs} args - Arguments to update or create a Enrollments.
     * @example
     * // Update or create a Enrollments
     * const enrollments = await prisma.enrollments.upsert({
     *   create: {
     *     // ... data to create a Enrollments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollments we want to update
     *   }
     * })
     */
    upsert<T extends enrollmentsUpsertArgs>(args: SelectSubset<T, enrollmentsUpsertArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollments.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends enrollmentsCountArgs>(
      args?: Subset<T, enrollmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentsAggregateArgs>(args: Subset<T, EnrollmentsAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentsAggregateType<T>>

    /**
     * Group by Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enrollmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enrollmentsGroupByArgs['orderBy'] }
        : { orderBy?: enrollmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enrollmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the enrollments model
   */
  readonly fields: enrollmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for enrollments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enrollmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends classesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classesDefaultArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grades<T extends enrollments$gradesArgs<ExtArgs> = {}>(args?: Subset<T, enrollments$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the enrollments model
   */
  interface enrollmentsFieldRefs {
    readonly id: FieldRef<"enrollments", 'String'>
    readonly tenant_id: FieldRef<"enrollments", 'String'>
    readonly student_id: FieldRef<"enrollments", 'String'>
    readonly class_id: FieldRef<"enrollments", 'String'>
    readonly status: FieldRef<"enrollments", 'String'>
    readonly created_at: FieldRef<"enrollments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * enrollments findUnique
   */
  export type enrollmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments findUniqueOrThrow
   */
  export type enrollmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments findFirst
   */
  export type enrollmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments findFirstOrThrow
   */
  export type enrollmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments findMany
   */
  export type enrollmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments create
   */
  export type enrollmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a enrollments.
     */
    data: XOR<enrollmentsCreateInput, enrollmentsUncheckedCreateInput>
  }

  /**
   * enrollments createMany
   */
  export type enrollmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentsCreateManyInput | enrollmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * enrollments createManyAndReturn
   */
  export type enrollmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentsCreateManyInput | enrollmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * enrollments update
   */
  export type enrollmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a enrollments.
     */
    data: XOR<enrollmentsUpdateInput, enrollmentsUncheckedUpdateInput>
    /**
     * Choose, which enrollments to update.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments updateMany
   */
  export type enrollmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
  }

  /**
   * enrollments updateManyAndReturn
   */
  export type enrollmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * enrollments upsert
   */
  export type enrollmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the enrollments to update in case it exists.
     */
    where: enrollmentsWhereUniqueInput
    /**
     * In case the enrollments found by the `where` argument doesn't exist, create a new enrollments with this data.
     */
    create: XOR<enrollmentsCreateInput, enrollmentsUncheckedCreateInput>
    /**
     * In case the enrollments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enrollmentsUpdateInput, enrollmentsUncheckedUpdateInput>
  }

  /**
   * enrollments delete
   */
  export type enrollmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter which enrollments to delete.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments deleteMany
   */
  export type enrollmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to delete
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to delete.
     */
    limit?: number
  }

  /**
   * enrollments.grades
   */
  export type enrollments$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    where?: gradesWhereInput
    orderBy?: gradesOrderByWithRelationInput | gradesOrderByWithRelationInput[]
    cursor?: gradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * enrollments without action
   */
  export type enrollmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
  }


  /**
   * Model exams
   */

  export type AggregateExams = {
    _count: ExamsCountAggregateOutputType | null
    _min: ExamsMinAggregateOutputType | null
    _max: ExamsMaxAggregateOutputType | null
  }

  export type ExamsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    class_id: string | null
    type: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    room: string | null
    created_at: Date | null
  }

  export type ExamsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    class_id: string | null
    type: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    room: string | null
    created_at: Date | null
  }

  export type ExamsCountAggregateOutputType = {
    id: number
    tenant_id: number
    class_id: number
    type: number
    date: number
    start_time: number
    end_time: number
    room: number
    created_at: number
    _all: number
  }


  export type ExamsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    type?: true
    date?: true
    start_time?: true
    end_time?: true
    room?: true
    created_at?: true
  }

  export type ExamsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    type?: true
    date?: true
    start_time?: true
    end_time?: true
    room?: true
    created_at?: true
  }

  export type ExamsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    class_id?: true
    type?: true
    date?: true
    start_time?: true
    end_time?: true
    room?: true
    created_at?: true
    _all?: true
  }

  export type ExamsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exams to aggregate.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exams
    **/
    _count?: true | ExamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamsMaxAggregateInputType
  }

  export type GetExamsAggregateType<T extends ExamsAggregateArgs> = {
        [P in keyof T & keyof AggregateExams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExams[P]>
      : GetScalarType<T[P], AggregateExams[P]>
  }




  export type examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
    orderBy?: examsOrderByWithAggregationInput | examsOrderByWithAggregationInput[]
    by: ExamsScalarFieldEnum[] | ExamsScalarFieldEnum
    having?: examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamsCountAggregateInputType | true
    _min?: ExamsMinAggregateInputType
    _max?: ExamsMaxAggregateInputType
  }

  export type ExamsGroupByOutputType = {
    id: string
    tenant_id: string
    class_id: string
    type: string
    date: Date
    start_time: Date
    end_time: Date
    room: string | null
    created_at: Date | null
    _count: ExamsCountAggregateOutputType | null
    _min: ExamsMinAggregateOutputType | null
    _max: ExamsMaxAggregateOutputType | null
  }

  type GetExamsGroupByPayload<T extends examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamsGroupByOutputType[P]>
            : GetScalarType<T[P], ExamsGroupByOutputType[P]>
        }
      >
    >


  export type examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    type?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>

  export type examsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    type?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>

  export type examsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    type?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    created_at?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>

  export type examsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    class_id?: boolean
    type?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    room?: boolean
    created_at?: boolean
  }

  export type examsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "class_id" | "type" | "date" | "start_time" | "end_time" | "room" | "created_at", ExtArgs["result"]["exams"]>
  export type examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }
  export type examsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }
  export type examsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
  }

  export type $examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exams"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      class_id: string
      type: string
      date: Date
      start_time: Date
      end_time: Date
      room: string | null
      created_at: Date | null
    }, ExtArgs["result"]["exams"]>
    composites: {}
  }

  type examsGetPayload<S extends boolean | null | undefined | examsDefaultArgs> = $Result.GetResult<Prisma.$examsPayload, S>

  type examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<examsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamsCountAggregateInputType | true
    }

  export interface examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exams'], meta: { name: 'exams' } }
    /**
     * Find zero or one Exams that matches the filter.
     * @param {examsFindUniqueArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends examsFindUniqueArgs>(args: SelectSubset<T, examsFindUniqueArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {examsFindUniqueOrThrowArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends examsFindUniqueOrThrowArgs>(args: SelectSubset<T, examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindFirstArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends examsFindFirstArgs>(args?: SelectSubset<T, examsFindFirstArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindFirstOrThrowArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends examsFindFirstOrThrowArgs>(args?: SelectSubset<T, examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exams.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examsWithIdOnly = await prisma.exams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends examsFindManyArgs>(args?: SelectSubset<T, examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exams.
     * @param {examsCreateArgs} args - Arguments to create a Exams.
     * @example
     * // Create one Exams
     * const Exams = await prisma.exams.create({
     *   data: {
     *     // ... data to create a Exams
     *   }
     * })
     * 
     */
    create<T extends examsCreateArgs>(args: SelectSubset<T, examsCreateArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {examsCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exams = await prisma.exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends examsCreateManyArgs>(args?: SelectSubset<T, examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {examsCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exams = await prisma.exams.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examsWithIdOnly = await prisma.exams.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends examsCreateManyAndReturnArgs>(args?: SelectSubset<T, examsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exams.
     * @param {examsDeleteArgs} args - Arguments to delete one Exams.
     * @example
     * // Delete one Exams
     * const Exams = await prisma.exams.delete({
     *   where: {
     *     // ... filter to delete one Exams
     *   }
     * })
     * 
     */
    delete<T extends examsDeleteArgs>(args: SelectSubset<T, examsDeleteArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exams.
     * @param {examsUpdateArgs} args - Arguments to update one Exams.
     * @example
     * // Update one Exams
     * const exams = await prisma.exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends examsUpdateArgs>(args: SelectSubset<T, examsUpdateArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {examsDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends examsDeleteManyArgs>(args?: SelectSubset<T, examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exams = await prisma.exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends examsUpdateManyArgs>(args: SelectSubset<T, examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {examsUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exams = await prisma.exams.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examsWithIdOnly = await prisma.exams.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends examsUpdateManyAndReturnArgs>(args: SelectSubset<T, examsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exams.
     * @param {examsUpsertArgs} args - Arguments to update or create a Exams.
     * @example
     * // Update or create a Exams
     * const exams = await prisma.exams.upsert({
     *   create: {
     *     // ... data to create a Exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exams we want to update
     *   }
     * })
     */
    upsert<T extends examsUpsertArgs>(args: SelectSubset<T, examsUpsertArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exams.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends examsCountArgs>(
      args?: Subset<T, examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamsAggregateArgs>(args: Subset<T, ExamsAggregateArgs>): Prisma.PrismaPromise<GetExamsAggregateType<T>>

    /**
     * Group by Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: examsGroupByArgs['orderBy'] }
        : { orderBy?: examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exams model
   */
  readonly fields: examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends classesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classesDefaultArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exams model
   */
  interface examsFieldRefs {
    readonly id: FieldRef<"exams", 'String'>
    readonly tenant_id: FieldRef<"exams", 'String'>
    readonly class_id: FieldRef<"exams", 'String'>
    readonly type: FieldRef<"exams", 'String'>
    readonly date: FieldRef<"exams", 'DateTime'>
    readonly start_time: FieldRef<"exams", 'DateTime'>
    readonly end_time: FieldRef<"exams", 'DateTime'>
    readonly room: FieldRef<"exams", 'String'>
    readonly created_at: FieldRef<"exams", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * exams findUnique
   */
  export type examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams findUniqueOrThrow
   */
  export type examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams findFirst
   */
  export type examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     */
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams findFirstOrThrow
   */
  export type examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     */
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams findMany
   */
  export type examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams create
   */
  export type examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The data needed to create a exams.
     */
    data: XOR<examsCreateInput, examsUncheckedCreateInput>
  }

  /**
   * exams createMany
   */
  export type examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exams.
     */
    data: examsCreateManyInput | examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exams createManyAndReturn
   */
  export type examsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * The data used to create many exams.
     */
    data: examsCreateManyInput | examsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * exams update
   */
  export type examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The data needed to update a exams.
     */
    data: XOR<examsUpdateInput, examsUncheckedUpdateInput>
    /**
     * Choose, which exams to update.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams updateMany
   */
  export type examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exams.
     */
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     */
    where?: examsWhereInput
    /**
     * Limit how many exams to update.
     */
    limit?: number
  }

  /**
   * exams updateManyAndReturn
   */
  export type examsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * The data used to update exams.
     */
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     */
    where?: examsWhereInput
    /**
     * Limit how many exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * exams upsert
   */
  export type examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The filter to search for the exams to update in case it exists.
     */
    where: examsWhereUniqueInput
    /**
     * In case the exams found by the `where` argument doesn't exist, create a new exams with this data.
     */
    create: XOR<examsCreateInput, examsUncheckedCreateInput>
    /**
     * In case the exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<examsUpdateInput, examsUncheckedUpdateInput>
  }

  /**
   * exams delete
   */
  export type examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter which exams to delete.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams deleteMany
   */
  export type examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exams to delete
     */
    where?: examsWhereInput
    /**
     * Limit how many exams to delete.
     */
    limit?: number
  }

  /**
   * exams without action
   */
  export type examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
  }


  /**
   * Model financial_bills
   */

  export type AggregateFinancial_bills = {
    _count: Financial_billsCountAggregateOutputType | null
    _avg: Financial_billsAvgAggregateOutputType | null
    _sum: Financial_billsSumAggregateOutputType | null
    _min: Financial_billsMinAggregateOutputType | null
    _max: Financial_billsMaxAggregateOutputType | null
  }

  export type Financial_billsAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type Financial_billsSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type Financial_billsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    title: string | null
    amount: Decimal | null
    is_paid: boolean | null
    due_date: Date | null
    created_at: Date | null
  }

  export type Financial_billsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    title: string | null
    amount: Decimal | null
    is_paid: boolean | null
    due_date: Date | null
    created_at: Date | null
  }

  export type Financial_billsCountAggregateOutputType = {
    id: number
    tenant_id: number
    student_id: number
    title: number
    amount: number
    is_paid: number
    due_date: number
    created_at: number
    _all: number
  }


  export type Financial_billsAvgAggregateInputType = {
    amount?: true
  }

  export type Financial_billsSumAggregateInputType = {
    amount?: true
  }

  export type Financial_billsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    title?: true
    amount?: true
    is_paid?: true
    due_date?: true
    created_at?: true
  }

  export type Financial_billsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    title?: true
    amount?: true
    is_paid?: true
    due_date?: true
    created_at?: true
  }

  export type Financial_billsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    title?: true
    amount?: true
    is_paid?: true
    due_date?: true
    created_at?: true
    _all?: true
  }

  export type Financial_billsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which financial_bills to aggregate.
     */
    where?: financial_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financial_bills to fetch.
     */
    orderBy?: financial_billsOrderByWithRelationInput | financial_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: financial_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financial_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financial_bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned financial_bills
    **/
    _count?: true | Financial_billsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Financial_billsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Financial_billsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Financial_billsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Financial_billsMaxAggregateInputType
  }

  export type GetFinancial_billsAggregateType<T extends Financial_billsAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancial_bills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancial_bills[P]>
      : GetScalarType<T[P], AggregateFinancial_bills[P]>
  }




  export type financial_billsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: financial_billsWhereInput
    orderBy?: financial_billsOrderByWithAggregationInput | financial_billsOrderByWithAggregationInput[]
    by: Financial_billsScalarFieldEnum[] | Financial_billsScalarFieldEnum
    having?: financial_billsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Financial_billsCountAggregateInputType | true
    _avg?: Financial_billsAvgAggregateInputType
    _sum?: Financial_billsSumAggregateInputType
    _min?: Financial_billsMinAggregateInputType
    _max?: Financial_billsMaxAggregateInputType
  }

  export type Financial_billsGroupByOutputType = {
    id: string
    tenant_id: string
    student_id: string
    title: string
    amount: Decimal
    is_paid: boolean | null
    due_date: Date | null
    created_at: Date | null
    _count: Financial_billsCountAggregateOutputType | null
    _avg: Financial_billsAvgAggregateOutputType | null
    _sum: Financial_billsSumAggregateOutputType | null
    _min: Financial_billsMinAggregateOutputType | null
    _max: Financial_billsMaxAggregateOutputType | null
  }

  type GetFinancial_billsGroupByPayload<T extends financial_billsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Financial_billsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Financial_billsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Financial_billsGroupByOutputType[P]>
            : GetScalarType<T[P], Financial_billsGroupByOutputType[P]>
        }
      >
    >


  export type financial_billsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    amount?: boolean
    is_paid?: boolean
    due_date?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financial_bills"]>

  export type financial_billsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    amount?: boolean
    is_paid?: boolean
    due_date?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financial_bills"]>

  export type financial_billsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    amount?: boolean
    is_paid?: boolean
    due_date?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financial_bills"]>

  export type financial_billsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    amount?: boolean
    is_paid?: boolean
    due_date?: boolean
    created_at?: boolean
  }

  export type financial_billsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "student_id" | "title" | "amount" | "is_paid" | "due_date" | "created_at", ExtArgs["result"]["financial_bills"]>
  export type financial_billsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type financial_billsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type financial_billsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $financial_billsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "financial_bills"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      student_id: string
      title: string
      amount: Prisma.Decimal
      is_paid: boolean | null
      due_date: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["financial_bills"]>
    composites: {}
  }

  type financial_billsGetPayload<S extends boolean | null | undefined | financial_billsDefaultArgs> = $Result.GetResult<Prisma.$financial_billsPayload, S>

  type financial_billsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<financial_billsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Financial_billsCountAggregateInputType | true
    }

  export interface financial_billsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['financial_bills'], meta: { name: 'financial_bills' } }
    /**
     * Find zero or one Financial_bills that matches the filter.
     * @param {financial_billsFindUniqueArgs} args - Arguments to find a Financial_bills
     * @example
     * // Get one Financial_bills
     * const financial_bills = await prisma.financial_bills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends financial_billsFindUniqueArgs>(args: SelectSubset<T, financial_billsFindUniqueArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Financial_bills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {financial_billsFindUniqueOrThrowArgs} args - Arguments to find a Financial_bills
     * @example
     * // Get one Financial_bills
     * const financial_bills = await prisma.financial_bills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends financial_billsFindUniqueOrThrowArgs>(args: SelectSubset<T, financial_billsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Financial_bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financial_billsFindFirstArgs} args - Arguments to find a Financial_bills
     * @example
     * // Get one Financial_bills
     * const financial_bills = await prisma.financial_bills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends financial_billsFindFirstArgs>(args?: SelectSubset<T, financial_billsFindFirstArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Financial_bills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financial_billsFindFirstOrThrowArgs} args - Arguments to find a Financial_bills
     * @example
     * // Get one Financial_bills
     * const financial_bills = await prisma.financial_bills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends financial_billsFindFirstOrThrowArgs>(args?: SelectSubset<T, financial_billsFindFirstOrThrowArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Financial_bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financial_billsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Financial_bills
     * const financial_bills = await prisma.financial_bills.findMany()
     * 
     * // Get first 10 Financial_bills
     * const financial_bills = await prisma.financial_bills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financial_billsWithIdOnly = await prisma.financial_bills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends financial_billsFindManyArgs>(args?: SelectSubset<T, financial_billsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Financial_bills.
     * @param {financial_billsCreateArgs} args - Arguments to create a Financial_bills.
     * @example
     * // Create one Financial_bills
     * const Financial_bills = await prisma.financial_bills.create({
     *   data: {
     *     // ... data to create a Financial_bills
     *   }
     * })
     * 
     */
    create<T extends financial_billsCreateArgs>(args: SelectSubset<T, financial_billsCreateArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Financial_bills.
     * @param {financial_billsCreateManyArgs} args - Arguments to create many Financial_bills.
     * @example
     * // Create many Financial_bills
     * const financial_bills = await prisma.financial_bills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends financial_billsCreateManyArgs>(args?: SelectSubset<T, financial_billsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Financial_bills and returns the data saved in the database.
     * @param {financial_billsCreateManyAndReturnArgs} args - Arguments to create many Financial_bills.
     * @example
     * // Create many Financial_bills
     * const financial_bills = await prisma.financial_bills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Financial_bills and only return the `id`
     * const financial_billsWithIdOnly = await prisma.financial_bills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends financial_billsCreateManyAndReturnArgs>(args?: SelectSubset<T, financial_billsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Financial_bills.
     * @param {financial_billsDeleteArgs} args - Arguments to delete one Financial_bills.
     * @example
     * // Delete one Financial_bills
     * const Financial_bills = await prisma.financial_bills.delete({
     *   where: {
     *     // ... filter to delete one Financial_bills
     *   }
     * })
     * 
     */
    delete<T extends financial_billsDeleteArgs>(args: SelectSubset<T, financial_billsDeleteArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Financial_bills.
     * @param {financial_billsUpdateArgs} args - Arguments to update one Financial_bills.
     * @example
     * // Update one Financial_bills
     * const financial_bills = await prisma.financial_bills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends financial_billsUpdateArgs>(args: SelectSubset<T, financial_billsUpdateArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Financial_bills.
     * @param {financial_billsDeleteManyArgs} args - Arguments to filter Financial_bills to delete.
     * @example
     * // Delete a few Financial_bills
     * const { count } = await prisma.financial_bills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends financial_billsDeleteManyArgs>(args?: SelectSubset<T, financial_billsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Financial_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financial_billsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Financial_bills
     * const financial_bills = await prisma.financial_bills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends financial_billsUpdateManyArgs>(args: SelectSubset<T, financial_billsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Financial_bills and returns the data updated in the database.
     * @param {financial_billsUpdateManyAndReturnArgs} args - Arguments to update many Financial_bills.
     * @example
     * // Update many Financial_bills
     * const financial_bills = await prisma.financial_bills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Financial_bills and only return the `id`
     * const financial_billsWithIdOnly = await prisma.financial_bills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends financial_billsUpdateManyAndReturnArgs>(args: SelectSubset<T, financial_billsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Financial_bills.
     * @param {financial_billsUpsertArgs} args - Arguments to update or create a Financial_bills.
     * @example
     * // Update or create a Financial_bills
     * const financial_bills = await prisma.financial_bills.upsert({
     *   create: {
     *     // ... data to create a Financial_bills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Financial_bills we want to update
     *   }
     * })
     */
    upsert<T extends financial_billsUpsertArgs>(args: SelectSubset<T, financial_billsUpsertArgs<ExtArgs>>): Prisma__financial_billsClient<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Financial_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financial_billsCountArgs} args - Arguments to filter Financial_bills to count.
     * @example
     * // Count the number of Financial_bills
     * const count = await prisma.financial_bills.count({
     *   where: {
     *     // ... the filter for the Financial_bills we want to count
     *   }
     * })
    **/
    count<T extends financial_billsCountArgs>(
      args?: Subset<T, financial_billsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Financial_billsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Financial_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Financial_billsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Financial_billsAggregateArgs>(args: Subset<T, Financial_billsAggregateArgs>): Prisma.PrismaPromise<GetFinancial_billsAggregateType<T>>

    /**
     * Group by Financial_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financial_billsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends financial_billsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: financial_billsGroupByArgs['orderBy'] }
        : { orderBy?: financial_billsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, financial_billsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancial_billsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the financial_bills model
   */
  readonly fields: financial_billsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for financial_bills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__financial_billsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the financial_bills model
   */
  interface financial_billsFieldRefs {
    readonly id: FieldRef<"financial_bills", 'String'>
    readonly tenant_id: FieldRef<"financial_bills", 'String'>
    readonly student_id: FieldRef<"financial_bills", 'String'>
    readonly title: FieldRef<"financial_bills", 'String'>
    readonly amount: FieldRef<"financial_bills", 'Decimal'>
    readonly is_paid: FieldRef<"financial_bills", 'Boolean'>
    readonly due_date: FieldRef<"financial_bills", 'DateTime'>
    readonly created_at: FieldRef<"financial_bills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * financial_bills findUnique
   */
  export type financial_billsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * Filter, which financial_bills to fetch.
     */
    where: financial_billsWhereUniqueInput
  }

  /**
   * financial_bills findUniqueOrThrow
   */
  export type financial_billsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * Filter, which financial_bills to fetch.
     */
    where: financial_billsWhereUniqueInput
  }

  /**
   * financial_bills findFirst
   */
  export type financial_billsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * Filter, which financial_bills to fetch.
     */
    where?: financial_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financial_bills to fetch.
     */
    orderBy?: financial_billsOrderByWithRelationInput | financial_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for financial_bills.
     */
    cursor?: financial_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financial_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financial_bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of financial_bills.
     */
    distinct?: Financial_billsScalarFieldEnum | Financial_billsScalarFieldEnum[]
  }

  /**
   * financial_bills findFirstOrThrow
   */
  export type financial_billsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * Filter, which financial_bills to fetch.
     */
    where?: financial_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financial_bills to fetch.
     */
    orderBy?: financial_billsOrderByWithRelationInput | financial_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for financial_bills.
     */
    cursor?: financial_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financial_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financial_bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of financial_bills.
     */
    distinct?: Financial_billsScalarFieldEnum | Financial_billsScalarFieldEnum[]
  }

  /**
   * financial_bills findMany
   */
  export type financial_billsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * Filter, which financial_bills to fetch.
     */
    where?: financial_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financial_bills to fetch.
     */
    orderBy?: financial_billsOrderByWithRelationInput | financial_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing financial_bills.
     */
    cursor?: financial_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financial_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financial_bills.
     */
    skip?: number
    distinct?: Financial_billsScalarFieldEnum | Financial_billsScalarFieldEnum[]
  }

  /**
   * financial_bills create
   */
  export type financial_billsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * The data needed to create a financial_bills.
     */
    data: XOR<financial_billsCreateInput, financial_billsUncheckedCreateInput>
  }

  /**
   * financial_bills createMany
   */
  export type financial_billsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many financial_bills.
     */
    data: financial_billsCreateManyInput | financial_billsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * financial_bills createManyAndReturn
   */
  export type financial_billsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * The data used to create many financial_bills.
     */
    data: financial_billsCreateManyInput | financial_billsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * financial_bills update
   */
  export type financial_billsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * The data needed to update a financial_bills.
     */
    data: XOR<financial_billsUpdateInput, financial_billsUncheckedUpdateInput>
    /**
     * Choose, which financial_bills to update.
     */
    where: financial_billsWhereUniqueInput
  }

  /**
   * financial_bills updateMany
   */
  export type financial_billsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update financial_bills.
     */
    data: XOR<financial_billsUpdateManyMutationInput, financial_billsUncheckedUpdateManyInput>
    /**
     * Filter which financial_bills to update
     */
    where?: financial_billsWhereInput
    /**
     * Limit how many financial_bills to update.
     */
    limit?: number
  }

  /**
   * financial_bills updateManyAndReturn
   */
  export type financial_billsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * The data used to update financial_bills.
     */
    data: XOR<financial_billsUpdateManyMutationInput, financial_billsUncheckedUpdateManyInput>
    /**
     * Filter which financial_bills to update
     */
    where?: financial_billsWhereInput
    /**
     * Limit how many financial_bills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * financial_bills upsert
   */
  export type financial_billsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * The filter to search for the financial_bills to update in case it exists.
     */
    where: financial_billsWhereUniqueInput
    /**
     * In case the financial_bills found by the `where` argument doesn't exist, create a new financial_bills with this data.
     */
    create: XOR<financial_billsCreateInput, financial_billsUncheckedCreateInput>
    /**
     * In case the financial_bills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<financial_billsUpdateInput, financial_billsUncheckedUpdateInput>
  }

  /**
   * financial_bills delete
   */
  export type financial_billsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    /**
     * Filter which financial_bills to delete.
     */
    where: financial_billsWhereUniqueInput
  }

  /**
   * financial_bills deleteMany
   */
  export type financial_billsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which financial_bills to delete
     */
    where?: financial_billsWhereInput
    /**
     * Limit how many financial_bills to delete.
     */
    limit?: number
  }

  /**
   * financial_bills without action
   */
  export type financial_billsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
  }


  /**
   * Model grades
   */

  export type AggregateGrades = {
    _count: GradesCountAggregateOutputType | null
    _avg: GradesAvgAggregateOutputType | null
    _sum: GradesSumAggregateOutputType | null
    _min: GradesMinAggregateOutputType | null
    _max: GradesMaxAggregateOutputType | null
  }

  export type GradesAvgAggregateOutputType = {
    score: number | null
  }

  export type GradesSumAggregateOutputType = {
    score: number | null
  }

  export type GradesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    enrollment_id: string | null
    grade: string | null
    score: number | null
    created_at: Date | null
  }

  export type GradesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    enrollment_id: string | null
    grade: string | null
    score: number | null
    created_at: Date | null
  }

  export type GradesCountAggregateOutputType = {
    id: number
    tenant_id: number
    enrollment_id: number
    grade: number
    score: number
    created_at: number
    _all: number
  }


  export type GradesAvgAggregateInputType = {
    score?: true
  }

  export type GradesSumAggregateInputType = {
    score?: true
  }

  export type GradesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    enrollment_id?: true
    grade?: true
    score?: true
    created_at?: true
  }

  export type GradesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    enrollment_id?: true
    grade?: true
    score?: true
    created_at?: true
  }

  export type GradesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    enrollment_id?: true
    grade?: true
    score?: true
    created_at?: true
    _all?: true
  }

  export type GradesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grades to aggregate.
     */
    where?: gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades to fetch.
     */
    orderBy?: gradesOrderByWithRelationInput | gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grades
    **/
    _count?: true | GradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradesMaxAggregateInputType
  }

  export type GetGradesAggregateType<T extends GradesAggregateArgs> = {
        [P in keyof T & keyof AggregateGrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrades[P]>
      : GetScalarType<T[P], AggregateGrades[P]>
  }




  export type gradesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gradesWhereInput
    orderBy?: gradesOrderByWithAggregationInput | gradesOrderByWithAggregationInput[]
    by: GradesScalarFieldEnum[] | GradesScalarFieldEnum
    having?: gradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradesCountAggregateInputType | true
    _avg?: GradesAvgAggregateInputType
    _sum?: GradesSumAggregateInputType
    _min?: GradesMinAggregateInputType
    _max?: GradesMaxAggregateInputType
  }

  export type GradesGroupByOutputType = {
    id: string
    tenant_id: string
    enrollment_id: string
    grade: string | null
    score: number | null
    created_at: Date | null
    _count: GradesCountAggregateOutputType | null
    _avg: GradesAvgAggregateOutputType | null
    _sum: GradesSumAggregateOutputType | null
    _min: GradesMinAggregateOutputType | null
    _max: GradesMaxAggregateOutputType | null
  }

  type GetGradesGroupByPayload<T extends gradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradesGroupByOutputType[P]>
            : GetScalarType<T[P], GradesGroupByOutputType[P]>
        }
      >
    >


  export type gradesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    enrollment_id?: boolean
    grade?: boolean
    score?: boolean
    created_at?: boolean
    enrollments?: boolean | enrollmentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades"]>

  export type gradesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    enrollment_id?: boolean
    grade?: boolean
    score?: boolean
    created_at?: boolean
    enrollments?: boolean | enrollmentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades"]>

  export type gradesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    enrollment_id?: boolean
    grade?: boolean
    score?: boolean
    created_at?: boolean
    enrollments?: boolean | enrollmentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades"]>

  export type gradesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    enrollment_id?: boolean
    grade?: boolean
    score?: boolean
    created_at?: boolean
  }

  export type gradesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "enrollment_id" | "grade" | "score" | "created_at", ExtArgs["result"]["grades"]>
  export type gradesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | enrollmentsDefaultArgs<ExtArgs>
  }
  export type gradesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | enrollmentsDefaultArgs<ExtArgs>
  }
  export type gradesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | enrollmentsDefaultArgs<ExtArgs>
  }

  export type $gradesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grades"
    objects: {
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      enrollment_id: string
      grade: string | null
      score: number | null
      created_at: Date | null
    }, ExtArgs["result"]["grades"]>
    composites: {}
  }

  type gradesGetPayload<S extends boolean | null | undefined | gradesDefaultArgs> = $Result.GetResult<Prisma.$gradesPayload, S>

  type gradesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gradesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradesCountAggregateInputType | true
    }

  export interface gradesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grades'], meta: { name: 'grades' } }
    /**
     * Find zero or one Grades that matches the filter.
     * @param {gradesFindUniqueArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gradesFindUniqueArgs>(args: SelectSubset<T, gradesFindUniqueArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gradesFindUniqueOrThrowArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gradesFindUniqueOrThrowArgs>(args: SelectSubset<T, gradesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradesFindFirstArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gradesFindFirstArgs>(args?: SelectSubset<T, gradesFindFirstArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradesFindFirstOrThrowArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gradesFindFirstOrThrowArgs>(args?: SelectSubset<T, gradesFindFirstOrThrowArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grades.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradesWithIdOnly = await prisma.grades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gradesFindManyArgs>(args?: SelectSubset<T, gradesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grades.
     * @param {gradesCreateArgs} args - Arguments to create a Grades.
     * @example
     * // Create one Grades
     * const Grades = await prisma.grades.create({
     *   data: {
     *     // ... data to create a Grades
     *   }
     * })
     * 
     */
    create<T extends gradesCreateArgs>(args: SelectSubset<T, gradesCreateArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {gradesCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grades = await prisma.grades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gradesCreateManyArgs>(args?: SelectSubset<T, gradesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {gradesCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grades = await prisma.grades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradesWithIdOnly = await prisma.grades.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gradesCreateManyAndReturnArgs>(args?: SelectSubset<T, gradesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grades.
     * @param {gradesDeleteArgs} args - Arguments to delete one Grades.
     * @example
     * // Delete one Grades
     * const Grades = await prisma.grades.delete({
     *   where: {
     *     // ... filter to delete one Grades
     *   }
     * })
     * 
     */
    delete<T extends gradesDeleteArgs>(args: SelectSubset<T, gradesDeleteArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grades.
     * @param {gradesUpdateArgs} args - Arguments to update one Grades.
     * @example
     * // Update one Grades
     * const grades = await prisma.grades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gradesUpdateArgs>(args: SelectSubset<T, gradesUpdateArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {gradesDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gradesDeleteManyArgs>(args?: SelectSubset<T, gradesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grades = await prisma.grades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gradesUpdateManyArgs>(args: SelectSubset<T, gradesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {gradesUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grades = await prisma.grades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradesWithIdOnly = await prisma.grades.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends gradesUpdateManyAndReturnArgs>(args: SelectSubset<T, gradesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grades.
     * @param {gradesUpsertArgs} args - Arguments to update or create a Grades.
     * @example
     * // Update or create a Grades
     * const grades = await prisma.grades.upsert({
     *   create: {
     *     // ... data to create a Grades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grades we want to update
     *   }
     * })
     */
    upsert<T extends gradesUpsertArgs>(args: SelectSubset<T, gradesUpsertArgs<ExtArgs>>): Prisma__gradesClient<$Result.GetResult<Prisma.$gradesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradesCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grades.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends gradesCountArgs>(
      args?: Subset<T, gradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradesAggregateArgs>(args: Subset<T, GradesAggregateArgs>): Prisma.PrismaPromise<GetGradesAggregateType<T>>

    /**
     * Group by Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gradesGroupByArgs['orderBy'] }
        : { orderBy?: gradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grades model
   */
  readonly fields: gradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gradesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends enrollmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, enrollmentsDefaultArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grades model
   */
  interface gradesFieldRefs {
    readonly id: FieldRef<"grades", 'String'>
    readonly tenant_id: FieldRef<"grades", 'String'>
    readonly enrollment_id: FieldRef<"grades", 'String'>
    readonly grade: FieldRef<"grades", 'String'>
    readonly score: FieldRef<"grades", 'Float'>
    readonly created_at: FieldRef<"grades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * grades findUnique
   */
  export type gradesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * Filter, which grades to fetch.
     */
    where: gradesWhereUniqueInput
  }

  /**
   * grades findUniqueOrThrow
   */
  export type gradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * Filter, which grades to fetch.
     */
    where: gradesWhereUniqueInput
  }

  /**
   * grades findFirst
   */
  export type gradesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * Filter, which grades to fetch.
     */
    where?: gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades to fetch.
     */
    orderBy?: gradesOrderByWithRelationInput | gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grades.
     */
    cursor?: gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grades.
     */
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * grades findFirstOrThrow
   */
  export type gradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * Filter, which grades to fetch.
     */
    where?: gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades to fetch.
     */
    orderBy?: gradesOrderByWithRelationInput | gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grades.
     */
    cursor?: gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grades.
     */
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * grades findMany
   */
  export type gradesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * Filter, which grades to fetch.
     */
    where?: gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades to fetch.
     */
    orderBy?: gradesOrderByWithRelationInput | gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grades.
     */
    cursor?: gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades.
     */
    skip?: number
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * grades create
   */
  export type gradesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * The data needed to create a grades.
     */
    data: XOR<gradesCreateInput, gradesUncheckedCreateInput>
  }

  /**
   * grades createMany
   */
  export type gradesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grades.
     */
    data: gradesCreateManyInput | gradesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grades createManyAndReturn
   */
  export type gradesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * The data used to create many grades.
     */
    data: gradesCreateManyInput | gradesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * grades update
   */
  export type gradesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * The data needed to update a grades.
     */
    data: XOR<gradesUpdateInput, gradesUncheckedUpdateInput>
    /**
     * Choose, which grades to update.
     */
    where: gradesWhereUniqueInput
  }

  /**
   * grades updateMany
   */
  export type gradesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grades.
     */
    data: XOR<gradesUpdateManyMutationInput, gradesUncheckedUpdateManyInput>
    /**
     * Filter which grades to update
     */
    where?: gradesWhereInput
    /**
     * Limit how many grades to update.
     */
    limit?: number
  }

  /**
   * grades updateManyAndReturn
   */
  export type gradesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * The data used to update grades.
     */
    data: XOR<gradesUpdateManyMutationInput, gradesUncheckedUpdateManyInput>
    /**
     * Filter which grades to update
     */
    where?: gradesWhereInput
    /**
     * Limit how many grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * grades upsert
   */
  export type gradesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * The filter to search for the grades to update in case it exists.
     */
    where: gradesWhereUniqueInput
    /**
     * In case the grades found by the `where` argument doesn't exist, create a new grades with this data.
     */
    create: XOR<gradesCreateInput, gradesUncheckedCreateInput>
    /**
     * In case the grades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gradesUpdateInput, gradesUncheckedUpdateInput>
  }

  /**
   * grades delete
   */
  export type gradesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
    /**
     * Filter which grades to delete.
     */
    where: gradesWhereUniqueInput
  }

  /**
   * grades deleteMany
   */
  export type gradesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grades to delete
     */
    where?: gradesWhereInput
    /**
     * Limit how many grades to delete.
     */
    limit?: number
  }

  /**
   * grades without action
   */
  export type gradesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades
     */
    select?: gradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grades
     */
    omit?: gradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradesInclude<ExtArgs> | null
  }


  /**
   * Model lecturers
   */

  export type AggregateLecturers = {
    _count: LecturersCountAggregateOutputType | null
    _min: LecturersMinAggregateOutputType | null
    _max: LecturersMaxAggregateOutputType | null
  }

  export type LecturersMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    platform_lecturer_number: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LecturersMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    platform_lecturer_number: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LecturersCountAggregateOutputType = {
    id: number
    tenant_id: number
    user_id: number
    platform_lecturer_number: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LecturersMinAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    platform_lecturer_number?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type LecturersMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    platform_lecturer_number?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type LecturersCountAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    platform_lecturer_number?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LecturersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lecturers to aggregate.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lecturers
    **/
    _count?: true | LecturersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LecturersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LecturersMaxAggregateInputType
  }

  export type GetLecturersAggregateType<T extends LecturersAggregateArgs> = {
        [P in keyof T & keyof AggregateLecturers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecturers[P]>
      : GetScalarType<T[P], AggregateLecturers[P]>
  }




  export type lecturersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lecturersWhereInput
    orderBy?: lecturersOrderByWithAggregationInput | lecturersOrderByWithAggregationInput[]
    by: LecturersScalarFieldEnum[] | LecturersScalarFieldEnum
    having?: lecturersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LecturersCountAggregateInputType | true
    _min?: LecturersMinAggregateInputType
    _max?: LecturersMaxAggregateInputType
  }

  export type LecturersGroupByOutputType = {
    id: string
    tenant_id: string
    user_id: string
    platform_lecturer_number: string | null
    name: string
    created_at: Date | null
    updated_at: Date | null
    _count: LecturersCountAggregateOutputType | null
    _min: LecturersMinAggregateOutputType | null
    _max: LecturersMaxAggregateOutputType | null
  }

  type GetLecturersGroupByPayload<T extends lecturersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LecturersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LecturersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LecturersGroupByOutputType[P]>
            : GetScalarType<T[P], LecturersGroupByOutputType[P]>
        }
      >
    >


  export type lecturersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_lecturer_number?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    classes?: boolean | lecturers$classesArgs<ExtArgs>
    _count?: boolean | LecturersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturers"]>

  export type lecturersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_lecturer_number?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["lecturers"]>

  export type lecturersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_lecturer_number?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["lecturers"]>

  export type lecturersSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_lecturer_number?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type lecturersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "user_id" | "platform_lecturer_number" | "name" | "created_at" | "updated_at", ExtArgs["result"]["lecturers"]>
  export type lecturersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | lecturers$classesArgs<ExtArgs>
    _count?: boolean | LecturersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type lecturersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type lecturersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $lecturersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lecturers"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      user_id: string
      platform_lecturer_number: string | null
      name: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["lecturers"]>
    composites: {}
  }

  type lecturersGetPayload<S extends boolean | null | undefined | lecturersDefaultArgs> = $Result.GetResult<Prisma.$lecturersPayload, S>

  type lecturersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lecturersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LecturersCountAggregateInputType | true
    }

  export interface lecturersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lecturers'], meta: { name: 'lecturers' } }
    /**
     * Find zero or one Lecturers that matches the filter.
     * @param {lecturersFindUniqueArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lecturersFindUniqueArgs>(args: SelectSubset<T, lecturersFindUniqueArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lecturers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lecturersFindUniqueOrThrowArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lecturersFindUniqueOrThrowArgs>(args: SelectSubset<T, lecturersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersFindFirstArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lecturersFindFirstArgs>(args?: SelectSubset<T, lecturersFindFirstArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecturers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersFindFirstOrThrowArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lecturersFindFirstOrThrowArgs>(args?: SelectSubset<T, lecturersFindFirstOrThrowArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lecturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecturers
     * const lecturers = await prisma.lecturers.findMany()
     * 
     * // Get first 10 Lecturers
     * const lecturers = await prisma.lecturers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lecturersWithIdOnly = await prisma.lecturers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lecturersFindManyArgs>(args?: SelectSubset<T, lecturersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lecturers.
     * @param {lecturersCreateArgs} args - Arguments to create a Lecturers.
     * @example
     * // Create one Lecturers
     * const Lecturers = await prisma.lecturers.create({
     *   data: {
     *     // ... data to create a Lecturers
     *   }
     * })
     * 
     */
    create<T extends lecturersCreateArgs>(args: SelectSubset<T, lecturersCreateArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lecturers.
     * @param {lecturersCreateManyArgs} args - Arguments to create many Lecturers.
     * @example
     * // Create many Lecturers
     * const lecturers = await prisma.lecturers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lecturersCreateManyArgs>(args?: SelectSubset<T, lecturersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lecturers and returns the data saved in the database.
     * @param {lecturersCreateManyAndReturnArgs} args - Arguments to create many Lecturers.
     * @example
     * // Create many Lecturers
     * const lecturers = await prisma.lecturers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lecturers and only return the `id`
     * const lecturersWithIdOnly = await prisma.lecturers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lecturersCreateManyAndReturnArgs>(args?: SelectSubset<T, lecturersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lecturers.
     * @param {lecturersDeleteArgs} args - Arguments to delete one Lecturers.
     * @example
     * // Delete one Lecturers
     * const Lecturers = await prisma.lecturers.delete({
     *   where: {
     *     // ... filter to delete one Lecturers
     *   }
     * })
     * 
     */
    delete<T extends lecturersDeleteArgs>(args: SelectSubset<T, lecturersDeleteArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lecturers.
     * @param {lecturersUpdateArgs} args - Arguments to update one Lecturers.
     * @example
     * // Update one Lecturers
     * const lecturers = await prisma.lecturers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lecturersUpdateArgs>(args: SelectSubset<T, lecturersUpdateArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lecturers.
     * @param {lecturersDeleteManyArgs} args - Arguments to filter Lecturers to delete.
     * @example
     * // Delete a few Lecturers
     * const { count } = await prisma.lecturers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lecturersDeleteManyArgs>(args?: SelectSubset<T, lecturersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecturers
     * const lecturers = await prisma.lecturers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lecturersUpdateManyArgs>(args: SelectSubset<T, lecturersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers and returns the data updated in the database.
     * @param {lecturersUpdateManyAndReturnArgs} args - Arguments to update many Lecturers.
     * @example
     * // Update many Lecturers
     * const lecturers = await prisma.lecturers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lecturers and only return the `id`
     * const lecturersWithIdOnly = await prisma.lecturers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lecturersUpdateManyAndReturnArgs>(args: SelectSubset<T, lecturersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lecturers.
     * @param {lecturersUpsertArgs} args - Arguments to update or create a Lecturers.
     * @example
     * // Update or create a Lecturers
     * const lecturers = await prisma.lecturers.upsert({
     *   create: {
     *     // ... data to create a Lecturers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecturers we want to update
     *   }
     * })
     */
    upsert<T extends lecturersUpsertArgs>(args: SelectSubset<T, lecturersUpsertArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersCountArgs} args - Arguments to filter Lecturers to count.
     * @example
     * // Count the number of Lecturers
     * const count = await prisma.lecturers.count({
     *   where: {
     *     // ... the filter for the Lecturers we want to count
     *   }
     * })
    **/
    count<T extends lecturersCountArgs>(
      args?: Subset<T, lecturersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LecturersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LecturersAggregateArgs>(args: Subset<T, LecturersAggregateArgs>): Prisma.PrismaPromise<GetLecturersAggregateType<T>>

    /**
     * Group by Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lecturersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lecturersGroupByArgs['orderBy'] }
        : { orderBy?: lecturersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lecturersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lecturers model
   */
  readonly fields: lecturersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lecturers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lecturersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends lecturers$classesArgs<ExtArgs> = {}>(args?: Subset<T, lecturers$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lecturers model
   */
  interface lecturersFieldRefs {
    readonly id: FieldRef<"lecturers", 'String'>
    readonly tenant_id: FieldRef<"lecturers", 'String'>
    readonly user_id: FieldRef<"lecturers", 'String'>
    readonly platform_lecturer_number: FieldRef<"lecturers", 'String'>
    readonly name: FieldRef<"lecturers", 'String'>
    readonly created_at: FieldRef<"lecturers", 'DateTime'>
    readonly updated_at: FieldRef<"lecturers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * lecturers findUnique
   */
  export type lecturersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers findUniqueOrThrow
   */
  export type lecturersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers findFirst
   */
  export type lecturersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecturers.
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecturers.
     */
    distinct?: LecturersScalarFieldEnum | LecturersScalarFieldEnum[]
  }

  /**
   * lecturers findFirstOrThrow
   */
  export type lecturersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecturers.
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecturers.
     */
    distinct?: LecturersScalarFieldEnum | LecturersScalarFieldEnum[]
  }

  /**
   * lecturers findMany
   */
  export type lecturersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lecturers.
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    distinct?: LecturersScalarFieldEnum | LecturersScalarFieldEnum[]
  }

  /**
   * lecturers create
   */
  export type lecturersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * The data needed to create a lecturers.
     */
    data: XOR<lecturersCreateInput, lecturersUncheckedCreateInput>
  }

  /**
   * lecturers createMany
   */
  export type lecturersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lecturers.
     */
    data: lecturersCreateManyInput | lecturersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lecturers createManyAndReturn
   */
  export type lecturersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * The data used to create many lecturers.
     */
    data: lecturersCreateManyInput | lecturersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lecturers update
   */
  export type lecturersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * The data needed to update a lecturers.
     */
    data: XOR<lecturersUpdateInput, lecturersUncheckedUpdateInput>
    /**
     * Choose, which lecturers to update.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers updateMany
   */
  export type lecturersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lecturers.
     */
    data: XOR<lecturersUpdateManyMutationInput, lecturersUncheckedUpdateManyInput>
    /**
     * Filter which lecturers to update
     */
    where?: lecturersWhereInput
    /**
     * Limit how many lecturers to update.
     */
    limit?: number
  }

  /**
   * lecturers updateManyAndReturn
   */
  export type lecturersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * The data used to update lecturers.
     */
    data: XOR<lecturersUpdateManyMutationInput, lecturersUncheckedUpdateManyInput>
    /**
     * Filter which lecturers to update
     */
    where?: lecturersWhereInput
    /**
     * Limit how many lecturers to update.
     */
    limit?: number
  }

  /**
   * lecturers upsert
   */
  export type lecturersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * The filter to search for the lecturers to update in case it exists.
     */
    where: lecturersWhereUniqueInput
    /**
     * In case the lecturers found by the `where` argument doesn't exist, create a new lecturers with this data.
     */
    create: XOR<lecturersCreateInput, lecturersUncheckedCreateInput>
    /**
     * In case the lecturers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lecturersUpdateInput, lecturersUncheckedUpdateInput>
  }

  /**
   * lecturers delete
   */
  export type lecturersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter which lecturers to delete.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers deleteMany
   */
  export type lecturersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lecturers to delete
     */
    where?: lecturersWhereInput
    /**
     * Limit how many lecturers to delete.
     */
    limit?: number
  }

  /**
   * lecturers.classes
   */
  export type lecturers$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    cursor?: classesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * lecturers without action
   */
  export type lecturersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
  }


  /**
   * Model research_proposals
   */

  export type AggregateResearch_proposals = {
    _count: Research_proposalsCountAggregateOutputType | null
    _min: Research_proposalsMinAggregateOutputType | null
    _max: Research_proposalsMaxAggregateOutputType | null
  }

  export type Research_proposalsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    title: string | null
    type: string | null
    description: string | null
    supervisor_preferred: string | null
    status: string | null
    created_at: Date | null
  }

  export type Research_proposalsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    title: string | null
    type: string | null
    description: string | null
    supervisor_preferred: string | null
    status: string | null
    created_at: Date | null
  }

  export type Research_proposalsCountAggregateOutputType = {
    id: number
    tenant_id: number
    student_id: number
    title: number
    type: number
    description: number
    supervisor_preferred: number
    status: number
    created_at: number
    _all: number
  }


  export type Research_proposalsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    title?: true
    type?: true
    description?: true
    supervisor_preferred?: true
    status?: true
    created_at?: true
  }

  export type Research_proposalsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    title?: true
    type?: true
    description?: true
    supervisor_preferred?: true
    status?: true
    created_at?: true
  }

  export type Research_proposalsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    title?: true
    type?: true
    description?: true
    supervisor_preferred?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Research_proposalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which research_proposals to aggregate.
     */
    where?: research_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of research_proposals to fetch.
     */
    orderBy?: research_proposalsOrderByWithRelationInput | research_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: research_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` research_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` research_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned research_proposals
    **/
    _count?: true | Research_proposalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Research_proposalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Research_proposalsMaxAggregateInputType
  }

  export type GetResearch_proposalsAggregateType<T extends Research_proposalsAggregateArgs> = {
        [P in keyof T & keyof AggregateResearch_proposals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearch_proposals[P]>
      : GetScalarType<T[P], AggregateResearch_proposals[P]>
  }




  export type research_proposalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: research_proposalsWhereInput
    orderBy?: research_proposalsOrderByWithAggregationInput | research_proposalsOrderByWithAggregationInput[]
    by: Research_proposalsScalarFieldEnum[] | Research_proposalsScalarFieldEnum
    having?: research_proposalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Research_proposalsCountAggregateInputType | true
    _min?: Research_proposalsMinAggregateInputType
    _max?: Research_proposalsMaxAggregateInputType
  }

  export type Research_proposalsGroupByOutputType = {
    id: string
    tenant_id: string
    student_id: string
    title: string
    type: string
    description: string | null
    supervisor_preferred: string | null
    status: string | null
    created_at: Date | null
    _count: Research_proposalsCountAggregateOutputType | null
    _min: Research_proposalsMinAggregateOutputType | null
    _max: Research_proposalsMaxAggregateOutputType | null
  }

  type GetResearch_proposalsGroupByPayload<T extends research_proposalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Research_proposalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Research_proposalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Research_proposalsGroupByOutputType[P]>
            : GetScalarType<T[P], Research_proposalsGroupByOutputType[P]>
        }
      >
    >


  export type research_proposalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    supervisor_preferred?: boolean
    status?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["research_proposals"]>

  export type research_proposalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    supervisor_preferred?: boolean
    status?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["research_proposals"]>

  export type research_proposalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    supervisor_preferred?: boolean
    status?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["research_proposals"]>

  export type research_proposalsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    supervisor_preferred?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type research_proposalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "student_id" | "title" | "type" | "description" | "supervisor_preferred" | "status" | "created_at", ExtArgs["result"]["research_proposals"]>
  export type research_proposalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type research_proposalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type research_proposalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $research_proposalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "research_proposals"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      student_id: string
      title: string
      type: string
      description: string | null
      supervisor_preferred: string | null
      status: string | null
      created_at: Date | null
    }, ExtArgs["result"]["research_proposals"]>
    composites: {}
  }

  type research_proposalsGetPayload<S extends boolean | null | undefined | research_proposalsDefaultArgs> = $Result.GetResult<Prisma.$research_proposalsPayload, S>

  type research_proposalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<research_proposalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Research_proposalsCountAggregateInputType | true
    }

  export interface research_proposalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['research_proposals'], meta: { name: 'research_proposals' } }
    /**
     * Find zero or one Research_proposals that matches the filter.
     * @param {research_proposalsFindUniqueArgs} args - Arguments to find a Research_proposals
     * @example
     * // Get one Research_proposals
     * const research_proposals = await prisma.research_proposals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends research_proposalsFindUniqueArgs>(args: SelectSubset<T, research_proposalsFindUniqueArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Research_proposals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {research_proposalsFindUniqueOrThrowArgs} args - Arguments to find a Research_proposals
     * @example
     * // Get one Research_proposals
     * const research_proposals = await prisma.research_proposals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends research_proposalsFindUniqueOrThrowArgs>(args: SelectSubset<T, research_proposalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Research_proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {research_proposalsFindFirstArgs} args - Arguments to find a Research_proposals
     * @example
     * // Get one Research_proposals
     * const research_proposals = await prisma.research_proposals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends research_proposalsFindFirstArgs>(args?: SelectSubset<T, research_proposalsFindFirstArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Research_proposals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {research_proposalsFindFirstOrThrowArgs} args - Arguments to find a Research_proposals
     * @example
     * // Get one Research_proposals
     * const research_proposals = await prisma.research_proposals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends research_proposalsFindFirstOrThrowArgs>(args?: SelectSubset<T, research_proposalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Research_proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {research_proposalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Research_proposals
     * const research_proposals = await prisma.research_proposals.findMany()
     * 
     * // Get first 10 Research_proposals
     * const research_proposals = await prisma.research_proposals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const research_proposalsWithIdOnly = await prisma.research_proposals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends research_proposalsFindManyArgs>(args?: SelectSubset<T, research_proposalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Research_proposals.
     * @param {research_proposalsCreateArgs} args - Arguments to create a Research_proposals.
     * @example
     * // Create one Research_proposals
     * const Research_proposals = await prisma.research_proposals.create({
     *   data: {
     *     // ... data to create a Research_proposals
     *   }
     * })
     * 
     */
    create<T extends research_proposalsCreateArgs>(args: SelectSubset<T, research_proposalsCreateArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Research_proposals.
     * @param {research_proposalsCreateManyArgs} args - Arguments to create many Research_proposals.
     * @example
     * // Create many Research_proposals
     * const research_proposals = await prisma.research_proposals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends research_proposalsCreateManyArgs>(args?: SelectSubset<T, research_proposalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Research_proposals and returns the data saved in the database.
     * @param {research_proposalsCreateManyAndReturnArgs} args - Arguments to create many Research_proposals.
     * @example
     * // Create many Research_proposals
     * const research_proposals = await prisma.research_proposals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Research_proposals and only return the `id`
     * const research_proposalsWithIdOnly = await prisma.research_proposals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends research_proposalsCreateManyAndReturnArgs>(args?: SelectSubset<T, research_proposalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Research_proposals.
     * @param {research_proposalsDeleteArgs} args - Arguments to delete one Research_proposals.
     * @example
     * // Delete one Research_proposals
     * const Research_proposals = await prisma.research_proposals.delete({
     *   where: {
     *     // ... filter to delete one Research_proposals
     *   }
     * })
     * 
     */
    delete<T extends research_proposalsDeleteArgs>(args: SelectSubset<T, research_proposalsDeleteArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Research_proposals.
     * @param {research_proposalsUpdateArgs} args - Arguments to update one Research_proposals.
     * @example
     * // Update one Research_proposals
     * const research_proposals = await prisma.research_proposals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends research_proposalsUpdateArgs>(args: SelectSubset<T, research_proposalsUpdateArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Research_proposals.
     * @param {research_proposalsDeleteManyArgs} args - Arguments to filter Research_proposals to delete.
     * @example
     * // Delete a few Research_proposals
     * const { count } = await prisma.research_proposals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends research_proposalsDeleteManyArgs>(args?: SelectSubset<T, research_proposalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Research_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {research_proposalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Research_proposals
     * const research_proposals = await prisma.research_proposals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends research_proposalsUpdateManyArgs>(args: SelectSubset<T, research_proposalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Research_proposals and returns the data updated in the database.
     * @param {research_proposalsUpdateManyAndReturnArgs} args - Arguments to update many Research_proposals.
     * @example
     * // Update many Research_proposals
     * const research_proposals = await prisma.research_proposals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Research_proposals and only return the `id`
     * const research_proposalsWithIdOnly = await prisma.research_proposals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends research_proposalsUpdateManyAndReturnArgs>(args: SelectSubset<T, research_proposalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Research_proposals.
     * @param {research_proposalsUpsertArgs} args - Arguments to update or create a Research_proposals.
     * @example
     * // Update or create a Research_proposals
     * const research_proposals = await prisma.research_proposals.upsert({
     *   create: {
     *     // ... data to create a Research_proposals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Research_proposals we want to update
     *   }
     * })
     */
    upsert<T extends research_proposalsUpsertArgs>(args: SelectSubset<T, research_proposalsUpsertArgs<ExtArgs>>): Prisma__research_proposalsClient<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Research_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {research_proposalsCountArgs} args - Arguments to filter Research_proposals to count.
     * @example
     * // Count the number of Research_proposals
     * const count = await prisma.research_proposals.count({
     *   where: {
     *     // ... the filter for the Research_proposals we want to count
     *   }
     * })
    **/
    count<T extends research_proposalsCountArgs>(
      args?: Subset<T, research_proposalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Research_proposalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Research_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Research_proposalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Research_proposalsAggregateArgs>(args: Subset<T, Research_proposalsAggregateArgs>): Prisma.PrismaPromise<GetResearch_proposalsAggregateType<T>>

    /**
     * Group by Research_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {research_proposalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends research_proposalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: research_proposalsGroupByArgs['orderBy'] }
        : { orderBy?: research_proposalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, research_proposalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearch_proposalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the research_proposals model
   */
  readonly fields: research_proposalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for research_proposals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__research_proposalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the research_proposals model
   */
  interface research_proposalsFieldRefs {
    readonly id: FieldRef<"research_proposals", 'String'>
    readonly tenant_id: FieldRef<"research_proposals", 'String'>
    readonly student_id: FieldRef<"research_proposals", 'String'>
    readonly title: FieldRef<"research_proposals", 'String'>
    readonly type: FieldRef<"research_proposals", 'String'>
    readonly description: FieldRef<"research_proposals", 'String'>
    readonly supervisor_preferred: FieldRef<"research_proposals", 'String'>
    readonly status: FieldRef<"research_proposals", 'String'>
    readonly created_at: FieldRef<"research_proposals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * research_proposals findUnique
   */
  export type research_proposalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which research_proposals to fetch.
     */
    where: research_proposalsWhereUniqueInput
  }

  /**
   * research_proposals findUniqueOrThrow
   */
  export type research_proposalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which research_proposals to fetch.
     */
    where: research_proposalsWhereUniqueInput
  }

  /**
   * research_proposals findFirst
   */
  export type research_proposalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which research_proposals to fetch.
     */
    where?: research_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of research_proposals to fetch.
     */
    orderBy?: research_proposalsOrderByWithRelationInput | research_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for research_proposals.
     */
    cursor?: research_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` research_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` research_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of research_proposals.
     */
    distinct?: Research_proposalsScalarFieldEnum | Research_proposalsScalarFieldEnum[]
  }

  /**
   * research_proposals findFirstOrThrow
   */
  export type research_proposalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which research_proposals to fetch.
     */
    where?: research_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of research_proposals to fetch.
     */
    orderBy?: research_proposalsOrderByWithRelationInput | research_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for research_proposals.
     */
    cursor?: research_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` research_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` research_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of research_proposals.
     */
    distinct?: Research_proposalsScalarFieldEnum | Research_proposalsScalarFieldEnum[]
  }

  /**
   * research_proposals findMany
   */
  export type research_proposalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * Filter, which research_proposals to fetch.
     */
    where?: research_proposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of research_proposals to fetch.
     */
    orderBy?: research_proposalsOrderByWithRelationInput | research_proposalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing research_proposals.
     */
    cursor?: research_proposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` research_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` research_proposals.
     */
    skip?: number
    distinct?: Research_proposalsScalarFieldEnum | Research_proposalsScalarFieldEnum[]
  }

  /**
   * research_proposals create
   */
  export type research_proposalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * The data needed to create a research_proposals.
     */
    data: XOR<research_proposalsCreateInput, research_proposalsUncheckedCreateInput>
  }

  /**
   * research_proposals createMany
   */
  export type research_proposalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many research_proposals.
     */
    data: research_proposalsCreateManyInput | research_proposalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * research_proposals createManyAndReturn
   */
  export type research_proposalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * The data used to create many research_proposals.
     */
    data: research_proposalsCreateManyInput | research_proposalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * research_proposals update
   */
  export type research_proposalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * The data needed to update a research_proposals.
     */
    data: XOR<research_proposalsUpdateInput, research_proposalsUncheckedUpdateInput>
    /**
     * Choose, which research_proposals to update.
     */
    where: research_proposalsWhereUniqueInput
  }

  /**
   * research_proposals updateMany
   */
  export type research_proposalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update research_proposals.
     */
    data: XOR<research_proposalsUpdateManyMutationInput, research_proposalsUncheckedUpdateManyInput>
    /**
     * Filter which research_proposals to update
     */
    where?: research_proposalsWhereInput
    /**
     * Limit how many research_proposals to update.
     */
    limit?: number
  }

  /**
   * research_proposals updateManyAndReturn
   */
  export type research_proposalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * The data used to update research_proposals.
     */
    data: XOR<research_proposalsUpdateManyMutationInput, research_proposalsUncheckedUpdateManyInput>
    /**
     * Filter which research_proposals to update
     */
    where?: research_proposalsWhereInput
    /**
     * Limit how many research_proposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * research_proposals upsert
   */
  export type research_proposalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * The filter to search for the research_proposals to update in case it exists.
     */
    where: research_proposalsWhereUniqueInput
    /**
     * In case the research_proposals found by the `where` argument doesn't exist, create a new research_proposals with this data.
     */
    create: XOR<research_proposalsCreateInput, research_proposalsUncheckedCreateInput>
    /**
     * In case the research_proposals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<research_proposalsUpdateInput, research_proposalsUncheckedUpdateInput>
  }

  /**
   * research_proposals delete
   */
  export type research_proposalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    /**
     * Filter which research_proposals to delete.
     */
    where: research_proposalsWhereUniqueInput
  }

  /**
   * research_proposals deleteMany
   */
  export type research_proposalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which research_proposals to delete
     */
    where?: research_proposalsWhereInput
    /**
     * Limit how many research_proposals to delete.
     */
    limit?: number
  }

  /**
   * research_proposals without action
   */
  export type research_proposalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
  }


  /**
   * Model student_profiles
   */

  export type AggregateStudent_profiles = {
    _count: Student_profilesCountAggregateOutputType | null
    _avg: Student_profilesAvgAggregateOutputType | null
    _sum: Student_profilesSumAggregateOutputType | null
    _min: Student_profilesMinAggregateOutputType | null
    _max: Student_profilesMaxAggregateOutputType | null
  }

  export type Student_profilesAvgAggregateOutputType = {
    job_start_year: number | null
    graduation_year: number | null
  }

  export type Student_profilesSumAggregateOutputType = {
    job_start_year: number | null
    graduation_year: number | null
  }

  export type Student_profilesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    gender: string | null
    place_of_birth: string | null
    date_of_birth: Date | null
    religion: string | null
    phone_1: string | null
    phone_2: string | null
    whatsapp: string | null
    job_status: string | null
    company_name: string | null
    job_start_year: number | null
    income_range: string | null
    ktp_province: string | null
    ktp_city: string | null
    ktp_district: string | null
    ktp_subdistrict: string | null
    ktp_rt: string | null
    ktp_rw: string | null
    ktp_postal_code: string | null
    ktp_address: string | null
    current_province: string | null
    current_city: string | null
    current_district: string | null
    current_subdistrict: string | null
    current_rt: string | null
    current_rw: string | null
    current_postal_code: string | null
    current_address: string | null
    citizenship: string | null
    nik: string | null
    kk_number: string | null
    living_status: string | null
    father_nik: string | null
    father_name: string | null
    father_living_status: string | null
    father_phone: string | null
    father_place_of_birth: string | null
    father_date_of_birth: Date | null
    father_religion: string | null
    father_job: string | null
    father_income_range: string | null
    father_address: string | null
    mother_nik: string | null
    mother_name: string | null
    mother_living_status: string | null
    mother_phone: string | null
    mother_place_of_birth: string | null
    mother_date_of_birth: Date | null
    mother_religion: string | null
    mother_job: string | null
    mother_income_range: string | null
    mother_address: string | null
    school_name: string | null
    school_major: string | null
    nisn: string | null
    diploma_number: string | null
    graduation_year: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_profilesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    student_id: string | null
    gender: string | null
    place_of_birth: string | null
    date_of_birth: Date | null
    religion: string | null
    phone_1: string | null
    phone_2: string | null
    whatsapp: string | null
    job_status: string | null
    company_name: string | null
    job_start_year: number | null
    income_range: string | null
    ktp_province: string | null
    ktp_city: string | null
    ktp_district: string | null
    ktp_subdistrict: string | null
    ktp_rt: string | null
    ktp_rw: string | null
    ktp_postal_code: string | null
    ktp_address: string | null
    current_province: string | null
    current_city: string | null
    current_district: string | null
    current_subdistrict: string | null
    current_rt: string | null
    current_rw: string | null
    current_postal_code: string | null
    current_address: string | null
    citizenship: string | null
    nik: string | null
    kk_number: string | null
    living_status: string | null
    father_nik: string | null
    father_name: string | null
    father_living_status: string | null
    father_phone: string | null
    father_place_of_birth: string | null
    father_date_of_birth: Date | null
    father_religion: string | null
    father_job: string | null
    father_income_range: string | null
    father_address: string | null
    mother_nik: string | null
    mother_name: string | null
    mother_living_status: string | null
    mother_phone: string | null
    mother_place_of_birth: string | null
    mother_date_of_birth: Date | null
    mother_religion: string | null
    mother_job: string | null
    mother_income_range: string | null
    mother_address: string | null
    school_name: string | null
    school_major: string | null
    nisn: string | null
    diploma_number: string | null
    graduation_year: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_profilesCountAggregateOutputType = {
    id: number
    tenant_id: number
    student_id: number
    gender: number
    place_of_birth: number
    date_of_birth: number
    religion: number
    phone_1: number
    phone_2: number
    whatsapp: number
    job_status: number
    company_name: number
    job_start_year: number
    income_range: number
    ktp_province: number
    ktp_city: number
    ktp_district: number
    ktp_subdistrict: number
    ktp_rt: number
    ktp_rw: number
    ktp_postal_code: number
    ktp_address: number
    current_province: number
    current_city: number
    current_district: number
    current_subdistrict: number
    current_rt: number
    current_rw: number
    current_postal_code: number
    current_address: number
    citizenship: number
    nik: number
    kk_number: number
    living_status: number
    father_nik: number
    father_name: number
    father_living_status: number
    father_phone: number
    father_place_of_birth: number
    father_date_of_birth: number
    father_religion: number
    father_job: number
    father_income_range: number
    father_address: number
    mother_nik: number
    mother_name: number
    mother_living_status: number
    mother_phone: number
    mother_place_of_birth: number
    mother_date_of_birth: number
    mother_religion: number
    mother_job: number
    mother_income_range: number
    mother_address: number
    school_name: number
    school_major: number
    nisn: number
    diploma_number: number
    graduation_year: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Student_profilesAvgAggregateInputType = {
    job_start_year?: true
    graduation_year?: true
  }

  export type Student_profilesSumAggregateInputType = {
    job_start_year?: true
    graduation_year?: true
  }

  export type Student_profilesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    gender?: true
    place_of_birth?: true
    date_of_birth?: true
    religion?: true
    phone_1?: true
    phone_2?: true
    whatsapp?: true
    job_status?: true
    company_name?: true
    job_start_year?: true
    income_range?: true
    ktp_province?: true
    ktp_city?: true
    ktp_district?: true
    ktp_subdistrict?: true
    ktp_rt?: true
    ktp_rw?: true
    ktp_postal_code?: true
    ktp_address?: true
    current_province?: true
    current_city?: true
    current_district?: true
    current_subdistrict?: true
    current_rt?: true
    current_rw?: true
    current_postal_code?: true
    current_address?: true
    citizenship?: true
    nik?: true
    kk_number?: true
    living_status?: true
    father_nik?: true
    father_name?: true
    father_living_status?: true
    father_phone?: true
    father_place_of_birth?: true
    father_date_of_birth?: true
    father_religion?: true
    father_job?: true
    father_income_range?: true
    father_address?: true
    mother_nik?: true
    mother_name?: true
    mother_living_status?: true
    mother_phone?: true
    mother_place_of_birth?: true
    mother_date_of_birth?: true
    mother_religion?: true
    mother_job?: true
    mother_income_range?: true
    mother_address?: true
    school_name?: true
    school_major?: true
    nisn?: true
    diploma_number?: true
    graduation_year?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_profilesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    gender?: true
    place_of_birth?: true
    date_of_birth?: true
    religion?: true
    phone_1?: true
    phone_2?: true
    whatsapp?: true
    job_status?: true
    company_name?: true
    job_start_year?: true
    income_range?: true
    ktp_province?: true
    ktp_city?: true
    ktp_district?: true
    ktp_subdistrict?: true
    ktp_rt?: true
    ktp_rw?: true
    ktp_postal_code?: true
    ktp_address?: true
    current_province?: true
    current_city?: true
    current_district?: true
    current_subdistrict?: true
    current_rt?: true
    current_rw?: true
    current_postal_code?: true
    current_address?: true
    citizenship?: true
    nik?: true
    kk_number?: true
    living_status?: true
    father_nik?: true
    father_name?: true
    father_living_status?: true
    father_phone?: true
    father_place_of_birth?: true
    father_date_of_birth?: true
    father_religion?: true
    father_job?: true
    father_income_range?: true
    father_address?: true
    mother_nik?: true
    mother_name?: true
    mother_living_status?: true
    mother_phone?: true
    mother_place_of_birth?: true
    mother_date_of_birth?: true
    mother_religion?: true
    mother_job?: true
    mother_income_range?: true
    mother_address?: true
    school_name?: true
    school_major?: true
    nisn?: true
    diploma_number?: true
    graduation_year?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_profilesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    student_id?: true
    gender?: true
    place_of_birth?: true
    date_of_birth?: true
    religion?: true
    phone_1?: true
    phone_2?: true
    whatsapp?: true
    job_status?: true
    company_name?: true
    job_start_year?: true
    income_range?: true
    ktp_province?: true
    ktp_city?: true
    ktp_district?: true
    ktp_subdistrict?: true
    ktp_rt?: true
    ktp_rw?: true
    ktp_postal_code?: true
    ktp_address?: true
    current_province?: true
    current_city?: true
    current_district?: true
    current_subdistrict?: true
    current_rt?: true
    current_rw?: true
    current_postal_code?: true
    current_address?: true
    citizenship?: true
    nik?: true
    kk_number?: true
    living_status?: true
    father_nik?: true
    father_name?: true
    father_living_status?: true
    father_phone?: true
    father_place_of_birth?: true
    father_date_of_birth?: true
    father_religion?: true
    father_job?: true
    father_income_range?: true
    father_address?: true
    mother_nik?: true
    mother_name?: true
    mother_living_status?: true
    mother_phone?: true
    mother_place_of_birth?: true
    mother_date_of_birth?: true
    mother_religion?: true
    mother_job?: true
    mother_income_range?: true
    mother_address?: true
    school_name?: true
    school_major?: true
    nisn?: true
    diploma_number?: true
    graduation_year?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Student_profilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_profiles to aggregate.
     */
    where?: student_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_profiles to fetch.
     */
    orderBy?: student_profilesOrderByWithRelationInput | student_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_profiles
    **/
    _count?: true | Student_profilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_profilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_profilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_profilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_profilesMaxAggregateInputType
  }

  export type GetStudent_profilesAggregateType<T extends Student_profilesAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_profiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_profiles[P]>
      : GetScalarType<T[P], AggregateStudent_profiles[P]>
  }




  export type student_profilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_profilesWhereInput
    orderBy?: student_profilesOrderByWithAggregationInput | student_profilesOrderByWithAggregationInput[]
    by: Student_profilesScalarFieldEnum[] | Student_profilesScalarFieldEnum
    having?: student_profilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_profilesCountAggregateInputType | true
    _avg?: Student_profilesAvgAggregateInputType
    _sum?: Student_profilesSumAggregateInputType
    _min?: Student_profilesMinAggregateInputType
    _max?: Student_profilesMaxAggregateInputType
  }

  export type Student_profilesGroupByOutputType = {
    id: string
    tenant_id: string
    student_id: string
    gender: string | null
    place_of_birth: string | null
    date_of_birth: Date | null
    religion: string | null
    phone_1: string | null
    phone_2: string | null
    whatsapp: string | null
    job_status: string | null
    company_name: string | null
    job_start_year: number | null
    income_range: string | null
    ktp_province: string | null
    ktp_city: string | null
    ktp_district: string | null
    ktp_subdistrict: string | null
    ktp_rt: string | null
    ktp_rw: string | null
    ktp_postal_code: string | null
    ktp_address: string | null
    current_province: string | null
    current_city: string | null
    current_district: string | null
    current_subdistrict: string | null
    current_rt: string | null
    current_rw: string | null
    current_postal_code: string | null
    current_address: string | null
    citizenship: string | null
    nik: string | null
    kk_number: string | null
    living_status: string | null
    father_nik: string | null
    father_name: string | null
    father_living_status: string | null
    father_phone: string | null
    father_place_of_birth: string | null
    father_date_of_birth: Date | null
    father_religion: string | null
    father_job: string | null
    father_income_range: string | null
    father_address: string | null
    mother_nik: string | null
    mother_name: string | null
    mother_living_status: string | null
    mother_phone: string | null
    mother_place_of_birth: string | null
    mother_date_of_birth: Date | null
    mother_religion: string | null
    mother_job: string | null
    mother_income_range: string | null
    mother_address: string | null
    school_name: string | null
    school_major: string | null
    nisn: string | null
    diploma_number: string | null
    graduation_year: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Student_profilesCountAggregateOutputType | null
    _avg: Student_profilesAvgAggregateOutputType | null
    _sum: Student_profilesSumAggregateOutputType | null
    _min: Student_profilesMinAggregateOutputType | null
    _max: Student_profilesMaxAggregateOutputType | null
  }

  type GetStudent_profilesGroupByPayload<T extends student_profilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_profilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_profilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_profilesGroupByOutputType[P]>
            : GetScalarType<T[P], Student_profilesGroupByOutputType[P]>
        }
      >
    >


  export type student_profilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    gender?: boolean
    place_of_birth?: boolean
    date_of_birth?: boolean
    religion?: boolean
    phone_1?: boolean
    phone_2?: boolean
    whatsapp?: boolean
    job_status?: boolean
    company_name?: boolean
    job_start_year?: boolean
    income_range?: boolean
    ktp_province?: boolean
    ktp_city?: boolean
    ktp_district?: boolean
    ktp_subdistrict?: boolean
    ktp_rt?: boolean
    ktp_rw?: boolean
    ktp_postal_code?: boolean
    ktp_address?: boolean
    current_province?: boolean
    current_city?: boolean
    current_district?: boolean
    current_subdistrict?: boolean
    current_rt?: boolean
    current_rw?: boolean
    current_postal_code?: boolean
    current_address?: boolean
    citizenship?: boolean
    nik?: boolean
    kk_number?: boolean
    living_status?: boolean
    father_nik?: boolean
    father_name?: boolean
    father_living_status?: boolean
    father_phone?: boolean
    father_place_of_birth?: boolean
    father_date_of_birth?: boolean
    father_religion?: boolean
    father_job?: boolean
    father_income_range?: boolean
    father_address?: boolean
    mother_nik?: boolean
    mother_name?: boolean
    mother_living_status?: boolean
    mother_phone?: boolean
    mother_place_of_birth?: boolean
    mother_date_of_birth?: boolean
    mother_religion?: boolean
    mother_job?: boolean
    mother_income_range?: boolean
    mother_address?: boolean
    school_name?: boolean
    school_major?: boolean
    nisn?: boolean
    diploma_number?: boolean
    graduation_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_profiles"]>

  export type student_profilesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    gender?: boolean
    place_of_birth?: boolean
    date_of_birth?: boolean
    religion?: boolean
    phone_1?: boolean
    phone_2?: boolean
    whatsapp?: boolean
    job_status?: boolean
    company_name?: boolean
    job_start_year?: boolean
    income_range?: boolean
    ktp_province?: boolean
    ktp_city?: boolean
    ktp_district?: boolean
    ktp_subdistrict?: boolean
    ktp_rt?: boolean
    ktp_rw?: boolean
    ktp_postal_code?: boolean
    ktp_address?: boolean
    current_province?: boolean
    current_city?: boolean
    current_district?: boolean
    current_subdistrict?: boolean
    current_rt?: boolean
    current_rw?: boolean
    current_postal_code?: boolean
    current_address?: boolean
    citizenship?: boolean
    nik?: boolean
    kk_number?: boolean
    living_status?: boolean
    father_nik?: boolean
    father_name?: boolean
    father_living_status?: boolean
    father_phone?: boolean
    father_place_of_birth?: boolean
    father_date_of_birth?: boolean
    father_religion?: boolean
    father_job?: boolean
    father_income_range?: boolean
    father_address?: boolean
    mother_nik?: boolean
    mother_name?: boolean
    mother_living_status?: boolean
    mother_phone?: boolean
    mother_place_of_birth?: boolean
    mother_date_of_birth?: boolean
    mother_religion?: boolean
    mother_job?: boolean
    mother_income_range?: boolean
    mother_address?: boolean
    school_name?: boolean
    school_major?: boolean
    nisn?: boolean
    diploma_number?: boolean
    graduation_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_profiles"]>

  export type student_profilesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    gender?: boolean
    place_of_birth?: boolean
    date_of_birth?: boolean
    religion?: boolean
    phone_1?: boolean
    phone_2?: boolean
    whatsapp?: boolean
    job_status?: boolean
    company_name?: boolean
    job_start_year?: boolean
    income_range?: boolean
    ktp_province?: boolean
    ktp_city?: boolean
    ktp_district?: boolean
    ktp_subdistrict?: boolean
    ktp_rt?: boolean
    ktp_rw?: boolean
    ktp_postal_code?: boolean
    ktp_address?: boolean
    current_province?: boolean
    current_city?: boolean
    current_district?: boolean
    current_subdistrict?: boolean
    current_rt?: boolean
    current_rw?: boolean
    current_postal_code?: boolean
    current_address?: boolean
    citizenship?: boolean
    nik?: boolean
    kk_number?: boolean
    living_status?: boolean
    father_nik?: boolean
    father_name?: boolean
    father_living_status?: boolean
    father_phone?: boolean
    father_place_of_birth?: boolean
    father_date_of_birth?: boolean
    father_religion?: boolean
    father_job?: boolean
    father_income_range?: boolean
    father_address?: boolean
    mother_nik?: boolean
    mother_name?: boolean
    mother_living_status?: boolean
    mother_phone?: boolean
    mother_place_of_birth?: boolean
    mother_date_of_birth?: boolean
    mother_religion?: boolean
    mother_job?: boolean
    mother_income_range?: boolean
    mother_address?: boolean
    school_name?: boolean
    school_major?: boolean
    nisn?: boolean
    diploma_number?: boolean
    graduation_year?: boolean
    created_at?: boolean
    updated_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_profiles"]>

  export type student_profilesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    student_id?: boolean
    gender?: boolean
    place_of_birth?: boolean
    date_of_birth?: boolean
    religion?: boolean
    phone_1?: boolean
    phone_2?: boolean
    whatsapp?: boolean
    job_status?: boolean
    company_name?: boolean
    job_start_year?: boolean
    income_range?: boolean
    ktp_province?: boolean
    ktp_city?: boolean
    ktp_district?: boolean
    ktp_subdistrict?: boolean
    ktp_rt?: boolean
    ktp_rw?: boolean
    ktp_postal_code?: boolean
    ktp_address?: boolean
    current_province?: boolean
    current_city?: boolean
    current_district?: boolean
    current_subdistrict?: boolean
    current_rt?: boolean
    current_rw?: boolean
    current_postal_code?: boolean
    current_address?: boolean
    citizenship?: boolean
    nik?: boolean
    kk_number?: boolean
    living_status?: boolean
    father_nik?: boolean
    father_name?: boolean
    father_living_status?: boolean
    father_phone?: boolean
    father_place_of_birth?: boolean
    father_date_of_birth?: boolean
    father_religion?: boolean
    father_job?: boolean
    father_income_range?: boolean
    father_address?: boolean
    mother_nik?: boolean
    mother_name?: boolean
    mother_living_status?: boolean
    mother_phone?: boolean
    mother_place_of_birth?: boolean
    mother_date_of_birth?: boolean
    mother_religion?: boolean
    mother_job?: boolean
    mother_income_range?: boolean
    mother_address?: boolean
    school_name?: boolean
    school_major?: boolean
    nisn?: boolean
    diploma_number?: boolean
    graduation_year?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type student_profilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "student_id" | "gender" | "place_of_birth" | "date_of_birth" | "religion" | "phone_1" | "phone_2" | "whatsapp" | "job_status" | "company_name" | "job_start_year" | "income_range" | "ktp_province" | "ktp_city" | "ktp_district" | "ktp_subdistrict" | "ktp_rt" | "ktp_rw" | "ktp_postal_code" | "ktp_address" | "current_province" | "current_city" | "current_district" | "current_subdistrict" | "current_rt" | "current_rw" | "current_postal_code" | "current_address" | "citizenship" | "nik" | "kk_number" | "living_status" | "father_nik" | "father_name" | "father_living_status" | "father_phone" | "father_place_of_birth" | "father_date_of_birth" | "father_religion" | "father_job" | "father_income_range" | "father_address" | "mother_nik" | "mother_name" | "mother_living_status" | "mother_phone" | "mother_place_of_birth" | "mother_date_of_birth" | "mother_religion" | "mother_job" | "mother_income_range" | "mother_address" | "school_name" | "school_major" | "nisn" | "diploma_number" | "graduation_year" | "created_at" | "updated_at", ExtArgs["result"]["student_profiles"]>
  export type student_profilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type student_profilesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type student_profilesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $student_profilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_profiles"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      student_id: string
      gender: string | null
      place_of_birth: string | null
      date_of_birth: Date | null
      religion: string | null
      phone_1: string | null
      phone_2: string | null
      whatsapp: string | null
      job_status: string | null
      company_name: string | null
      job_start_year: number | null
      income_range: string | null
      ktp_province: string | null
      ktp_city: string | null
      ktp_district: string | null
      ktp_subdistrict: string | null
      ktp_rt: string | null
      ktp_rw: string | null
      ktp_postal_code: string | null
      ktp_address: string | null
      current_province: string | null
      current_city: string | null
      current_district: string | null
      current_subdistrict: string | null
      current_rt: string | null
      current_rw: string | null
      current_postal_code: string | null
      current_address: string | null
      citizenship: string | null
      nik: string | null
      kk_number: string | null
      living_status: string | null
      father_nik: string | null
      father_name: string | null
      father_living_status: string | null
      father_phone: string | null
      father_place_of_birth: string | null
      father_date_of_birth: Date | null
      father_religion: string | null
      father_job: string | null
      father_income_range: string | null
      father_address: string | null
      mother_nik: string | null
      mother_name: string | null
      mother_living_status: string | null
      mother_phone: string | null
      mother_place_of_birth: string | null
      mother_date_of_birth: Date | null
      mother_religion: string | null
      mother_job: string | null
      mother_income_range: string | null
      mother_address: string | null
      school_name: string | null
      school_major: string | null
      nisn: string | null
      diploma_number: string | null
      graduation_year: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["student_profiles"]>
    composites: {}
  }

  type student_profilesGetPayload<S extends boolean | null | undefined | student_profilesDefaultArgs> = $Result.GetResult<Prisma.$student_profilesPayload, S>

  type student_profilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_profilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Student_profilesCountAggregateInputType | true
    }

  export interface student_profilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_profiles'], meta: { name: 'student_profiles' } }
    /**
     * Find zero or one Student_profiles that matches the filter.
     * @param {student_profilesFindUniqueArgs} args - Arguments to find a Student_profiles
     * @example
     * // Get one Student_profiles
     * const student_profiles = await prisma.student_profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_profilesFindUniqueArgs>(args: SelectSubset<T, student_profilesFindUniqueArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student_profiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_profilesFindUniqueOrThrowArgs} args - Arguments to find a Student_profiles
     * @example
     * // Get one Student_profiles
     * const student_profiles = await prisma.student_profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_profilesFindUniqueOrThrowArgs>(args: SelectSubset<T, student_profilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_profilesFindFirstArgs} args - Arguments to find a Student_profiles
     * @example
     * // Get one Student_profiles
     * const student_profiles = await prisma.student_profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_profilesFindFirstArgs>(args?: SelectSubset<T, student_profilesFindFirstArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_profiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_profilesFindFirstOrThrowArgs} args - Arguments to find a Student_profiles
     * @example
     * // Get one Student_profiles
     * const student_profiles = await prisma.student_profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_profilesFindFirstOrThrowArgs>(args?: SelectSubset<T, student_profilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Student_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_profilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_profiles
     * const student_profiles = await prisma.student_profiles.findMany()
     * 
     * // Get first 10 Student_profiles
     * const student_profiles = await prisma.student_profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_profilesWithIdOnly = await prisma.student_profiles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_profilesFindManyArgs>(args?: SelectSubset<T, student_profilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student_profiles.
     * @param {student_profilesCreateArgs} args - Arguments to create a Student_profiles.
     * @example
     * // Create one Student_profiles
     * const Student_profiles = await prisma.student_profiles.create({
     *   data: {
     *     // ... data to create a Student_profiles
     *   }
     * })
     * 
     */
    create<T extends student_profilesCreateArgs>(args: SelectSubset<T, student_profilesCreateArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Student_profiles.
     * @param {student_profilesCreateManyArgs} args - Arguments to create many Student_profiles.
     * @example
     * // Create many Student_profiles
     * const student_profiles = await prisma.student_profiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_profilesCreateManyArgs>(args?: SelectSubset<T, student_profilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_profiles and returns the data saved in the database.
     * @param {student_profilesCreateManyAndReturnArgs} args - Arguments to create many Student_profiles.
     * @example
     * // Create many Student_profiles
     * const student_profiles = await prisma.student_profiles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_profiles and only return the `id`
     * const student_profilesWithIdOnly = await prisma.student_profiles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_profilesCreateManyAndReturnArgs>(args?: SelectSubset<T, student_profilesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student_profiles.
     * @param {student_profilesDeleteArgs} args - Arguments to delete one Student_profiles.
     * @example
     * // Delete one Student_profiles
     * const Student_profiles = await prisma.student_profiles.delete({
     *   where: {
     *     // ... filter to delete one Student_profiles
     *   }
     * })
     * 
     */
    delete<T extends student_profilesDeleteArgs>(args: SelectSubset<T, student_profilesDeleteArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student_profiles.
     * @param {student_profilesUpdateArgs} args - Arguments to update one Student_profiles.
     * @example
     * // Update one Student_profiles
     * const student_profiles = await prisma.student_profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_profilesUpdateArgs>(args: SelectSubset<T, student_profilesUpdateArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Student_profiles.
     * @param {student_profilesDeleteManyArgs} args - Arguments to filter Student_profiles to delete.
     * @example
     * // Delete a few Student_profiles
     * const { count } = await prisma.student_profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_profilesDeleteManyArgs>(args?: SelectSubset<T, student_profilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_profilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_profiles
     * const student_profiles = await prisma.student_profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_profilesUpdateManyArgs>(args: SelectSubset<T, student_profilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_profiles and returns the data updated in the database.
     * @param {student_profilesUpdateManyAndReturnArgs} args - Arguments to update many Student_profiles.
     * @example
     * // Update many Student_profiles
     * const student_profiles = await prisma.student_profiles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Student_profiles and only return the `id`
     * const student_profilesWithIdOnly = await prisma.student_profiles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends student_profilesUpdateManyAndReturnArgs>(args: SelectSubset<T, student_profilesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student_profiles.
     * @param {student_profilesUpsertArgs} args - Arguments to update or create a Student_profiles.
     * @example
     * // Update or create a Student_profiles
     * const student_profiles = await prisma.student_profiles.upsert({
     *   create: {
     *     // ... data to create a Student_profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_profiles we want to update
     *   }
     * })
     */
    upsert<T extends student_profilesUpsertArgs>(args: SelectSubset<T, student_profilesUpsertArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Student_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_profilesCountArgs} args - Arguments to filter Student_profiles to count.
     * @example
     * // Count the number of Student_profiles
     * const count = await prisma.student_profiles.count({
     *   where: {
     *     // ... the filter for the Student_profiles we want to count
     *   }
     * })
    **/
    count<T extends student_profilesCountArgs>(
      args?: Subset<T, student_profilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_profilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_profilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_profilesAggregateArgs>(args: Subset<T, Student_profilesAggregateArgs>): Prisma.PrismaPromise<GetStudent_profilesAggregateType<T>>

    /**
     * Group by Student_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_profilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_profilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_profilesGroupByArgs['orderBy'] }
        : { orderBy?: student_profilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_profilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_profilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_profiles model
   */
  readonly fields: student_profilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_profilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_profiles model
   */
  interface student_profilesFieldRefs {
    readonly id: FieldRef<"student_profiles", 'String'>
    readonly tenant_id: FieldRef<"student_profiles", 'String'>
    readonly student_id: FieldRef<"student_profiles", 'String'>
    readonly gender: FieldRef<"student_profiles", 'String'>
    readonly place_of_birth: FieldRef<"student_profiles", 'String'>
    readonly date_of_birth: FieldRef<"student_profiles", 'DateTime'>
    readonly religion: FieldRef<"student_profiles", 'String'>
    readonly phone_1: FieldRef<"student_profiles", 'String'>
    readonly phone_2: FieldRef<"student_profiles", 'String'>
    readonly whatsapp: FieldRef<"student_profiles", 'String'>
    readonly job_status: FieldRef<"student_profiles", 'String'>
    readonly company_name: FieldRef<"student_profiles", 'String'>
    readonly job_start_year: FieldRef<"student_profiles", 'Int'>
    readonly income_range: FieldRef<"student_profiles", 'String'>
    readonly ktp_province: FieldRef<"student_profiles", 'String'>
    readonly ktp_city: FieldRef<"student_profiles", 'String'>
    readonly ktp_district: FieldRef<"student_profiles", 'String'>
    readonly ktp_subdistrict: FieldRef<"student_profiles", 'String'>
    readonly ktp_rt: FieldRef<"student_profiles", 'String'>
    readonly ktp_rw: FieldRef<"student_profiles", 'String'>
    readonly ktp_postal_code: FieldRef<"student_profiles", 'String'>
    readonly ktp_address: FieldRef<"student_profiles", 'String'>
    readonly current_province: FieldRef<"student_profiles", 'String'>
    readonly current_city: FieldRef<"student_profiles", 'String'>
    readonly current_district: FieldRef<"student_profiles", 'String'>
    readonly current_subdistrict: FieldRef<"student_profiles", 'String'>
    readonly current_rt: FieldRef<"student_profiles", 'String'>
    readonly current_rw: FieldRef<"student_profiles", 'String'>
    readonly current_postal_code: FieldRef<"student_profiles", 'String'>
    readonly current_address: FieldRef<"student_profiles", 'String'>
    readonly citizenship: FieldRef<"student_profiles", 'String'>
    readonly nik: FieldRef<"student_profiles", 'String'>
    readonly kk_number: FieldRef<"student_profiles", 'String'>
    readonly living_status: FieldRef<"student_profiles", 'String'>
    readonly father_nik: FieldRef<"student_profiles", 'String'>
    readonly father_name: FieldRef<"student_profiles", 'String'>
    readonly father_living_status: FieldRef<"student_profiles", 'String'>
    readonly father_phone: FieldRef<"student_profiles", 'String'>
    readonly father_place_of_birth: FieldRef<"student_profiles", 'String'>
    readonly father_date_of_birth: FieldRef<"student_profiles", 'DateTime'>
    readonly father_religion: FieldRef<"student_profiles", 'String'>
    readonly father_job: FieldRef<"student_profiles", 'String'>
    readonly father_income_range: FieldRef<"student_profiles", 'String'>
    readonly father_address: FieldRef<"student_profiles", 'String'>
    readonly mother_nik: FieldRef<"student_profiles", 'String'>
    readonly mother_name: FieldRef<"student_profiles", 'String'>
    readonly mother_living_status: FieldRef<"student_profiles", 'String'>
    readonly mother_phone: FieldRef<"student_profiles", 'String'>
    readonly mother_place_of_birth: FieldRef<"student_profiles", 'String'>
    readonly mother_date_of_birth: FieldRef<"student_profiles", 'DateTime'>
    readonly mother_religion: FieldRef<"student_profiles", 'String'>
    readonly mother_job: FieldRef<"student_profiles", 'String'>
    readonly mother_income_range: FieldRef<"student_profiles", 'String'>
    readonly mother_address: FieldRef<"student_profiles", 'String'>
    readonly school_name: FieldRef<"student_profiles", 'String'>
    readonly school_major: FieldRef<"student_profiles", 'String'>
    readonly nisn: FieldRef<"student_profiles", 'String'>
    readonly diploma_number: FieldRef<"student_profiles", 'String'>
    readonly graduation_year: FieldRef<"student_profiles", 'Int'>
    readonly created_at: FieldRef<"student_profiles", 'DateTime'>
    readonly updated_at: FieldRef<"student_profiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_profiles findUnique
   */
  export type student_profilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * Filter, which student_profiles to fetch.
     */
    where: student_profilesWhereUniqueInput
  }

  /**
   * student_profiles findUniqueOrThrow
   */
  export type student_profilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * Filter, which student_profiles to fetch.
     */
    where: student_profilesWhereUniqueInput
  }

  /**
   * student_profiles findFirst
   */
  export type student_profilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * Filter, which student_profiles to fetch.
     */
    where?: student_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_profiles to fetch.
     */
    orderBy?: student_profilesOrderByWithRelationInput | student_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_profiles.
     */
    cursor?: student_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_profiles.
     */
    distinct?: Student_profilesScalarFieldEnum | Student_profilesScalarFieldEnum[]
  }

  /**
   * student_profiles findFirstOrThrow
   */
  export type student_profilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * Filter, which student_profiles to fetch.
     */
    where?: student_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_profiles to fetch.
     */
    orderBy?: student_profilesOrderByWithRelationInput | student_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_profiles.
     */
    cursor?: student_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_profiles.
     */
    distinct?: Student_profilesScalarFieldEnum | Student_profilesScalarFieldEnum[]
  }

  /**
   * student_profiles findMany
   */
  export type student_profilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * Filter, which student_profiles to fetch.
     */
    where?: student_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_profiles to fetch.
     */
    orderBy?: student_profilesOrderByWithRelationInput | student_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_profiles.
     */
    cursor?: student_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_profiles.
     */
    skip?: number
    distinct?: Student_profilesScalarFieldEnum | Student_profilesScalarFieldEnum[]
  }

  /**
   * student_profiles create
   */
  export type student_profilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * The data needed to create a student_profiles.
     */
    data: XOR<student_profilesCreateInput, student_profilesUncheckedCreateInput>
  }

  /**
   * student_profiles createMany
   */
  export type student_profilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_profiles.
     */
    data: student_profilesCreateManyInput | student_profilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_profiles createManyAndReturn
   */
  export type student_profilesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * The data used to create many student_profiles.
     */
    data: student_profilesCreateManyInput | student_profilesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_profiles update
   */
  export type student_profilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * The data needed to update a student_profiles.
     */
    data: XOR<student_profilesUpdateInput, student_profilesUncheckedUpdateInput>
    /**
     * Choose, which student_profiles to update.
     */
    where: student_profilesWhereUniqueInput
  }

  /**
   * student_profiles updateMany
   */
  export type student_profilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_profiles.
     */
    data: XOR<student_profilesUpdateManyMutationInput, student_profilesUncheckedUpdateManyInput>
    /**
     * Filter which student_profiles to update
     */
    where?: student_profilesWhereInput
    /**
     * Limit how many student_profiles to update.
     */
    limit?: number
  }

  /**
   * student_profiles updateManyAndReturn
   */
  export type student_profilesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * The data used to update student_profiles.
     */
    data: XOR<student_profilesUpdateManyMutationInput, student_profilesUncheckedUpdateManyInput>
    /**
     * Filter which student_profiles to update
     */
    where?: student_profilesWhereInput
    /**
     * Limit how many student_profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_profiles upsert
   */
  export type student_profilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * The filter to search for the student_profiles to update in case it exists.
     */
    where: student_profilesWhereUniqueInput
    /**
     * In case the student_profiles found by the `where` argument doesn't exist, create a new student_profiles with this data.
     */
    create: XOR<student_profilesCreateInput, student_profilesUncheckedCreateInput>
    /**
     * In case the student_profiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_profilesUpdateInput, student_profilesUncheckedUpdateInput>
  }

  /**
   * student_profiles delete
   */
  export type student_profilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    /**
     * Filter which student_profiles to delete.
     */
    where: student_profilesWhereUniqueInput
  }

  /**
   * student_profiles deleteMany
   */
  export type student_profilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_profiles to delete
     */
    where?: student_profilesWhereInput
    /**
     * Limit how many student_profiles to delete.
     */
    limit?: number
  }

  /**
   * student_profiles without action
   */
  export type student_profilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
  }


  /**
   * Model students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    entry_year: number | null
  }

  export type StudentsSumAggregateOutputType = {
    entry_year: number | null
  }

  export type StudentsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    platform_student_number: string | null
    name: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    study_program: string | null
    entry_year: number | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    platform_student_number: string | null
    name: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    study_program: string | null
    entry_year: number | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    tenant_id: number
    user_id: number
    platform_student_number: number
    name: number
    status: number
    created_at: number
    updated_at: number
    study_program: number
    entry_year: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    entry_year?: true
  }

  export type StudentsSumAggregateInputType = {
    entry_year?: true
  }

  export type StudentsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    platform_student_number?: true
    name?: true
    status?: true
    created_at?: true
    updated_at?: true
    study_program?: true
    entry_year?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    platform_student_number?: true
    name?: true
    status?: true
    created_at?: true
    updated_at?: true
    study_program?: true
    entry_year?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    platform_student_number?: true
    name?: true
    status?: true
    created_at?: true
    updated_at?: true
    study_program?: true
    entry_year?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to aggregate.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type studentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithAggregationInput | studentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: studentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: string
    tenant_id: string
    user_id: string
    platform_student_number: string | null
    name: string
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    study_program: string | null
    entry_year: number | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends studentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type studentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_student_number?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    study_program?: boolean
    entry_year?: boolean
    attendances?: boolean | students$attendancesArgs<ExtArgs>
    certificate_requests?: boolean | students$certificate_requestsArgs<ExtArgs>
    enrollments?: boolean | students$enrollmentsArgs<ExtArgs>
    financial_bills?: boolean | students$financial_billsArgs<ExtArgs>
    research_proposals?: boolean | students$research_proposalsArgs<ExtArgs>
    student_profiles?: boolean | students$student_profilesArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_student_number?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    study_program?: boolean
    entry_year?: boolean
  }, ExtArgs["result"]["students"]>

  export type studentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_student_number?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    study_program?: boolean
    entry_year?: boolean
  }, ExtArgs["result"]["students"]>

  export type studentsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    platform_student_number?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    study_program?: boolean
    entry_year?: boolean
  }

  export type studentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "user_id" | "platform_student_number" | "name" | "status" | "created_at" | "updated_at" | "study_program" | "entry_year", ExtArgs["result"]["students"]>
  export type studentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | students$attendancesArgs<ExtArgs>
    certificate_requests?: boolean | students$certificate_requestsArgs<ExtArgs>
    enrollments?: boolean | students$enrollmentsArgs<ExtArgs>
    financial_bills?: boolean | students$financial_billsArgs<ExtArgs>
    research_proposals?: boolean | students$research_proposalsArgs<ExtArgs>
    student_profiles?: boolean | students$student_profilesArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type studentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $studentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students"
    objects: {
      attendances: Prisma.$attendancesPayload<ExtArgs>[]
      certificate_requests: Prisma.$certificate_requestsPayload<ExtArgs>[]
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
      financial_bills: Prisma.$financial_billsPayload<ExtArgs>[]
      research_proposals: Prisma.$research_proposalsPayload<ExtArgs>[]
      student_profiles: Prisma.$student_profilesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      user_id: string
      platform_student_number: string | null
      name: string
      status: string | null
      created_at: Date | null
      updated_at: Date | null
      study_program: string | null
      entry_year: number | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type studentsGetPayload<S extends boolean | null | undefined | studentsDefaultArgs> = $Result.GetResult<Prisma.$studentsPayload, S>

  type studentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface studentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students'], meta: { name: 'students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {studentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentsFindUniqueArgs>(args: SelectSubset<T, studentsFindUniqueArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentsFindFirstArgs>(args?: SelectSubset<T, studentsFindFirstArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentsFindManyArgs>(args?: SelectSubset<T, studentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {studentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends studentsCreateArgs>(args: SelectSubset<T, studentsCreateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentsCreateManyArgs>(args?: SelectSubset<T, studentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentsCreateManyAndReturnArgs>(args?: SelectSubset<T, studentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Students.
     * @param {studentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends studentsDeleteArgs>(args: SelectSubset<T, studentsDeleteArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {studentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentsUpdateArgs>(args: SelectSubset<T, studentsUpdateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentsDeleteManyArgs>(args?: SelectSubset<T, studentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentsUpdateManyArgs>(args: SelectSubset<T, studentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {studentsUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends studentsUpdateManyAndReturnArgs>(args: SelectSubset<T, studentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Students.
     * @param {studentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends studentsUpsertArgs>(args: SelectSubset<T, studentsUpsertArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentsCountArgs>(
      args?: Subset<T, studentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsGroupByArgs['orderBy'] }
        : { orderBy?: studentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students model
   */
  readonly fields: studentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends students$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, students$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificate_requests<T extends students$certificate_requestsArgs<ExtArgs> = {}>(args?: Subset<T, students$certificate_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificate_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends students$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, students$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financial_bills<T extends students$financial_billsArgs<ExtArgs> = {}>(args?: Subset<T, students$financial_billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financial_billsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    research_proposals<T extends students$research_proposalsArgs<ExtArgs> = {}>(args?: Subset<T, students$research_proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$research_proposalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_profiles<T extends students$student_profilesArgs<ExtArgs> = {}>(args?: Subset<T, students$student_profilesArgs<ExtArgs>>): Prisma__student_profilesClient<$Result.GetResult<Prisma.$student_profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students model
   */
  interface studentsFieldRefs {
    readonly id: FieldRef<"students", 'String'>
    readonly tenant_id: FieldRef<"students", 'String'>
    readonly user_id: FieldRef<"students", 'String'>
    readonly platform_student_number: FieldRef<"students", 'String'>
    readonly name: FieldRef<"students", 'String'>
    readonly status: FieldRef<"students", 'String'>
    readonly created_at: FieldRef<"students", 'DateTime'>
    readonly updated_at: FieldRef<"students", 'DateTime'>
    readonly study_program: FieldRef<"students", 'String'>
    readonly entry_year: FieldRef<"students", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * students findUnique
   */
  export type studentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findUniqueOrThrow
   */
  export type studentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findFirst
   */
  export type studentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findFirstOrThrow
   */
  export type studentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findMany
   */
  export type studentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students create
   */
  export type studentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students.
     */
    data: XOR<studentsCreateInput, studentsUncheckedCreateInput>
  }

  /**
   * students createMany
   */
  export type studentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students createManyAndReturn
   */
  export type studentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students update
   */
  export type studentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students.
     */
    data: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
    /**
     * Choose, which students to update.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students updateMany
   */
  export type studentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * students updateManyAndReturn
   */
  export type studentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * students upsert
   */
  export type studentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students to update in case it exists.
     */
    where: studentsWhereUniqueInput
    /**
     * In case the students found by the `where` argument doesn't exist, create a new students with this data.
     */
    create: XOR<studentsCreateInput, studentsUncheckedCreateInput>
    /**
     * In case the students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
  }

  /**
   * students delete
   */
  export type studentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter which students to delete.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students deleteMany
   */
  export type studentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * students.attendances
   */
  export type students$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendances
     */
    omit?: attendancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    where?: attendancesWhereInput
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    cursor?: attendancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * students.certificate_requests
   */
  export type students$certificate_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate_requests
     */
    select?: certificate_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate_requests
     */
    omit?: certificate_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificate_requestsInclude<ExtArgs> | null
    where?: certificate_requestsWhereInput
    orderBy?: certificate_requestsOrderByWithRelationInput | certificate_requestsOrderByWithRelationInput[]
    cursor?: certificate_requestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Certificate_requestsScalarFieldEnum | Certificate_requestsScalarFieldEnum[]
  }

  /**
   * students.enrollments
   */
  export type students$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * students.financial_bills
   */
  export type students$financial_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financial_bills
     */
    select?: financial_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financial_bills
     */
    omit?: financial_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financial_billsInclude<ExtArgs> | null
    where?: financial_billsWhereInput
    orderBy?: financial_billsOrderByWithRelationInput | financial_billsOrderByWithRelationInput[]
    cursor?: financial_billsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Financial_billsScalarFieldEnum | Financial_billsScalarFieldEnum[]
  }

  /**
   * students.research_proposals
   */
  export type students$research_proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the research_proposals
     */
    select?: research_proposalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the research_proposals
     */
    omit?: research_proposalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: research_proposalsInclude<ExtArgs> | null
    where?: research_proposalsWhereInput
    orderBy?: research_proposalsOrderByWithRelationInput | research_proposalsOrderByWithRelationInput[]
    cursor?: research_proposalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Research_proposalsScalarFieldEnum | Research_proposalsScalarFieldEnum[]
  }

  /**
   * students.student_profiles
   */
  export type students$student_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_profiles
     */
    select?: student_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_profiles
     */
    omit?: student_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_profilesInclude<ExtArgs> | null
    where?: student_profilesWhereInput
  }

  /**
   * students without action
   */
  export type studentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnnouncementsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    title: 'title',
    content: 'content',
    type: 'type',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type AnnouncementsScalarFieldEnum = (typeof AnnouncementsScalarFieldEnum)[keyof typeof AnnouncementsScalarFieldEnum]


  export const AttendancesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    class_id: 'class_id',
    student_id: 'student_id',
    meeting_number: 'meeting_number',
    status: 'status',
    created_at: 'created_at'
  };

  export type AttendancesScalarFieldEnum = (typeof AttendancesScalarFieldEnum)[keyof typeof AttendancesScalarFieldEnum]


  export const Certificate_requestsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    student_id: 'student_id',
    type: 'type',
    purpose: 'purpose',
    quantity: 'quantity',
    notes: 'notes',
    status: 'status',
    rejection_reason: 'rejection_reason',
    download_url: 'download_url',
    created_at: 'created_at'
  };

  export type Certificate_requestsScalarFieldEnum = (typeof Certificate_requestsScalarFieldEnum)[keyof typeof Certificate_requestsScalarFieldEnum]


  export const Class_schedulesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    class_id: 'class_id',
    day: 'day',
    start_time: 'start_time',
    end_time: 'end_time',
    room: 'room',
    type: 'type',
    created_at: 'created_at'
  };

  export type Class_schedulesScalarFieldEnum = (typeof Class_schedulesScalarFieldEnum)[keyof typeof Class_schedulesScalarFieldEnum]


  export const ClassesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    course_id: 'course_id',
    lecturer_id: 'lecturer_id',
    semester: 'semester',
    year: 'year',
    capacity: 'capacity',
    created_at: 'created_at'
  };

  export type ClassesScalarFieldEnum = (typeof ClassesScalarFieldEnum)[keyof typeof ClassesScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    code: 'code',
    name: 'name',
    credits: 'credits',
    created_at: 'created_at'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const EnrollmentsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    student_id: 'student_id',
    class_id: 'class_id',
    status: 'status',
    created_at: 'created_at'
  };

  export type EnrollmentsScalarFieldEnum = (typeof EnrollmentsScalarFieldEnum)[keyof typeof EnrollmentsScalarFieldEnum]


  export const ExamsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    class_id: 'class_id',
    type: 'type',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    room: 'room',
    created_at: 'created_at'
  };

  export type ExamsScalarFieldEnum = (typeof ExamsScalarFieldEnum)[keyof typeof ExamsScalarFieldEnum]


  export const Financial_billsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    student_id: 'student_id',
    title: 'title',
    amount: 'amount',
    is_paid: 'is_paid',
    due_date: 'due_date',
    created_at: 'created_at'
  };

  export type Financial_billsScalarFieldEnum = (typeof Financial_billsScalarFieldEnum)[keyof typeof Financial_billsScalarFieldEnum]


  export const GradesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    enrollment_id: 'enrollment_id',
    grade: 'grade',
    score: 'score',
    created_at: 'created_at'
  };

  export type GradesScalarFieldEnum = (typeof GradesScalarFieldEnum)[keyof typeof GradesScalarFieldEnum]


  export const LecturersScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    user_id: 'user_id',
    platform_lecturer_number: 'platform_lecturer_number',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LecturersScalarFieldEnum = (typeof LecturersScalarFieldEnum)[keyof typeof LecturersScalarFieldEnum]


  export const Research_proposalsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    student_id: 'student_id',
    title: 'title',
    type: 'type',
    description: 'description',
    supervisor_preferred: 'supervisor_preferred',
    status: 'status',
    created_at: 'created_at'
  };

  export type Research_proposalsScalarFieldEnum = (typeof Research_proposalsScalarFieldEnum)[keyof typeof Research_proposalsScalarFieldEnum]


  export const Student_profilesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    student_id: 'student_id',
    gender: 'gender',
    place_of_birth: 'place_of_birth',
    date_of_birth: 'date_of_birth',
    religion: 'religion',
    phone_1: 'phone_1',
    phone_2: 'phone_2',
    whatsapp: 'whatsapp',
    job_status: 'job_status',
    company_name: 'company_name',
    job_start_year: 'job_start_year',
    income_range: 'income_range',
    ktp_province: 'ktp_province',
    ktp_city: 'ktp_city',
    ktp_district: 'ktp_district',
    ktp_subdistrict: 'ktp_subdistrict',
    ktp_rt: 'ktp_rt',
    ktp_rw: 'ktp_rw',
    ktp_postal_code: 'ktp_postal_code',
    ktp_address: 'ktp_address',
    current_province: 'current_province',
    current_city: 'current_city',
    current_district: 'current_district',
    current_subdistrict: 'current_subdistrict',
    current_rt: 'current_rt',
    current_rw: 'current_rw',
    current_postal_code: 'current_postal_code',
    current_address: 'current_address',
    citizenship: 'citizenship',
    nik: 'nik',
    kk_number: 'kk_number',
    living_status: 'living_status',
    father_nik: 'father_nik',
    father_name: 'father_name',
    father_living_status: 'father_living_status',
    father_phone: 'father_phone',
    father_place_of_birth: 'father_place_of_birth',
    father_date_of_birth: 'father_date_of_birth',
    father_religion: 'father_religion',
    father_job: 'father_job',
    father_income_range: 'father_income_range',
    father_address: 'father_address',
    mother_nik: 'mother_nik',
    mother_name: 'mother_name',
    mother_living_status: 'mother_living_status',
    mother_phone: 'mother_phone',
    mother_place_of_birth: 'mother_place_of_birth',
    mother_date_of_birth: 'mother_date_of_birth',
    mother_religion: 'mother_religion',
    mother_job: 'mother_job',
    mother_income_range: 'mother_income_range',
    mother_address: 'mother_address',
    school_name: 'school_name',
    school_major: 'school_major',
    nisn: 'nisn',
    diploma_number: 'diploma_number',
    graduation_year: 'graduation_year',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Student_profilesScalarFieldEnum = (typeof Student_profilesScalarFieldEnum)[keyof typeof Student_profilesScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    user_id: 'user_id',
    platform_student_number: 'platform_student_number',
    name: 'name',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    study_program: 'study_program',
    entry_year: 'entry_year'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type announcementsWhereInput = {
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    id?: UuidFilter<"announcements"> | string
    tenant_id?: UuidFilter<"announcements"> | string
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    type?: StringNullableFilter<"announcements"> | string | null
    is_active?: BoolNullableFilter<"announcements"> | boolean | null
    created_at?: DateTimeNullableFilter<"announcements"> | Date | string | null
  }

  export type announcementsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type announcementsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    tenant_id?: UuidFilter<"announcements"> | string
    title?: StringFilter<"announcements"> | string
    content?: StringFilter<"announcements"> | string
    type?: StringNullableFilter<"announcements"> | string | null
    is_active?: BoolNullableFilter<"announcements"> | boolean | null
    created_at?: DateTimeNullableFilter<"announcements"> | Date | string | null
  }, "id">

  export type announcementsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: announcementsCountOrderByAggregateInput
    _max?: announcementsMaxOrderByAggregateInput
    _min?: announcementsMinOrderByAggregateInput
  }

  export type announcementsScalarWhereWithAggregatesInput = {
    AND?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    OR?: announcementsScalarWhereWithAggregatesInput[]
    NOT?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"announcements"> | string
    tenant_id?: UuidWithAggregatesFilter<"announcements"> | string
    title?: StringWithAggregatesFilter<"announcements"> | string
    content?: StringWithAggregatesFilter<"announcements"> | string
    type?: StringNullableWithAggregatesFilter<"announcements"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"announcements"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"announcements"> | Date | string | null
  }

  export type attendancesWhereInput = {
    AND?: attendancesWhereInput | attendancesWhereInput[]
    OR?: attendancesWhereInput[]
    NOT?: attendancesWhereInput | attendancesWhereInput[]
    id?: UuidFilter<"attendances"> | string
    tenant_id?: UuidFilter<"attendances"> | string
    class_id?: UuidFilter<"attendances"> | string
    student_id?: UuidFilter<"attendances"> | string
    meeting_number?: IntFilter<"attendances"> | number
    status?: StringNullableFilter<"attendances"> | string | null
    created_at?: DateTimeNullableFilter<"attendances"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type attendancesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    student_id?: SortOrder
    meeting_number?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    classes?: classesOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type attendancesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    class_id_student_id_meeting_number?: attendancesClass_idStudent_idMeeting_numberCompoundUniqueInput
    AND?: attendancesWhereInput | attendancesWhereInput[]
    OR?: attendancesWhereInput[]
    NOT?: attendancesWhereInput | attendancesWhereInput[]
    tenant_id?: UuidFilter<"attendances"> | string
    class_id?: UuidFilter<"attendances"> | string
    student_id?: UuidFilter<"attendances"> | string
    meeting_number?: IntFilter<"attendances"> | number
    status?: StringNullableFilter<"attendances"> | string | null
    created_at?: DateTimeNullableFilter<"attendances"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "id" | "class_id_student_id_meeting_number">

  export type attendancesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    student_id?: SortOrder
    meeting_number?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: attendancesCountOrderByAggregateInput
    _avg?: attendancesAvgOrderByAggregateInput
    _max?: attendancesMaxOrderByAggregateInput
    _min?: attendancesMinOrderByAggregateInput
    _sum?: attendancesSumOrderByAggregateInput
  }

  export type attendancesScalarWhereWithAggregatesInput = {
    AND?: attendancesScalarWhereWithAggregatesInput | attendancesScalarWhereWithAggregatesInput[]
    OR?: attendancesScalarWhereWithAggregatesInput[]
    NOT?: attendancesScalarWhereWithAggregatesInput | attendancesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"attendances"> | string
    tenant_id?: UuidWithAggregatesFilter<"attendances"> | string
    class_id?: UuidWithAggregatesFilter<"attendances"> | string
    student_id?: UuidWithAggregatesFilter<"attendances"> | string
    meeting_number?: IntWithAggregatesFilter<"attendances"> | number
    status?: StringNullableWithAggregatesFilter<"attendances"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"attendances"> | Date | string | null
  }

  export type certificate_requestsWhereInput = {
    AND?: certificate_requestsWhereInput | certificate_requestsWhereInput[]
    OR?: certificate_requestsWhereInput[]
    NOT?: certificate_requestsWhereInput | certificate_requestsWhereInput[]
    id?: UuidFilter<"certificate_requests"> | string
    tenant_id?: UuidFilter<"certificate_requests"> | string
    student_id?: UuidFilter<"certificate_requests"> | string
    type?: StringFilter<"certificate_requests"> | string
    purpose?: StringNullableFilter<"certificate_requests"> | string | null
    quantity?: IntNullableFilter<"certificate_requests"> | number | null
    notes?: StringNullableFilter<"certificate_requests"> | string | null
    status?: StringNullableFilter<"certificate_requests"> | string | null
    rejection_reason?: StringNullableFilter<"certificate_requests"> | string | null
    download_url?: StringNullableFilter<"certificate_requests"> | string | null
    created_at?: DateTimeNullableFilter<"certificate_requests"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type certificate_requestsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    type?: SortOrder
    purpose?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    rejection_reason?: SortOrderInput | SortOrder
    download_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type certificate_requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: certificate_requestsWhereInput | certificate_requestsWhereInput[]
    OR?: certificate_requestsWhereInput[]
    NOT?: certificate_requestsWhereInput | certificate_requestsWhereInput[]
    tenant_id?: UuidFilter<"certificate_requests"> | string
    student_id?: UuidFilter<"certificate_requests"> | string
    type?: StringFilter<"certificate_requests"> | string
    purpose?: StringNullableFilter<"certificate_requests"> | string | null
    quantity?: IntNullableFilter<"certificate_requests"> | number | null
    notes?: StringNullableFilter<"certificate_requests"> | string | null
    status?: StringNullableFilter<"certificate_requests"> | string | null
    rejection_reason?: StringNullableFilter<"certificate_requests"> | string | null
    download_url?: StringNullableFilter<"certificate_requests"> | string | null
    created_at?: DateTimeNullableFilter<"certificate_requests"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "id">

  export type certificate_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    type?: SortOrder
    purpose?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    rejection_reason?: SortOrderInput | SortOrder
    download_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: certificate_requestsCountOrderByAggregateInput
    _avg?: certificate_requestsAvgOrderByAggregateInput
    _max?: certificate_requestsMaxOrderByAggregateInput
    _min?: certificate_requestsMinOrderByAggregateInput
    _sum?: certificate_requestsSumOrderByAggregateInput
  }

  export type certificate_requestsScalarWhereWithAggregatesInput = {
    AND?: certificate_requestsScalarWhereWithAggregatesInput | certificate_requestsScalarWhereWithAggregatesInput[]
    OR?: certificate_requestsScalarWhereWithAggregatesInput[]
    NOT?: certificate_requestsScalarWhereWithAggregatesInput | certificate_requestsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"certificate_requests"> | string
    tenant_id?: UuidWithAggregatesFilter<"certificate_requests"> | string
    student_id?: UuidWithAggregatesFilter<"certificate_requests"> | string
    type?: StringWithAggregatesFilter<"certificate_requests"> | string
    purpose?: StringNullableWithAggregatesFilter<"certificate_requests"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"certificate_requests"> | number | null
    notes?: StringNullableWithAggregatesFilter<"certificate_requests"> | string | null
    status?: StringNullableWithAggregatesFilter<"certificate_requests"> | string | null
    rejection_reason?: StringNullableWithAggregatesFilter<"certificate_requests"> | string | null
    download_url?: StringNullableWithAggregatesFilter<"certificate_requests"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"certificate_requests"> | Date | string | null
  }

  export type class_schedulesWhereInput = {
    AND?: class_schedulesWhereInput | class_schedulesWhereInput[]
    OR?: class_schedulesWhereInput[]
    NOT?: class_schedulesWhereInput | class_schedulesWhereInput[]
    id?: UuidFilter<"class_schedules"> | string
    tenant_id?: UuidFilter<"class_schedules"> | string
    class_id?: UuidFilter<"class_schedules"> | string
    day?: StringFilter<"class_schedules"> | string
    start_time?: DateTimeFilter<"class_schedules"> | Date | string
    end_time?: DateTimeFilter<"class_schedules"> | Date | string
    room?: StringNullableFilter<"class_schedules"> | string | null
    type?: StringNullableFilter<"class_schedules"> | string | null
    created_at?: DateTimeNullableFilter<"class_schedules"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
  }

  export type class_schedulesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    classes?: classesOrderByWithRelationInput
  }

  export type class_schedulesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: class_schedulesWhereInput | class_schedulesWhereInput[]
    OR?: class_schedulesWhereInput[]
    NOT?: class_schedulesWhereInput | class_schedulesWhereInput[]
    tenant_id?: UuidFilter<"class_schedules"> | string
    class_id?: UuidFilter<"class_schedules"> | string
    day?: StringFilter<"class_schedules"> | string
    start_time?: DateTimeFilter<"class_schedules"> | Date | string
    end_time?: DateTimeFilter<"class_schedules"> | Date | string
    room?: StringNullableFilter<"class_schedules"> | string | null
    type?: StringNullableFilter<"class_schedules"> | string | null
    created_at?: DateTimeNullableFilter<"class_schedules"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
  }, "id">

  export type class_schedulesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: class_schedulesCountOrderByAggregateInput
    _max?: class_schedulesMaxOrderByAggregateInput
    _min?: class_schedulesMinOrderByAggregateInput
  }

  export type class_schedulesScalarWhereWithAggregatesInput = {
    AND?: class_schedulesScalarWhereWithAggregatesInput | class_schedulesScalarWhereWithAggregatesInput[]
    OR?: class_schedulesScalarWhereWithAggregatesInput[]
    NOT?: class_schedulesScalarWhereWithAggregatesInput | class_schedulesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"class_schedules"> | string
    tenant_id?: UuidWithAggregatesFilter<"class_schedules"> | string
    class_id?: UuidWithAggregatesFilter<"class_schedules"> | string
    day?: StringWithAggregatesFilter<"class_schedules"> | string
    start_time?: DateTimeWithAggregatesFilter<"class_schedules"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"class_schedules"> | Date | string
    room?: StringNullableWithAggregatesFilter<"class_schedules"> | string | null
    type?: StringNullableWithAggregatesFilter<"class_schedules"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"class_schedules"> | Date | string | null
  }

  export type classesWhereInput = {
    AND?: classesWhereInput | classesWhereInput[]
    OR?: classesWhereInput[]
    NOT?: classesWhereInput | classesWhereInput[]
    id?: UuidFilter<"classes"> | string
    tenant_id?: UuidFilter<"classes"> | string
    course_id?: UuidFilter<"classes"> | string
    lecturer_id?: UuidNullableFilter<"classes"> | string | null
    semester?: StringFilter<"classes"> | string
    year?: IntFilter<"classes"> | number
    capacity?: IntNullableFilter<"classes"> | number | null
    created_at?: DateTimeNullableFilter<"classes"> | Date | string | null
    attendances?: AttendancesListRelationFilter
    class_schedules?: Class_schedulesListRelationFilter
    courses?: XOR<CoursesScalarRelationFilter, coursesWhereInput>
    lecturers?: XOR<LecturersNullableScalarRelationFilter, lecturersWhereInput> | null
    enrollments?: EnrollmentsListRelationFilter
    exams?: ExamsListRelationFilter
  }

  export type classesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    course_id?: SortOrder
    lecturer_id?: SortOrderInput | SortOrder
    semester?: SortOrder
    year?: SortOrder
    capacity?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    attendances?: attendancesOrderByRelationAggregateInput
    class_schedules?: class_schedulesOrderByRelationAggregateInput
    courses?: coursesOrderByWithRelationInput
    lecturers?: lecturersOrderByWithRelationInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
    exams?: examsOrderByRelationAggregateInput
  }

  export type classesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_course_id_semester_year?: classesTenant_idCourse_idSemesterYearCompoundUniqueInput
    AND?: classesWhereInput | classesWhereInput[]
    OR?: classesWhereInput[]
    NOT?: classesWhereInput | classesWhereInput[]
    tenant_id?: UuidFilter<"classes"> | string
    course_id?: UuidFilter<"classes"> | string
    lecturer_id?: UuidNullableFilter<"classes"> | string | null
    semester?: StringFilter<"classes"> | string
    year?: IntFilter<"classes"> | number
    capacity?: IntNullableFilter<"classes"> | number | null
    created_at?: DateTimeNullableFilter<"classes"> | Date | string | null
    attendances?: AttendancesListRelationFilter
    class_schedules?: Class_schedulesListRelationFilter
    courses?: XOR<CoursesScalarRelationFilter, coursesWhereInput>
    lecturers?: XOR<LecturersNullableScalarRelationFilter, lecturersWhereInput> | null
    enrollments?: EnrollmentsListRelationFilter
    exams?: ExamsListRelationFilter
  }, "id" | "tenant_id_course_id_semester_year">

  export type classesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    course_id?: SortOrder
    lecturer_id?: SortOrderInput | SortOrder
    semester?: SortOrder
    year?: SortOrder
    capacity?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: classesCountOrderByAggregateInput
    _avg?: classesAvgOrderByAggregateInput
    _max?: classesMaxOrderByAggregateInput
    _min?: classesMinOrderByAggregateInput
    _sum?: classesSumOrderByAggregateInput
  }

  export type classesScalarWhereWithAggregatesInput = {
    AND?: classesScalarWhereWithAggregatesInput | classesScalarWhereWithAggregatesInput[]
    OR?: classesScalarWhereWithAggregatesInput[]
    NOT?: classesScalarWhereWithAggregatesInput | classesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"classes"> | string
    tenant_id?: UuidWithAggregatesFilter<"classes"> | string
    course_id?: UuidWithAggregatesFilter<"classes"> | string
    lecturer_id?: UuidNullableWithAggregatesFilter<"classes"> | string | null
    semester?: StringWithAggregatesFilter<"classes"> | string
    year?: IntWithAggregatesFilter<"classes"> | number
    capacity?: IntNullableWithAggregatesFilter<"classes"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"classes"> | Date | string | null
  }

  export type coursesWhereInput = {
    AND?: coursesWhereInput | coursesWhereInput[]
    OR?: coursesWhereInput[]
    NOT?: coursesWhereInput | coursesWhereInput[]
    id?: UuidFilter<"courses"> | string
    tenant_id?: UuidFilter<"courses"> | string
    code?: StringFilter<"courses"> | string
    name?: StringFilter<"courses"> | string
    credits?: IntFilter<"courses"> | number
    created_at?: DateTimeNullableFilter<"courses"> | Date | string | null
    classes?: ClassesListRelationFilter
  }

  export type coursesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    created_at?: SortOrderInput | SortOrder
    classes?: classesOrderByRelationAggregateInput
  }

  export type coursesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_code?: coursesTenant_idCodeCompoundUniqueInput
    AND?: coursesWhereInput | coursesWhereInput[]
    OR?: coursesWhereInput[]
    NOT?: coursesWhereInput | coursesWhereInput[]
    tenant_id?: UuidFilter<"courses"> | string
    code?: StringFilter<"courses"> | string
    name?: StringFilter<"courses"> | string
    credits?: IntFilter<"courses"> | number
    created_at?: DateTimeNullableFilter<"courses"> | Date | string | null
    classes?: ClassesListRelationFilter
  }, "id" | "tenant_id_code">

  export type coursesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: coursesCountOrderByAggregateInput
    _avg?: coursesAvgOrderByAggregateInput
    _max?: coursesMaxOrderByAggregateInput
    _min?: coursesMinOrderByAggregateInput
    _sum?: coursesSumOrderByAggregateInput
  }

  export type coursesScalarWhereWithAggregatesInput = {
    AND?: coursesScalarWhereWithAggregatesInput | coursesScalarWhereWithAggregatesInput[]
    OR?: coursesScalarWhereWithAggregatesInput[]
    NOT?: coursesScalarWhereWithAggregatesInput | coursesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"courses"> | string
    tenant_id?: UuidWithAggregatesFilter<"courses"> | string
    code?: StringWithAggregatesFilter<"courses"> | string
    name?: StringWithAggregatesFilter<"courses"> | string
    credits?: IntWithAggregatesFilter<"courses"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"courses"> | Date | string | null
  }

  export type enrollmentsWhereInput = {
    AND?: enrollmentsWhereInput | enrollmentsWhereInput[]
    OR?: enrollmentsWhereInput[]
    NOT?: enrollmentsWhereInput | enrollmentsWhereInput[]
    id?: UuidFilter<"enrollments"> | string
    tenant_id?: UuidFilter<"enrollments"> | string
    student_id?: UuidFilter<"enrollments"> | string
    class_id?: UuidFilter<"enrollments"> | string
    status?: StringNullableFilter<"enrollments"> | string | null
    created_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    grades?: GradesListRelationFilter
  }

  export type enrollmentsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    classes?: classesOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
    grades?: gradesOrderByRelationAggregateInput
  }

  export type enrollmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    student_id_class_id?: enrollmentsStudent_idClass_idCompoundUniqueInput
    AND?: enrollmentsWhereInput | enrollmentsWhereInput[]
    OR?: enrollmentsWhereInput[]
    NOT?: enrollmentsWhereInput | enrollmentsWhereInput[]
    tenant_id?: UuidFilter<"enrollments"> | string
    student_id?: UuidFilter<"enrollments"> | string
    class_id?: UuidFilter<"enrollments"> | string
    status?: StringNullableFilter<"enrollments"> | string | null
    created_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    grades?: GradesListRelationFilter
  }, "id" | "student_id_class_id">

  export type enrollmentsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: enrollmentsCountOrderByAggregateInput
    _max?: enrollmentsMaxOrderByAggregateInput
    _min?: enrollmentsMinOrderByAggregateInput
  }

  export type enrollmentsScalarWhereWithAggregatesInput = {
    AND?: enrollmentsScalarWhereWithAggregatesInput | enrollmentsScalarWhereWithAggregatesInput[]
    OR?: enrollmentsScalarWhereWithAggregatesInput[]
    NOT?: enrollmentsScalarWhereWithAggregatesInput | enrollmentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"enrollments"> | string
    tenant_id?: UuidWithAggregatesFilter<"enrollments"> | string
    student_id?: UuidWithAggregatesFilter<"enrollments"> | string
    class_id?: UuidWithAggregatesFilter<"enrollments"> | string
    status?: StringNullableWithAggregatesFilter<"enrollments"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
  }

  export type examsWhereInput = {
    AND?: examsWhereInput | examsWhereInput[]
    OR?: examsWhereInput[]
    NOT?: examsWhereInput | examsWhereInput[]
    id?: UuidFilter<"exams"> | string
    tenant_id?: UuidFilter<"exams"> | string
    class_id?: UuidFilter<"exams"> | string
    type?: StringFilter<"exams"> | string
    date?: DateTimeFilter<"exams"> | Date | string
    start_time?: DateTimeFilter<"exams"> | Date | string
    end_time?: DateTimeFilter<"exams"> | Date | string
    room?: StringNullableFilter<"exams"> | string | null
    created_at?: DateTimeNullableFilter<"exams"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
  }

  export type examsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    classes?: classesOrderByWithRelationInput
  }

  export type examsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: examsWhereInput | examsWhereInput[]
    OR?: examsWhereInput[]
    NOT?: examsWhereInput | examsWhereInput[]
    tenant_id?: UuidFilter<"exams"> | string
    class_id?: UuidFilter<"exams"> | string
    type?: StringFilter<"exams"> | string
    date?: DateTimeFilter<"exams"> | Date | string
    start_time?: DateTimeFilter<"exams"> | Date | string
    end_time?: DateTimeFilter<"exams"> | Date | string
    room?: StringNullableFilter<"exams"> | string | null
    created_at?: DateTimeNullableFilter<"exams"> | Date | string | null
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
  }, "id">

  export type examsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: examsCountOrderByAggregateInput
    _max?: examsMaxOrderByAggregateInput
    _min?: examsMinOrderByAggregateInput
  }

  export type examsScalarWhereWithAggregatesInput = {
    AND?: examsScalarWhereWithAggregatesInput | examsScalarWhereWithAggregatesInput[]
    OR?: examsScalarWhereWithAggregatesInput[]
    NOT?: examsScalarWhereWithAggregatesInput | examsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"exams"> | string
    tenant_id?: UuidWithAggregatesFilter<"exams"> | string
    class_id?: UuidWithAggregatesFilter<"exams"> | string
    type?: StringWithAggregatesFilter<"exams"> | string
    date?: DateTimeWithAggregatesFilter<"exams"> | Date | string
    start_time?: DateTimeWithAggregatesFilter<"exams"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"exams"> | Date | string
    room?: StringNullableWithAggregatesFilter<"exams"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"exams"> | Date | string | null
  }

  export type financial_billsWhereInput = {
    AND?: financial_billsWhereInput | financial_billsWhereInput[]
    OR?: financial_billsWhereInput[]
    NOT?: financial_billsWhereInput | financial_billsWhereInput[]
    id?: UuidFilter<"financial_bills"> | string
    tenant_id?: UuidFilter<"financial_bills"> | string
    student_id?: UuidFilter<"financial_bills"> | string
    title?: StringFilter<"financial_bills"> | string
    amount?: DecimalFilter<"financial_bills"> | Decimal | DecimalJsLike | number | string
    is_paid?: BoolNullableFilter<"financial_bills"> | boolean | null
    due_date?: DateTimeNullableFilter<"financial_bills"> | Date | string | null
    created_at?: DateTimeNullableFilter<"financial_bills"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type financial_billsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    is_paid?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type financial_billsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: financial_billsWhereInput | financial_billsWhereInput[]
    OR?: financial_billsWhereInput[]
    NOT?: financial_billsWhereInput | financial_billsWhereInput[]
    tenant_id?: UuidFilter<"financial_bills"> | string
    student_id?: UuidFilter<"financial_bills"> | string
    title?: StringFilter<"financial_bills"> | string
    amount?: DecimalFilter<"financial_bills"> | Decimal | DecimalJsLike | number | string
    is_paid?: BoolNullableFilter<"financial_bills"> | boolean | null
    due_date?: DateTimeNullableFilter<"financial_bills"> | Date | string | null
    created_at?: DateTimeNullableFilter<"financial_bills"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "id">

  export type financial_billsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    is_paid?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: financial_billsCountOrderByAggregateInput
    _avg?: financial_billsAvgOrderByAggregateInput
    _max?: financial_billsMaxOrderByAggregateInput
    _min?: financial_billsMinOrderByAggregateInput
    _sum?: financial_billsSumOrderByAggregateInput
  }

  export type financial_billsScalarWhereWithAggregatesInput = {
    AND?: financial_billsScalarWhereWithAggregatesInput | financial_billsScalarWhereWithAggregatesInput[]
    OR?: financial_billsScalarWhereWithAggregatesInput[]
    NOT?: financial_billsScalarWhereWithAggregatesInput | financial_billsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"financial_bills"> | string
    tenant_id?: UuidWithAggregatesFilter<"financial_bills"> | string
    student_id?: UuidWithAggregatesFilter<"financial_bills"> | string
    title?: StringWithAggregatesFilter<"financial_bills"> | string
    amount?: DecimalWithAggregatesFilter<"financial_bills"> | Decimal | DecimalJsLike | number | string
    is_paid?: BoolNullableWithAggregatesFilter<"financial_bills"> | boolean | null
    due_date?: DateTimeNullableWithAggregatesFilter<"financial_bills"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"financial_bills"> | Date | string | null
  }

  export type gradesWhereInput = {
    AND?: gradesWhereInput | gradesWhereInput[]
    OR?: gradesWhereInput[]
    NOT?: gradesWhereInput | gradesWhereInput[]
    id?: UuidFilter<"grades"> | string
    tenant_id?: UuidFilter<"grades"> | string
    enrollment_id?: UuidFilter<"grades"> | string
    grade?: StringNullableFilter<"grades"> | string | null
    score?: FloatNullableFilter<"grades"> | number | null
    created_at?: DateTimeNullableFilter<"grades"> | Date | string | null
    enrollments?: XOR<EnrollmentsScalarRelationFilter, enrollmentsWhereInput>
  }

  export type gradesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    enrollment_id?: SortOrder
    grade?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    enrollments?: enrollmentsOrderByWithRelationInput
  }

  export type gradesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: gradesWhereInput | gradesWhereInput[]
    OR?: gradesWhereInput[]
    NOT?: gradesWhereInput | gradesWhereInput[]
    tenant_id?: UuidFilter<"grades"> | string
    enrollment_id?: UuidFilter<"grades"> | string
    grade?: StringNullableFilter<"grades"> | string | null
    score?: FloatNullableFilter<"grades"> | number | null
    created_at?: DateTimeNullableFilter<"grades"> | Date | string | null
    enrollments?: XOR<EnrollmentsScalarRelationFilter, enrollmentsWhereInput>
  }, "id">

  export type gradesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    enrollment_id?: SortOrder
    grade?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: gradesCountOrderByAggregateInput
    _avg?: gradesAvgOrderByAggregateInput
    _max?: gradesMaxOrderByAggregateInput
    _min?: gradesMinOrderByAggregateInput
    _sum?: gradesSumOrderByAggregateInput
  }

  export type gradesScalarWhereWithAggregatesInput = {
    AND?: gradesScalarWhereWithAggregatesInput | gradesScalarWhereWithAggregatesInput[]
    OR?: gradesScalarWhereWithAggregatesInput[]
    NOT?: gradesScalarWhereWithAggregatesInput | gradesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"grades"> | string
    tenant_id?: UuidWithAggregatesFilter<"grades"> | string
    enrollment_id?: UuidWithAggregatesFilter<"grades"> | string
    grade?: StringNullableWithAggregatesFilter<"grades"> | string | null
    score?: FloatNullableWithAggregatesFilter<"grades"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"grades"> | Date | string | null
  }

  export type lecturersWhereInput = {
    AND?: lecturersWhereInput | lecturersWhereInput[]
    OR?: lecturersWhereInput[]
    NOT?: lecturersWhereInput | lecturersWhereInput[]
    id?: UuidFilter<"lecturers"> | string
    tenant_id?: UuidFilter<"lecturers"> | string
    user_id?: UuidFilter<"lecturers"> | string
    platform_lecturer_number?: StringNullableFilter<"lecturers"> | string | null
    name?: StringFilter<"lecturers"> | string
    created_at?: DateTimeNullableFilter<"lecturers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"lecturers"> | Date | string | null
    classes?: ClassesListRelationFilter
  }

  export type lecturersOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_lecturer_number?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    classes?: classesOrderByRelationAggregateInput
  }

  export type lecturersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_user_id?: lecturersTenant_idUser_idCompoundUniqueInput
    AND?: lecturersWhereInput | lecturersWhereInput[]
    OR?: lecturersWhereInput[]
    NOT?: lecturersWhereInput | lecturersWhereInput[]
    tenant_id?: UuidFilter<"lecturers"> | string
    user_id?: UuidFilter<"lecturers"> | string
    platform_lecturer_number?: StringNullableFilter<"lecturers"> | string | null
    name?: StringFilter<"lecturers"> | string
    created_at?: DateTimeNullableFilter<"lecturers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"lecturers"> | Date | string | null
    classes?: ClassesListRelationFilter
  }, "id" | "tenant_id_user_id">

  export type lecturersOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_lecturer_number?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: lecturersCountOrderByAggregateInput
    _max?: lecturersMaxOrderByAggregateInput
    _min?: lecturersMinOrderByAggregateInput
  }

  export type lecturersScalarWhereWithAggregatesInput = {
    AND?: lecturersScalarWhereWithAggregatesInput | lecturersScalarWhereWithAggregatesInput[]
    OR?: lecturersScalarWhereWithAggregatesInput[]
    NOT?: lecturersScalarWhereWithAggregatesInput | lecturersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"lecturers"> | string
    tenant_id?: UuidWithAggregatesFilter<"lecturers"> | string
    user_id?: UuidWithAggregatesFilter<"lecturers"> | string
    platform_lecturer_number?: StringNullableWithAggregatesFilter<"lecturers"> | string | null
    name?: StringWithAggregatesFilter<"lecturers"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"lecturers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"lecturers"> | Date | string | null
  }

  export type research_proposalsWhereInput = {
    AND?: research_proposalsWhereInput | research_proposalsWhereInput[]
    OR?: research_proposalsWhereInput[]
    NOT?: research_proposalsWhereInput | research_proposalsWhereInput[]
    id?: UuidFilter<"research_proposals"> | string
    tenant_id?: UuidFilter<"research_proposals"> | string
    student_id?: UuidFilter<"research_proposals"> | string
    title?: StringFilter<"research_proposals"> | string
    type?: StringFilter<"research_proposals"> | string
    description?: StringNullableFilter<"research_proposals"> | string | null
    supervisor_preferred?: StringNullableFilter<"research_proposals"> | string | null
    status?: StringNullableFilter<"research_proposals"> | string | null
    created_at?: DateTimeNullableFilter<"research_proposals"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type research_proposalsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    supervisor_preferred?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type research_proposalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: research_proposalsWhereInput | research_proposalsWhereInput[]
    OR?: research_proposalsWhereInput[]
    NOT?: research_proposalsWhereInput | research_proposalsWhereInput[]
    tenant_id?: UuidFilter<"research_proposals"> | string
    student_id?: UuidFilter<"research_proposals"> | string
    title?: StringFilter<"research_proposals"> | string
    type?: StringFilter<"research_proposals"> | string
    description?: StringNullableFilter<"research_proposals"> | string | null
    supervisor_preferred?: StringNullableFilter<"research_proposals"> | string | null
    status?: StringNullableFilter<"research_proposals"> | string | null
    created_at?: DateTimeNullableFilter<"research_proposals"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "id">

  export type research_proposalsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    supervisor_preferred?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: research_proposalsCountOrderByAggregateInput
    _max?: research_proposalsMaxOrderByAggregateInput
    _min?: research_proposalsMinOrderByAggregateInput
  }

  export type research_proposalsScalarWhereWithAggregatesInput = {
    AND?: research_proposalsScalarWhereWithAggregatesInput | research_proposalsScalarWhereWithAggregatesInput[]
    OR?: research_proposalsScalarWhereWithAggregatesInput[]
    NOT?: research_proposalsScalarWhereWithAggregatesInput | research_proposalsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"research_proposals"> | string
    tenant_id?: UuidWithAggregatesFilter<"research_proposals"> | string
    student_id?: UuidWithAggregatesFilter<"research_proposals"> | string
    title?: StringWithAggregatesFilter<"research_proposals"> | string
    type?: StringWithAggregatesFilter<"research_proposals"> | string
    description?: StringNullableWithAggregatesFilter<"research_proposals"> | string | null
    supervisor_preferred?: StringNullableWithAggregatesFilter<"research_proposals"> | string | null
    status?: StringNullableWithAggregatesFilter<"research_proposals"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"research_proposals"> | Date | string | null
  }

  export type student_profilesWhereInput = {
    AND?: student_profilesWhereInput | student_profilesWhereInput[]
    OR?: student_profilesWhereInput[]
    NOT?: student_profilesWhereInput | student_profilesWhereInput[]
    id?: UuidFilter<"student_profiles"> | string
    tenant_id?: UuidFilter<"student_profiles"> | string
    student_id?: UuidFilter<"student_profiles"> | string
    gender?: StringNullableFilter<"student_profiles"> | string | null
    place_of_birth?: StringNullableFilter<"student_profiles"> | string | null
    date_of_birth?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    religion?: StringNullableFilter<"student_profiles"> | string | null
    phone_1?: StringNullableFilter<"student_profiles"> | string | null
    phone_2?: StringNullableFilter<"student_profiles"> | string | null
    whatsapp?: StringNullableFilter<"student_profiles"> | string | null
    job_status?: StringNullableFilter<"student_profiles"> | string | null
    company_name?: StringNullableFilter<"student_profiles"> | string | null
    job_start_year?: IntNullableFilter<"student_profiles"> | number | null
    income_range?: StringNullableFilter<"student_profiles"> | string | null
    ktp_province?: StringNullableFilter<"student_profiles"> | string | null
    ktp_city?: StringNullableFilter<"student_profiles"> | string | null
    ktp_district?: StringNullableFilter<"student_profiles"> | string | null
    ktp_subdistrict?: StringNullableFilter<"student_profiles"> | string | null
    ktp_rt?: StringNullableFilter<"student_profiles"> | string | null
    ktp_rw?: StringNullableFilter<"student_profiles"> | string | null
    ktp_postal_code?: StringNullableFilter<"student_profiles"> | string | null
    ktp_address?: StringNullableFilter<"student_profiles"> | string | null
    current_province?: StringNullableFilter<"student_profiles"> | string | null
    current_city?: StringNullableFilter<"student_profiles"> | string | null
    current_district?: StringNullableFilter<"student_profiles"> | string | null
    current_subdistrict?: StringNullableFilter<"student_profiles"> | string | null
    current_rt?: StringNullableFilter<"student_profiles"> | string | null
    current_rw?: StringNullableFilter<"student_profiles"> | string | null
    current_postal_code?: StringNullableFilter<"student_profiles"> | string | null
    current_address?: StringNullableFilter<"student_profiles"> | string | null
    citizenship?: StringNullableFilter<"student_profiles"> | string | null
    nik?: StringNullableFilter<"student_profiles"> | string | null
    kk_number?: StringNullableFilter<"student_profiles"> | string | null
    living_status?: StringNullableFilter<"student_profiles"> | string | null
    father_nik?: StringNullableFilter<"student_profiles"> | string | null
    father_name?: StringNullableFilter<"student_profiles"> | string | null
    father_living_status?: StringNullableFilter<"student_profiles"> | string | null
    father_phone?: StringNullableFilter<"student_profiles"> | string | null
    father_place_of_birth?: StringNullableFilter<"student_profiles"> | string | null
    father_date_of_birth?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    father_religion?: StringNullableFilter<"student_profiles"> | string | null
    father_job?: StringNullableFilter<"student_profiles"> | string | null
    father_income_range?: StringNullableFilter<"student_profiles"> | string | null
    father_address?: StringNullableFilter<"student_profiles"> | string | null
    mother_nik?: StringNullableFilter<"student_profiles"> | string | null
    mother_name?: StringNullableFilter<"student_profiles"> | string | null
    mother_living_status?: StringNullableFilter<"student_profiles"> | string | null
    mother_phone?: StringNullableFilter<"student_profiles"> | string | null
    mother_place_of_birth?: StringNullableFilter<"student_profiles"> | string | null
    mother_date_of_birth?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    mother_religion?: StringNullableFilter<"student_profiles"> | string | null
    mother_job?: StringNullableFilter<"student_profiles"> | string | null
    mother_income_range?: StringNullableFilter<"student_profiles"> | string | null
    mother_address?: StringNullableFilter<"student_profiles"> | string | null
    school_name?: StringNullableFilter<"student_profiles"> | string | null
    school_major?: StringNullableFilter<"student_profiles"> | string | null
    nisn?: StringNullableFilter<"student_profiles"> | string | null
    diploma_number?: StringNullableFilter<"student_profiles"> | string | null
    graduation_year?: IntNullableFilter<"student_profiles"> | number | null
    created_at?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type student_profilesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    gender?: SortOrderInput | SortOrder
    place_of_birth?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    phone_1?: SortOrderInput | SortOrder
    phone_2?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    job_status?: SortOrderInput | SortOrder
    company_name?: SortOrderInput | SortOrder
    job_start_year?: SortOrderInput | SortOrder
    income_range?: SortOrderInput | SortOrder
    ktp_province?: SortOrderInput | SortOrder
    ktp_city?: SortOrderInput | SortOrder
    ktp_district?: SortOrderInput | SortOrder
    ktp_subdistrict?: SortOrderInput | SortOrder
    ktp_rt?: SortOrderInput | SortOrder
    ktp_rw?: SortOrderInput | SortOrder
    ktp_postal_code?: SortOrderInput | SortOrder
    ktp_address?: SortOrderInput | SortOrder
    current_province?: SortOrderInput | SortOrder
    current_city?: SortOrderInput | SortOrder
    current_district?: SortOrderInput | SortOrder
    current_subdistrict?: SortOrderInput | SortOrder
    current_rt?: SortOrderInput | SortOrder
    current_rw?: SortOrderInput | SortOrder
    current_postal_code?: SortOrderInput | SortOrder
    current_address?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    nik?: SortOrderInput | SortOrder
    kk_number?: SortOrderInput | SortOrder
    living_status?: SortOrderInput | SortOrder
    father_nik?: SortOrderInput | SortOrder
    father_name?: SortOrderInput | SortOrder
    father_living_status?: SortOrderInput | SortOrder
    father_phone?: SortOrderInput | SortOrder
    father_place_of_birth?: SortOrderInput | SortOrder
    father_date_of_birth?: SortOrderInput | SortOrder
    father_religion?: SortOrderInput | SortOrder
    father_job?: SortOrderInput | SortOrder
    father_income_range?: SortOrderInput | SortOrder
    father_address?: SortOrderInput | SortOrder
    mother_nik?: SortOrderInput | SortOrder
    mother_name?: SortOrderInput | SortOrder
    mother_living_status?: SortOrderInput | SortOrder
    mother_phone?: SortOrderInput | SortOrder
    mother_place_of_birth?: SortOrderInput | SortOrder
    mother_date_of_birth?: SortOrderInput | SortOrder
    mother_religion?: SortOrderInput | SortOrder
    mother_job?: SortOrderInput | SortOrder
    mother_income_range?: SortOrderInput | SortOrder
    mother_address?: SortOrderInput | SortOrder
    school_name?: SortOrderInput | SortOrder
    school_major?: SortOrderInput | SortOrder
    nisn?: SortOrderInput | SortOrder
    diploma_number?: SortOrderInput | SortOrder
    graduation_year?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type student_profilesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    student_id?: string
    AND?: student_profilesWhereInput | student_profilesWhereInput[]
    OR?: student_profilesWhereInput[]
    NOT?: student_profilesWhereInput | student_profilesWhereInput[]
    tenant_id?: UuidFilter<"student_profiles"> | string
    gender?: StringNullableFilter<"student_profiles"> | string | null
    place_of_birth?: StringNullableFilter<"student_profiles"> | string | null
    date_of_birth?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    religion?: StringNullableFilter<"student_profiles"> | string | null
    phone_1?: StringNullableFilter<"student_profiles"> | string | null
    phone_2?: StringNullableFilter<"student_profiles"> | string | null
    whatsapp?: StringNullableFilter<"student_profiles"> | string | null
    job_status?: StringNullableFilter<"student_profiles"> | string | null
    company_name?: StringNullableFilter<"student_profiles"> | string | null
    job_start_year?: IntNullableFilter<"student_profiles"> | number | null
    income_range?: StringNullableFilter<"student_profiles"> | string | null
    ktp_province?: StringNullableFilter<"student_profiles"> | string | null
    ktp_city?: StringNullableFilter<"student_profiles"> | string | null
    ktp_district?: StringNullableFilter<"student_profiles"> | string | null
    ktp_subdistrict?: StringNullableFilter<"student_profiles"> | string | null
    ktp_rt?: StringNullableFilter<"student_profiles"> | string | null
    ktp_rw?: StringNullableFilter<"student_profiles"> | string | null
    ktp_postal_code?: StringNullableFilter<"student_profiles"> | string | null
    ktp_address?: StringNullableFilter<"student_profiles"> | string | null
    current_province?: StringNullableFilter<"student_profiles"> | string | null
    current_city?: StringNullableFilter<"student_profiles"> | string | null
    current_district?: StringNullableFilter<"student_profiles"> | string | null
    current_subdistrict?: StringNullableFilter<"student_profiles"> | string | null
    current_rt?: StringNullableFilter<"student_profiles"> | string | null
    current_rw?: StringNullableFilter<"student_profiles"> | string | null
    current_postal_code?: StringNullableFilter<"student_profiles"> | string | null
    current_address?: StringNullableFilter<"student_profiles"> | string | null
    citizenship?: StringNullableFilter<"student_profiles"> | string | null
    nik?: StringNullableFilter<"student_profiles"> | string | null
    kk_number?: StringNullableFilter<"student_profiles"> | string | null
    living_status?: StringNullableFilter<"student_profiles"> | string | null
    father_nik?: StringNullableFilter<"student_profiles"> | string | null
    father_name?: StringNullableFilter<"student_profiles"> | string | null
    father_living_status?: StringNullableFilter<"student_profiles"> | string | null
    father_phone?: StringNullableFilter<"student_profiles"> | string | null
    father_place_of_birth?: StringNullableFilter<"student_profiles"> | string | null
    father_date_of_birth?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    father_religion?: StringNullableFilter<"student_profiles"> | string | null
    father_job?: StringNullableFilter<"student_profiles"> | string | null
    father_income_range?: StringNullableFilter<"student_profiles"> | string | null
    father_address?: StringNullableFilter<"student_profiles"> | string | null
    mother_nik?: StringNullableFilter<"student_profiles"> | string | null
    mother_name?: StringNullableFilter<"student_profiles"> | string | null
    mother_living_status?: StringNullableFilter<"student_profiles"> | string | null
    mother_phone?: StringNullableFilter<"student_profiles"> | string | null
    mother_place_of_birth?: StringNullableFilter<"student_profiles"> | string | null
    mother_date_of_birth?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    mother_religion?: StringNullableFilter<"student_profiles"> | string | null
    mother_job?: StringNullableFilter<"student_profiles"> | string | null
    mother_income_range?: StringNullableFilter<"student_profiles"> | string | null
    mother_address?: StringNullableFilter<"student_profiles"> | string | null
    school_name?: StringNullableFilter<"student_profiles"> | string | null
    school_major?: StringNullableFilter<"student_profiles"> | string | null
    nisn?: StringNullableFilter<"student_profiles"> | string | null
    diploma_number?: StringNullableFilter<"student_profiles"> | string | null
    graduation_year?: IntNullableFilter<"student_profiles"> | number | null
    created_at?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"student_profiles"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "id" | "student_id">

  export type student_profilesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    gender?: SortOrderInput | SortOrder
    place_of_birth?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    phone_1?: SortOrderInput | SortOrder
    phone_2?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    job_status?: SortOrderInput | SortOrder
    company_name?: SortOrderInput | SortOrder
    job_start_year?: SortOrderInput | SortOrder
    income_range?: SortOrderInput | SortOrder
    ktp_province?: SortOrderInput | SortOrder
    ktp_city?: SortOrderInput | SortOrder
    ktp_district?: SortOrderInput | SortOrder
    ktp_subdistrict?: SortOrderInput | SortOrder
    ktp_rt?: SortOrderInput | SortOrder
    ktp_rw?: SortOrderInput | SortOrder
    ktp_postal_code?: SortOrderInput | SortOrder
    ktp_address?: SortOrderInput | SortOrder
    current_province?: SortOrderInput | SortOrder
    current_city?: SortOrderInput | SortOrder
    current_district?: SortOrderInput | SortOrder
    current_subdistrict?: SortOrderInput | SortOrder
    current_rt?: SortOrderInput | SortOrder
    current_rw?: SortOrderInput | SortOrder
    current_postal_code?: SortOrderInput | SortOrder
    current_address?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    nik?: SortOrderInput | SortOrder
    kk_number?: SortOrderInput | SortOrder
    living_status?: SortOrderInput | SortOrder
    father_nik?: SortOrderInput | SortOrder
    father_name?: SortOrderInput | SortOrder
    father_living_status?: SortOrderInput | SortOrder
    father_phone?: SortOrderInput | SortOrder
    father_place_of_birth?: SortOrderInput | SortOrder
    father_date_of_birth?: SortOrderInput | SortOrder
    father_religion?: SortOrderInput | SortOrder
    father_job?: SortOrderInput | SortOrder
    father_income_range?: SortOrderInput | SortOrder
    father_address?: SortOrderInput | SortOrder
    mother_nik?: SortOrderInput | SortOrder
    mother_name?: SortOrderInput | SortOrder
    mother_living_status?: SortOrderInput | SortOrder
    mother_phone?: SortOrderInput | SortOrder
    mother_place_of_birth?: SortOrderInput | SortOrder
    mother_date_of_birth?: SortOrderInput | SortOrder
    mother_religion?: SortOrderInput | SortOrder
    mother_job?: SortOrderInput | SortOrder
    mother_income_range?: SortOrderInput | SortOrder
    mother_address?: SortOrderInput | SortOrder
    school_name?: SortOrderInput | SortOrder
    school_major?: SortOrderInput | SortOrder
    nisn?: SortOrderInput | SortOrder
    diploma_number?: SortOrderInput | SortOrder
    graduation_year?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: student_profilesCountOrderByAggregateInput
    _avg?: student_profilesAvgOrderByAggregateInput
    _max?: student_profilesMaxOrderByAggregateInput
    _min?: student_profilesMinOrderByAggregateInput
    _sum?: student_profilesSumOrderByAggregateInput
  }

  export type student_profilesScalarWhereWithAggregatesInput = {
    AND?: student_profilesScalarWhereWithAggregatesInput | student_profilesScalarWhereWithAggregatesInput[]
    OR?: student_profilesScalarWhereWithAggregatesInput[]
    NOT?: student_profilesScalarWhereWithAggregatesInput | student_profilesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"student_profiles"> | string
    tenant_id?: UuidWithAggregatesFilter<"student_profiles"> | string
    student_id?: UuidWithAggregatesFilter<"student_profiles"> | string
    gender?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    place_of_birth?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"student_profiles"> | Date | string | null
    religion?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    phone_1?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    phone_2?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    job_status?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    company_name?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    job_start_year?: IntNullableWithAggregatesFilter<"student_profiles"> | number | null
    income_range?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_province?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_city?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_district?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_subdistrict?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_rt?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_rw?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_postal_code?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    ktp_address?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_province?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_city?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_district?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_subdistrict?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_rt?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_rw?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_postal_code?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    current_address?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    citizenship?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    nik?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    kk_number?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    living_status?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_nik?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_name?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_living_status?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_phone?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_place_of_birth?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_date_of_birth?: DateTimeNullableWithAggregatesFilter<"student_profiles"> | Date | string | null
    father_religion?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_job?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_income_range?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    father_address?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_nik?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_name?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_living_status?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_phone?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_place_of_birth?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_date_of_birth?: DateTimeNullableWithAggregatesFilter<"student_profiles"> | Date | string | null
    mother_religion?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_job?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_income_range?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    mother_address?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    school_name?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    school_major?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    nisn?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    diploma_number?: StringNullableWithAggregatesFilter<"student_profiles"> | string | null
    graduation_year?: IntNullableWithAggregatesFilter<"student_profiles"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"student_profiles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"student_profiles"> | Date | string | null
  }

  export type studentsWhereInput = {
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    id?: UuidFilter<"students"> | string
    tenant_id?: UuidFilter<"students"> | string
    user_id?: UuidFilter<"students"> | string
    platform_student_number?: StringNullableFilter<"students"> | string | null
    name?: StringFilter<"students"> | string
    status?: StringNullableFilter<"students"> | string | null
    created_at?: DateTimeNullableFilter<"students"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"students"> | Date | string | null
    study_program?: StringNullableFilter<"students"> | string | null
    entry_year?: IntNullableFilter<"students"> | number | null
    attendances?: AttendancesListRelationFilter
    certificate_requests?: Certificate_requestsListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    financial_bills?: Financial_billsListRelationFilter
    research_proposals?: Research_proposalsListRelationFilter
    student_profiles?: XOR<Student_profilesNullableScalarRelationFilter, student_profilesWhereInput> | null
  }

  export type studentsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_student_number?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    study_program?: SortOrderInput | SortOrder
    entry_year?: SortOrderInput | SortOrder
    attendances?: attendancesOrderByRelationAggregateInput
    certificate_requests?: certificate_requestsOrderByRelationAggregateInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
    financial_bills?: financial_billsOrderByRelationAggregateInput
    research_proposals?: research_proposalsOrderByRelationAggregateInput
    student_profiles?: student_profilesOrderByWithRelationInput
  }

  export type studentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_user_id?: studentsTenant_idUser_idCompoundUniqueInput
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    tenant_id?: UuidFilter<"students"> | string
    user_id?: UuidFilter<"students"> | string
    platform_student_number?: StringNullableFilter<"students"> | string | null
    name?: StringFilter<"students"> | string
    status?: StringNullableFilter<"students"> | string | null
    created_at?: DateTimeNullableFilter<"students"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"students"> | Date | string | null
    study_program?: StringNullableFilter<"students"> | string | null
    entry_year?: IntNullableFilter<"students"> | number | null
    attendances?: AttendancesListRelationFilter
    certificate_requests?: Certificate_requestsListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    financial_bills?: Financial_billsListRelationFilter
    research_proposals?: Research_proposalsListRelationFilter
    student_profiles?: XOR<Student_profilesNullableScalarRelationFilter, student_profilesWhereInput> | null
  }, "id" | "tenant_id_user_id">

  export type studentsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_student_number?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    study_program?: SortOrderInput | SortOrder
    entry_year?: SortOrderInput | SortOrder
    _count?: studentsCountOrderByAggregateInput
    _avg?: studentsAvgOrderByAggregateInput
    _max?: studentsMaxOrderByAggregateInput
    _min?: studentsMinOrderByAggregateInput
    _sum?: studentsSumOrderByAggregateInput
  }

  export type studentsScalarWhereWithAggregatesInput = {
    AND?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    OR?: studentsScalarWhereWithAggregatesInput[]
    NOT?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"students"> | string
    tenant_id?: UuidWithAggregatesFilter<"students"> | string
    user_id?: UuidWithAggregatesFilter<"students"> | string
    platform_student_number?: StringNullableWithAggregatesFilter<"students"> | string | null
    name?: StringWithAggregatesFilter<"students"> | string
    status?: StringNullableWithAggregatesFilter<"students"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"students"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"students"> | Date | string | null
    study_program?: StringNullableWithAggregatesFilter<"students"> | string | null
    entry_year?: IntNullableWithAggregatesFilter<"students"> | number | null
  }

  export type announcementsCreateInput = {
    id?: string
    tenant_id: string
    title: string
    content: string
    type?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type announcementsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    title: string
    content: string
    type?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type announcementsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementsCreateManyInput = {
    id?: string
    tenant_id: string
    title: string
    content: string
    type?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type announcementsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type announcementsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesCreateInput = {
    id?: string
    tenant_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutAttendancesInput
    students: studentsCreateNestedOneWithoutAttendancesInput
  }

  export type attendancesUncheckedCreateInput = {
    id?: string
    tenant_id: string
    class_id: string
    student_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
  }

  export type attendancesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutAttendancesNestedInput
    students?: studentsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type attendancesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesCreateManyInput = {
    id?: string
    tenant_id: string
    class_id: string
    student_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
  }

  export type attendancesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificate_requestsCreateInput = {
    id?: string
    tenant_id: string
    type: string
    purpose?: string | null
    quantity?: number | null
    notes?: string | null
    status?: string | null
    rejection_reason?: string | null
    download_url?: string | null
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutCertificate_requestsInput
  }

  export type certificate_requestsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    student_id: string
    type: string
    purpose?: string | null
    quantity?: number | null
    notes?: string | null
    status?: string | null
    rejection_reason?: string | null
    download_url?: string | null
    created_at?: Date | string | null
  }

  export type certificate_requestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutCertificate_requestsNestedInput
  }

  export type certificate_requestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificate_requestsCreateManyInput = {
    id?: string
    tenant_id: string
    student_id: string
    type: string
    purpose?: string | null
    quantity?: number | null
    notes?: string | null
    status?: string | null
    rejection_reason?: string | null
    download_url?: string | null
    created_at?: Date | string | null
  }

  export type certificate_requestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificate_requestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_schedulesCreateInput = {
    id?: string
    tenant_id: string
    day: string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    type?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutClass_schedulesInput
  }

  export type class_schedulesUncheckedCreateInput = {
    id?: string
    tenant_id: string
    class_id: string
    day: string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type class_schedulesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutClass_schedulesNestedInput
  }

  export type class_schedulesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_schedulesCreateManyInput = {
    id?: string
    tenant_id: string
    class_id: string
    day: string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type class_schedulesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_schedulesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesCreateInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesCreateNestedManyWithoutClassesInput
    courses: coursesCreateNestedOneWithoutClassesInput
    lecturers?: lecturersCreateNestedOneWithoutClassesInput
    enrollments?: enrollmentsCreateNestedManyWithoutClassesInput
    exams?: examsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateInput = {
    id?: string
    tenant_id: string
    course_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutClassesInput
    exams?: examsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUpdateManyWithoutClassesNestedInput
    courses?: coursesUpdateOneRequiredWithoutClassesNestedInput
    lecturers?: lecturersUpdateOneWithoutClassesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutClassesNestedInput
    exams?: examsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUncheckedUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutClassesNestedInput
    exams?: examsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesCreateManyInput = {
    id?: string
    tenant_id: string
    course_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
  }

  export type classesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coursesCreateInput = {
    id?: string
    tenant_id: string
    code: string
    name: string
    credits?: number
    created_at?: Date | string | null
    classes?: classesCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateInput = {
    id?: string
    tenant_id: string
    code: string
    name: string
    credits?: number
    created_at?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type coursesCreateManyInput = {
    id?: string
    tenant_id: string
    code: string
    name: string
    credits?: number
    created_at?: Date | string | null
  }

  export type coursesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coursesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsCreateInput = {
    id?: string
    tenant_id: string
    status?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutEnrollmentsInput
    students: studentsCreateNestedOneWithoutEnrollmentsInput
    grades?: gradesCreateNestedManyWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    student_id: string
    class_id: string
    status?: string | null
    created_at?: Date | string | null
    grades?: gradesUncheckedCreateNestedManyWithoutEnrollmentsInput
  }

  export type enrollmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutEnrollmentsNestedInput
    students?: studentsUpdateOneRequiredWithoutEnrollmentsNestedInput
    grades?: gradesUpdateManyWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grades?: gradesUncheckedUpdateManyWithoutEnrollmentsNestedInput
  }

  export type enrollmentsCreateManyInput = {
    id?: string
    tenant_id: string
    student_id: string
    class_id: string
    status?: string | null
    created_at?: Date | string | null
  }

  export type enrollmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examsCreateInput = {
    id?: string
    tenant_id: string
    type: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutExamsInput
  }

  export type examsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    class_id: string
    type: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    created_at?: Date | string | null
  }

  export type examsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examsCreateManyInput = {
    id?: string
    tenant_id: string
    class_id: string
    type: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    created_at?: Date | string | null
  }

  export type examsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type financial_billsCreateInput = {
    id?: string
    tenant_id: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    is_paid?: boolean | null
    due_date?: Date | string | null
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutFinancial_billsInput
  }

  export type financial_billsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    student_id: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    is_paid?: boolean | null
    due_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type financial_billsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutFinancial_billsNestedInput
  }

  export type financial_billsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type financial_billsCreateManyInput = {
    id?: string
    tenant_id: string
    student_id: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    is_paid?: boolean | null
    due_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type financial_billsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type financial_billsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gradesCreateInput = {
    id?: string
    tenant_id: string
    grade?: string | null
    score?: number | null
    created_at?: Date | string | null
    enrollments: enrollmentsCreateNestedOneWithoutGradesInput
  }

  export type gradesUncheckedCreateInput = {
    id?: string
    tenant_id: string
    enrollment_id: string
    grade?: string | null
    score?: number | null
    created_at?: Date | string | null
  }

  export type gradesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: enrollmentsUpdateOneRequiredWithoutGradesNestedInput
  }

  export type gradesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    enrollment_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gradesCreateManyInput = {
    id?: string
    tenant_id: string
    enrollment_id: string
    grade?: string | null
    score?: number | null
    created_at?: Date | string | null
  }

  export type gradesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gradesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    enrollment_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lecturersCreateInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_lecturer_number?: string | null
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    classes?: classesCreateNestedManyWithoutLecturersInput
  }

  export type lecturersUncheckedCreateInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_lecturer_number?: string | null
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutLecturersInput
  }

  export type lecturersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_lecturer_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutLecturersNestedInput
  }

  export type lecturersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_lecturer_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutLecturersNestedInput
  }

  export type lecturersCreateManyInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_lecturer_number?: string | null
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type lecturersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_lecturer_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lecturersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_lecturer_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type research_proposalsCreateInput = {
    id?: string
    tenant_id: string
    title: string
    type: string
    description?: string | null
    supervisor_preferred?: string | null
    status?: string | null
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutResearch_proposalsInput
  }

  export type research_proposalsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    student_id: string
    title: string
    type: string
    description?: string | null
    supervisor_preferred?: string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type research_proposalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutResearch_proposalsNestedInput
  }

  export type research_proposalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type research_proposalsCreateManyInput = {
    id?: string
    tenant_id: string
    student_id: string
    title: string
    type: string
    description?: string | null
    supervisor_preferred?: string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type research_proposalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type research_proposalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_profilesCreateInput = {
    id?: string
    tenant_id: string
    gender?: string | null
    place_of_birth?: string | null
    date_of_birth?: Date | string | null
    religion?: string | null
    phone_1?: string | null
    phone_2?: string | null
    whatsapp?: string | null
    job_status?: string | null
    company_name?: string | null
    job_start_year?: number | null
    income_range?: string | null
    ktp_province?: string | null
    ktp_city?: string | null
    ktp_district?: string | null
    ktp_subdistrict?: string | null
    ktp_rt?: string | null
    ktp_rw?: string | null
    ktp_postal_code?: string | null
    ktp_address?: string | null
    current_province?: string | null
    current_city?: string | null
    current_district?: string | null
    current_subdistrict?: string | null
    current_rt?: string | null
    current_rw?: string | null
    current_postal_code?: string | null
    current_address?: string | null
    citizenship?: string | null
    nik?: string | null
    kk_number?: string | null
    living_status?: string | null
    father_nik?: string | null
    father_name?: string | null
    father_living_status?: string | null
    father_phone?: string | null
    father_place_of_birth?: string | null
    father_date_of_birth?: Date | string | null
    father_religion?: string | null
    father_job?: string | null
    father_income_range?: string | null
    father_address?: string | null
    mother_nik?: string | null
    mother_name?: string | null
    mother_living_status?: string | null
    mother_phone?: string | null
    mother_place_of_birth?: string | null
    mother_date_of_birth?: Date | string | null
    mother_religion?: string | null
    mother_job?: string | null
    mother_income_range?: string | null
    mother_address?: string | null
    school_name?: string | null
    school_major?: string | null
    nisn?: string | null
    diploma_number?: string | null
    graduation_year?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    students: studentsCreateNestedOneWithoutStudent_profilesInput
  }

  export type student_profilesUncheckedCreateInput = {
    id?: string
    tenant_id: string
    student_id: string
    gender?: string | null
    place_of_birth?: string | null
    date_of_birth?: Date | string | null
    religion?: string | null
    phone_1?: string | null
    phone_2?: string | null
    whatsapp?: string | null
    job_status?: string | null
    company_name?: string | null
    job_start_year?: number | null
    income_range?: string | null
    ktp_province?: string | null
    ktp_city?: string | null
    ktp_district?: string | null
    ktp_subdistrict?: string | null
    ktp_rt?: string | null
    ktp_rw?: string | null
    ktp_postal_code?: string | null
    ktp_address?: string | null
    current_province?: string | null
    current_city?: string | null
    current_district?: string | null
    current_subdistrict?: string | null
    current_rt?: string | null
    current_rw?: string | null
    current_postal_code?: string | null
    current_address?: string | null
    citizenship?: string | null
    nik?: string | null
    kk_number?: string | null
    living_status?: string | null
    father_nik?: string | null
    father_name?: string | null
    father_living_status?: string | null
    father_phone?: string | null
    father_place_of_birth?: string | null
    father_date_of_birth?: Date | string | null
    father_religion?: string | null
    father_job?: string | null
    father_income_range?: string | null
    father_address?: string | null
    mother_nik?: string | null
    mother_name?: string | null
    mother_living_status?: string | null
    mother_phone?: string | null
    mother_place_of_birth?: string | null
    mother_date_of_birth?: Date | string | null
    mother_religion?: string | null
    mother_job?: string | null
    mother_income_range?: string | null
    mother_address?: string | null
    school_name?: string | null
    school_major?: string | null
    nisn?: string | null
    diploma_number?: string | null
    graduation_year?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_profilesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    job_status?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_start_year?: NullableIntFieldUpdateOperationsInput | number | null
    income_range?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_province?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_city?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_district?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rt?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rw?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_province?: NullableStringFieldUpdateOperationsInput | string | null
    current_city?: NullableStringFieldUpdateOperationsInput | string | null
    current_district?: NullableStringFieldUpdateOperationsInput | string | null
    current_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    current_rt?: NullableStringFieldUpdateOperationsInput | string | null
    current_rw?: NullableStringFieldUpdateOperationsInput | string | null
    current_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    kk_number?: NullableStringFieldUpdateOperationsInput | string | null
    living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_nik?: NullableStringFieldUpdateOperationsInput | string | null
    father_name?: NullableStringFieldUpdateOperationsInput | string | null
    father_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_phone?: NullableStringFieldUpdateOperationsInput | string | null
    father_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    father_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    father_religion?: NullableStringFieldUpdateOperationsInput | string | null
    father_job?: NullableStringFieldUpdateOperationsInput | string | null
    father_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    father_address?: NullableStringFieldUpdateOperationsInput | string | null
    mother_nik?: NullableStringFieldUpdateOperationsInput | string | null
    mother_name?: NullableStringFieldUpdateOperationsInput | string | null
    mother_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    mother_phone?: NullableStringFieldUpdateOperationsInput | string | null
    mother_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    mother_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mother_religion?: NullableStringFieldUpdateOperationsInput | string | null
    mother_job?: NullableStringFieldUpdateOperationsInput | string | null
    mother_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    mother_address?: NullableStringFieldUpdateOperationsInput | string | null
    school_name?: NullableStringFieldUpdateOperationsInput | string | null
    school_major?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    diploma_number?: NullableStringFieldUpdateOperationsInput | string | null
    graduation_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_profilesNestedInput
  }

  export type student_profilesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    job_status?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_start_year?: NullableIntFieldUpdateOperationsInput | number | null
    income_range?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_province?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_city?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_district?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rt?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rw?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_province?: NullableStringFieldUpdateOperationsInput | string | null
    current_city?: NullableStringFieldUpdateOperationsInput | string | null
    current_district?: NullableStringFieldUpdateOperationsInput | string | null
    current_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    current_rt?: NullableStringFieldUpdateOperationsInput | string | null
    current_rw?: NullableStringFieldUpdateOperationsInput | string | null
    current_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    kk_number?: NullableStringFieldUpdateOperationsInput | string | null
    living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_nik?: NullableStringFieldUpdateOperationsInput | string | null
    father_name?: NullableStringFieldUpdateOperationsInput | string | null
    father_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_phone?: NullableStringFieldUpdateOperationsInput | string | null
    father_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    father_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    father_religion?: NullableStringFieldUpdateOperationsInput | string | null
    father_job?: NullableStringFieldUpdateOperationsInput | string | null
    father_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    father_address?: NullableStringFieldUpdateOperationsInput | string | null
    mother_nik?: NullableStringFieldUpdateOperationsInput | string | null
    mother_name?: NullableStringFieldUpdateOperationsInput | string | null
    mother_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    mother_phone?: NullableStringFieldUpdateOperationsInput | string | null
    mother_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    mother_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mother_religion?: NullableStringFieldUpdateOperationsInput | string | null
    mother_job?: NullableStringFieldUpdateOperationsInput | string | null
    mother_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    mother_address?: NullableStringFieldUpdateOperationsInput | string | null
    school_name?: NullableStringFieldUpdateOperationsInput | string | null
    school_major?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    diploma_number?: NullableStringFieldUpdateOperationsInput | string | null
    graduation_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_profilesCreateManyInput = {
    id?: string
    tenant_id: string
    student_id: string
    gender?: string | null
    place_of_birth?: string | null
    date_of_birth?: Date | string | null
    religion?: string | null
    phone_1?: string | null
    phone_2?: string | null
    whatsapp?: string | null
    job_status?: string | null
    company_name?: string | null
    job_start_year?: number | null
    income_range?: string | null
    ktp_province?: string | null
    ktp_city?: string | null
    ktp_district?: string | null
    ktp_subdistrict?: string | null
    ktp_rt?: string | null
    ktp_rw?: string | null
    ktp_postal_code?: string | null
    ktp_address?: string | null
    current_province?: string | null
    current_city?: string | null
    current_district?: string | null
    current_subdistrict?: string | null
    current_rt?: string | null
    current_rw?: string | null
    current_postal_code?: string | null
    current_address?: string | null
    citizenship?: string | null
    nik?: string | null
    kk_number?: string | null
    living_status?: string | null
    father_nik?: string | null
    father_name?: string | null
    father_living_status?: string | null
    father_phone?: string | null
    father_place_of_birth?: string | null
    father_date_of_birth?: Date | string | null
    father_religion?: string | null
    father_job?: string | null
    father_income_range?: string | null
    father_address?: string | null
    mother_nik?: string | null
    mother_name?: string | null
    mother_living_status?: string | null
    mother_phone?: string | null
    mother_place_of_birth?: string | null
    mother_date_of_birth?: Date | string | null
    mother_religion?: string | null
    mother_job?: string | null
    mother_income_range?: string | null
    mother_address?: string | null
    school_name?: string | null
    school_major?: string | null
    nisn?: string | null
    diploma_number?: string | null
    graduation_year?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_profilesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    job_status?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_start_year?: NullableIntFieldUpdateOperationsInput | number | null
    income_range?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_province?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_city?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_district?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rt?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rw?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_province?: NullableStringFieldUpdateOperationsInput | string | null
    current_city?: NullableStringFieldUpdateOperationsInput | string | null
    current_district?: NullableStringFieldUpdateOperationsInput | string | null
    current_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    current_rt?: NullableStringFieldUpdateOperationsInput | string | null
    current_rw?: NullableStringFieldUpdateOperationsInput | string | null
    current_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    kk_number?: NullableStringFieldUpdateOperationsInput | string | null
    living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_nik?: NullableStringFieldUpdateOperationsInput | string | null
    father_name?: NullableStringFieldUpdateOperationsInput | string | null
    father_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_phone?: NullableStringFieldUpdateOperationsInput | string | null
    father_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    father_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    father_religion?: NullableStringFieldUpdateOperationsInput | string | null
    father_job?: NullableStringFieldUpdateOperationsInput | string | null
    father_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    father_address?: NullableStringFieldUpdateOperationsInput | string | null
    mother_nik?: NullableStringFieldUpdateOperationsInput | string | null
    mother_name?: NullableStringFieldUpdateOperationsInput | string | null
    mother_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    mother_phone?: NullableStringFieldUpdateOperationsInput | string | null
    mother_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    mother_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mother_religion?: NullableStringFieldUpdateOperationsInput | string | null
    mother_job?: NullableStringFieldUpdateOperationsInput | string | null
    mother_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    mother_address?: NullableStringFieldUpdateOperationsInput | string | null
    school_name?: NullableStringFieldUpdateOperationsInput | string | null
    school_major?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    diploma_number?: NullableStringFieldUpdateOperationsInput | string | null
    graduation_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_profilesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    job_status?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_start_year?: NullableIntFieldUpdateOperationsInput | number | null
    income_range?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_province?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_city?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_district?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rt?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rw?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_province?: NullableStringFieldUpdateOperationsInput | string | null
    current_city?: NullableStringFieldUpdateOperationsInput | string | null
    current_district?: NullableStringFieldUpdateOperationsInput | string | null
    current_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    current_rt?: NullableStringFieldUpdateOperationsInput | string | null
    current_rw?: NullableStringFieldUpdateOperationsInput | string | null
    current_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    kk_number?: NullableStringFieldUpdateOperationsInput | string | null
    living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_nik?: NullableStringFieldUpdateOperationsInput | string | null
    father_name?: NullableStringFieldUpdateOperationsInput | string | null
    father_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_phone?: NullableStringFieldUpdateOperationsInput | string | null
    father_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    father_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    father_religion?: NullableStringFieldUpdateOperationsInput | string | null
    father_job?: NullableStringFieldUpdateOperationsInput | string | null
    father_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    father_address?: NullableStringFieldUpdateOperationsInput | string | null
    mother_nik?: NullableStringFieldUpdateOperationsInput | string | null
    mother_name?: NullableStringFieldUpdateOperationsInput | string | null
    mother_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    mother_phone?: NullableStringFieldUpdateOperationsInput | string | null
    mother_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    mother_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mother_religion?: NullableStringFieldUpdateOperationsInput | string | null
    mother_job?: NullableStringFieldUpdateOperationsInput | string | null
    mother_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    mother_address?: NullableStringFieldUpdateOperationsInput | string | null
    school_name?: NullableStringFieldUpdateOperationsInput | string | null
    school_major?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    diploma_number?: NullableStringFieldUpdateOperationsInput | string | null
    graduation_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentsCreateInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsUncheckedCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsUncheckedCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesUncheckedCreateNestedOneWithoutStudentsInput
  }

  export type studentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUncheckedUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUncheckedUpdateOneWithoutStudentsNestedInput
  }

  export type studentsCreateManyInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
  }

  export type studentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type announcementsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type announcementsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type announcementsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClassesScalarRelationFilter = {
    is?: classesWhereInput
    isNot?: classesWhereInput
  }

  export type StudentsScalarRelationFilter = {
    is?: studentsWhereInput
    isNot?: studentsWhereInput
  }

  export type attendancesClass_idStudent_idMeeting_numberCompoundUniqueInput = {
    class_id: string
    student_id: string
    meeting_number: number
  }

  export type attendancesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    student_id?: SortOrder
    meeting_number?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type attendancesAvgOrderByAggregateInput = {
    meeting_number?: SortOrder
  }

  export type attendancesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    student_id?: SortOrder
    meeting_number?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type attendancesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    student_id?: SortOrder
    meeting_number?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type attendancesSumOrderByAggregateInput = {
    meeting_number?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type certificate_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejection_reason?: SortOrder
    download_url?: SortOrder
    created_at?: SortOrder
  }

  export type certificate_requestsAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type certificate_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejection_reason?: SortOrder
    download_url?: SortOrder
    created_at?: SortOrder
  }

  export type certificate_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    rejection_reason?: SortOrder
    download_url?: SortOrder
    created_at?: SortOrder
  }

  export type certificate_requestsSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type class_schedulesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type class_schedulesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type class_schedulesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type AttendancesListRelationFilter = {
    every?: attendancesWhereInput
    some?: attendancesWhereInput
    none?: attendancesWhereInput
  }

  export type Class_schedulesListRelationFilter = {
    every?: class_schedulesWhereInput
    some?: class_schedulesWhereInput
    none?: class_schedulesWhereInput
  }

  export type CoursesScalarRelationFilter = {
    is?: coursesWhereInput
    isNot?: coursesWhereInput
  }

  export type LecturersNullableScalarRelationFilter = {
    is?: lecturersWhereInput | null
    isNot?: lecturersWhereInput | null
  }

  export type EnrollmentsListRelationFilter = {
    every?: enrollmentsWhereInput
    some?: enrollmentsWhereInput
    none?: enrollmentsWhereInput
  }

  export type ExamsListRelationFilter = {
    every?: examsWhereInput
    some?: examsWhereInput
    none?: examsWhereInput
  }

  export type attendancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type class_schedulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enrollmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type classesTenant_idCourse_idSemesterYearCompoundUniqueInput = {
    tenant_id: string
    course_id: string
    semester: string
    year: number
  }

  export type classesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    course_id?: SortOrder
    lecturer_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    capacity?: SortOrder
    created_at?: SortOrder
  }

  export type classesAvgOrderByAggregateInput = {
    year?: SortOrder
    capacity?: SortOrder
  }

  export type classesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    course_id?: SortOrder
    lecturer_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    capacity?: SortOrder
    created_at?: SortOrder
  }

  export type classesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    course_id?: SortOrder
    lecturer_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    capacity?: SortOrder
    created_at?: SortOrder
  }

  export type classesSumOrderByAggregateInput = {
    year?: SortOrder
    capacity?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClassesListRelationFilter = {
    every?: classesWhereInput
    some?: classesWhereInput
    none?: classesWhereInput
  }

  export type classesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type coursesTenant_idCodeCompoundUniqueInput = {
    tenant_id: string
    code: string
  }

  export type coursesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    created_at?: SortOrder
  }

  export type coursesAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type coursesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    created_at?: SortOrder
  }

  export type coursesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    created_at?: SortOrder
  }

  export type coursesSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type GradesListRelationFilter = {
    every?: gradesWhereInput
    some?: gradesWhereInput
    none?: gradesWhereInput
  }

  export type gradesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enrollmentsStudent_idClass_idCompoundUniqueInput = {
    student_id: string
    class_id: string
  }

  export type enrollmentsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type enrollmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type enrollmentsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    class_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type examsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrder
    created_at?: SortOrder
  }

  export type examsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrder
    created_at?: SortOrder
  }

  export type examsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    class_id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    room?: SortOrder
    created_at?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type financial_billsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    is_paid?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
  }

  export type financial_billsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type financial_billsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    is_paid?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
  }

  export type financial_billsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    is_paid?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
  }

  export type financial_billsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnrollmentsScalarRelationFilter = {
    is?: enrollmentsWhereInput
    isNot?: enrollmentsWhereInput
  }

  export type gradesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    enrollment_id?: SortOrder
    grade?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
  }

  export type gradesAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type gradesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    enrollment_id?: SortOrder
    grade?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
  }

  export type gradesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    enrollment_id?: SortOrder
    grade?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
  }

  export type gradesSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type lecturersTenant_idUser_idCompoundUniqueInput = {
    tenant_id: string
    user_id: string
  }

  export type lecturersCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_lecturer_number?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type lecturersMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_lecturer_number?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type lecturersMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_lecturer_number?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type research_proposalsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    supervisor_preferred?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type research_proposalsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    supervisor_preferred?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type research_proposalsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    supervisor_preferred?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type student_profilesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    gender?: SortOrder
    place_of_birth?: SortOrder
    date_of_birth?: SortOrder
    religion?: SortOrder
    phone_1?: SortOrder
    phone_2?: SortOrder
    whatsapp?: SortOrder
    job_status?: SortOrder
    company_name?: SortOrder
    job_start_year?: SortOrder
    income_range?: SortOrder
    ktp_province?: SortOrder
    ktp_city?: SortOrder
    ktp_district?: SortOrder
    ktp_subdistrict?: SortOrder
    ktp_rt?: SortOrder
    ktp_rw?: SortOrder
    ktp_postal_code?: SortOrder
    ktp_address?: SortOrder
    current_province?: SortOrder
    current_city?: SortOrder
    current_district?: SortOrder
    current_subdistrict?: SortOrder
    current_rt?: SortOrder
    current_rw?: SortOrder
    current_postal_code?: SortOrder
    current_address?: SortOrder
    citizenship?: SortOrder
    nik?: SortOrder
    kk_number?: SortOrder
    living_status?: SortOrder
    father_nik?: SortOrder
    father_name?: SortOrder
    father_living_status?: SortOrder
    father_phone?: SortOrder
    father_place_of_birth?: SortOrder
    father_date_of_birth?: SortOrder
    father_religion?: SortOrder
    father_job?: SortOrder
    father_income_range?: SortOrder
    father_address?: SortOrder
    mother_nik?: SortOrder
    mother_name?: SortOrder
    mother_living_status?: SortOrder
    mother_phone?: SortOrder
    mother_place_of_birth?: SortOrder
    mother_date_of_birth?: SortOrder
    mother_religion?: SortOrder
    mother_job?: SortOrder
    mother_income_range?: SortOrder
    mother_address?: SortOrder
    school_name?: SortOrder
    school_major?: SortOrder
    nisn?: SortOrder
    diploma_number?: SortOrder
    graduation_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_profilesAvgOrderByAggregateInput = {
    job_start_year?: SortOrder
    graduation_year?: SortOrder
  }

  export type student_profilesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    gender?: SortOrder
    place_of_birth?: SortOrder
    date_of_birth?: SortOrder
    religion?: SortOrder
    phone_1?: SortOrder
    phone_2?: SortOrder
    whatsapp?: SortOrder
    job_status?: SortOrder
    company_name?: SortOrder
    job_start_year?: SortOrder
    income_range?: SortOrder
    ktp_province?: SortOrder
    ktp_city?: SortOrder
    ktp_district?: SortOrder
    ktp_subdistrict?: SortOrder
    ktp_rt?: SortOrder
    ktp_rw?: SortOrder
    ktp_postal_code?: SortOrder
    ktp_address?: SortOrder
    current_province?: SortOrder
    current_city?: SortOrder
    current_district?: SortOrder
    current_subdistrict?: SortOrder
    current_rt?: SortOrder
    current_rw?: SortOrder
    current_postal_code?: SortOrder
    current_address?: SortOrder
    citizenship?: SortOrder
    nik?: SortOrder
    kk_number?: SortOrder
    living_status?: SortOrder
    father_nik?: SortOrder
    father_name?: SortOrder
    father_living_status?: SortOrder
    father_phone?: SortOrder
    father_place_of_birth?: SortOrder
    father_date_of_birth?: SortOrder
    father_religion?: SortOrder
    father_job?: SortOrder
    father_income_range?: SortOrder
    father_address?: SortOrder
    mother_nik?: SortOrder
    mother_name?: SortOrder
    mother_living_status?: SortOrder
    mother_phone?: SortOrder
    mother_place_of_birth?: SortOrder
    mother_date_of_birth?: SortOrder
    mother_religion?: SortOrder
    mother_job?: SortOrder
    mother_income_range?: SortOrder
    mother_address?: SortOrder
    school_name?: SortOrder
    school_major?: SortOrder
    nisn?: SortOrder
    diploma_number?: SortOrder
    graduation_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_profilesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    student_id?: SortOrder
    gender?: SortOrder
    place_of_birth?: SortOrder
    date_of_birth?: SortOrder
    religion?: SortOrder
    phone_1?: SortOrder
    phone_2?: SortOrder
    whatsapp?: SortOrder
    job_status?: SortOrder
    company_name?: SortOrder
    job_start_year?: SortOrder
    income_range?: SortOrder
    ktp_province?: SortOrder
    ktp_city?: SortOrder
    ktp_district?: SortOrder
    ktp_subdistrict?: SortOrder
    ktp_rt?: SortOrder
    ktp_rw?: SortOrder
    ktp_postal_code?: SortOrder
    ktp_address?: SortOrder
    current_province?: SortOrder
    current_city?: SortOrder
    current_district?: SortOrder
    current_subdistrict?: SortOrder
    current_rt?: SortOrder
    current_rw?: SortOrder
    current_postal_code?: SortOrder
    current_address?: SortOrder
    citizenship?: SortOrder
    nik?: SortOrder
    kk_number?: SortOrder
    living_status?: SortOrder
    father_nik?: SortOrder
    father_name?: SortOrder
    father_living_status?: SortOrder
    father_phone?: SortOrder
    father_place_of_birth?: SortOrder
    father_date_of_birth?: SortOrder
    father_religion?: SortOrder
    father_job?: SortOrder
    father_income_range?: SortOrder
    father_address?: SortOrder
    mother_nik?: SortOrder
    mother_name?: SortOrder
    mother_living_status?: SortOrder
    mother_phone?: SortOrder
    mother_place_of_birth?: SortOrder
    mother_date_of_birth?: SortOrder
    mother_religion?: SortOrder
    mother_job?: SortOrder
    mother_income_range?: SortOrder
    mother_address?: SortOrder
    school_name?: SortOrder
    school_major?: SortOrder
    nisn?: SortOrder
    diploma_number?: SortOrder
    graduation_year?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_profilesSumOrderByAggregateInput = {
    job_start_year?: SortOrder
    graduation_year?: SortOrder
  }

  export type Certificate_requestsListRelationFilter = {
    every?: certificate_requestsWhereInput
    some?: certificate_requestsWhereInput
    none?: certificate_requestsWhereInput
  }

  export type Financial_billsListRelationFilter = {
    every?: financial_billsWhereInput
    some?: financial_billsWhereInput
    none?: financial_billsWhereInput
  }

  export type Research_proposalsListRelationFilter = {
    every?: research_proposalsWhereInput
    some?: research_proposalsWhereInput
    none?: research_proposalsWhereInput
  }

  export type Student_profilesNullableScalarRelationFilter = {
    is?: student_profilesWhereInput | null
    isNot?: student_profilesWhereInput | null
  }

  export type certificate_requestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type financial_billsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type research_proposalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsTenant_idUser_idCompoundUniqueInput = {
    tenant_id: string
    user_id: string
  }

  export type studentsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_student_number?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    study_program?: SortOrder
    entry_year?: SortOrder
  }

  export type studentsAvgOrderByAggregateInput = {
    entry_year?: SortOrder
  }

  export type studentsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_student_number?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    study_program?: SortOrder
    entry_year?: SortOrder
  }

  export type studentsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    platform_student_number?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    study_program?: SortOrder
    entry_year?: SortOrder
  }

  export type studentsSumOrderByAggregateInput = {
    entry_year?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type classesCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<classesCreateWithoutAttendancesInput, classesUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: classesCreateOrConnectWithoutAttendancesInput
    connect?: classesWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttendancesInput
    connect?: studentsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type classesUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<classesCreateWithoutAttendancesInput, classesUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: classesCreateOrConnectWithoutAttendancesInput
    upsert?: classesUpsertWithoutAttendancesInput
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutAttendancesInput, classesUpdateWithoutAttendancesInput>, classesUncheckedUpdateWithoutAttendancesInput>
  }

  export type studentsUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttendancesInput
    upsert?: studentsUpsertWithoutAttendancesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutAttendancesInput, studentsUpdateWithoutAttendancesInput>, studentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type studentsCreateNestedOneWithoutCertificate_requestsInput = {
    create?: XOR<studentsCreateWithoutCertificate_requestsInput, studentsUncheckedCreateWithoutCertificate_requestsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutCertificate_requestsInput
    connect?: studentsWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type studentsUpdateOneRequiredWithoutCertificate_requestsNestedInput = {
    create?: XOR<studentsCreateWithoutCertificate_requestsInput, studentsUncheckedCreateWithoutCertificate_requestsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutCertificate_requestsInput
    upsert?: studentsUpsertWithoutCertificate_requestsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutCertificate_requestsInput, studentsUpdateWithoutCertificate_requestsInput>, studentsUncheckedUpdateWithoutCertificate_requestsInput>
  }

  export type classesCreateNestedOneWithoutClass_schedulesInput = {
    create?: XOR<classesCreateWithoutClass_schedulesInput, classesUncheckedCreateWithoutClass_schedulesInput>
    connectOrCreate?: classesCreateOrConnectWithoutClass_schedulesInput
    connect?: classesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type classesUpdateOneRequiredWithoutClass_schedulesNestedInput = {
    create?: XOR<classesCreateWithoutClass_schedulesInput, classesUncheckedCreateWithoutClass_schedulesInput>
    connectOrCreate?: classesCreateOrConnectWithoutClass_schedulesInput
    upsert?: classesUpsertWithoutClass_schedulesInput
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutClass_schedulesInput, classesUpdateWithoutClass_schedulesInput>, classesUncheckedUpdateWithoutClass_schedulesInput>
  }

  export type attendancesCreateNestedManyWithoutClassesInput = {
    create?: XOR<attendancesCreateWithoutClassesInput, attendancesUncheckedCreateWithoutClassesInput> | attendancesCreateWithoutClassesInput[] | attendancesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutClassesInput | attendancesCreateOrConnectWithoutClassesInput[]
    createMany?: attendancesCreateManyClassesInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type class_schedulesCreateNestedManyWithoutClassesInput = {
    create?: XOR<class_schedulesCreateWithoutClassesInput, class_schedulesUncheckedCreateWithoutClassesInput> | class_schedulesCreateWithoutClassesInput[] | class_schedulesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: class_schedulesCreateOrConnectWithoutClassesInput | class_schedulesCreateOrConnectWithoutClassesInput[]
    createMany?: class_schedulesCreateManyClassesInputEnvelope
    connect?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
  }

  export type coursesCreateNestedOneWithoutClassesInput = {
    create?: XOR<coursesCreateWithoutClassesInput, coursesUncheckedCreateWithoutClassesInput>
    connectOrCreate?: coursesCreateOrConnectWithoutClassesInput
    connect?: coursesWhereUniqueInput
  }

  export type lecturersCreateNestedOneWithoutClassesInput = {
    create?: XOR<lecturersCreateWithoutClassesInput, lecturersUncheckedCreateWithoutClassesInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutClassesInput
    connect?: lecturersWhereUniqueInput
  }

  export type enrollmentsCreateNestedManyWithoutClassesInput = {
    create?: XOR<enrollmentsCreateWithoutClassesInput, enrollmentsUncheckedCreateWithoutClassesInput> | enrollmentsCreateWithoutClassesInput[] | enrollmentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutClassesInput | enrollmentsCreateOrConnectWithoutClassesInput[]
    createMany?: enrollmentsCreateManyClassesInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type examsCreateNestedManyWithoutClassesInput = {
    create?: XOR<examsCreateWithoutClassesInput, examsUncheckedCreateWithoutClassesInput> | examsCreateWithoutClassesInput[] | examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: examsCreateOrConnectWithoutClassesInput | examsCreateOrConnectWithoutClassesInput[]
    createMany?: examsCreateManyClassesInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type attendancesUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<attendancesCreateWithoutClassesInput, attendancesUncheckedCreateWithoutClassesInput> | attendancesCreateWithoutClassesInput[] | attendancesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutClassesInput | attendancesCreateOrConnectWithoutClassesInput[]
    createMany?: attendancesCreateManyClassesInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type class_schedulesUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<class_schedulesCreateWithoutClassesInput, class_schedulesUncheckedCreateWithoutClassesInput> | class_schedulesCreateWithoutClassesInput[] | class_schedulesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: class_schedulesCreateOrConnectWithoutClassesInput | class_schedulesCreateOrConnectWithoutClassesInput[]
    createMany?: class_schedulesCreateManyClassesInputEnvelope
    connect?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<enrollmentsCreateWithoutClassesInput, enrollmentsUncheckedCreateWithoutClassesInput> | enrollmentsCreateWithoutClassesInput[] | enrollmentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutClassesInput | enrollmentsCreateOrConnectWithoutClassesInput[]
    createMany?: enrollmentsCreateManyClassesInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type examsUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<examsCreateWithoutClassesInput, examsUncheckedCreateWithoutClassesInput> | examsCreateWithoutClassesInput[] | examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: examsCreateOrConnectWithoutClassesInput | examsCreateOrConnectWithoutClassesInput[]
    createMany?: examsCreateManyClassesInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type attendancesUpdateManyWithoutClassesNestedInput = {
    create?: XOR<attendancesCreateWithoutClassesInput, attendancesUncheckedCreateWithoutClassesInput> | attendancesCreateWithoutClassesInput[] | attendancesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutClassesInput | attendancesCreateOrConnectWithoutClassesInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutClassesInput | attendancesUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: attendancesCreateManyClassesInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutClassesInput | attendancesUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutClassesInput | attendancesUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type class_schedulesUpdateManyWithoutClassesNestedInput = {
    create?: XOR<class_schedulesCreateWithoutClassesInput, class_schedulesUncheckedCreateWithoutClassesInput> | class_schedulesCreateWithoutClassesInput[] | class_schedulesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: class_schedulesCreateOrConnectWithoutClassesInput | class_schedulesCreateOrConnectWithoutClassesInput[]
    upsert?: class_schedulesUpsertWithWhereUniqueWithoutClassesInput | class_schedulesUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: class_schedulesCreateManyClassesInputEnvelope
    set?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    disconnect?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    delete?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    connect?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    update?: class_schedulesUpdateWithWhereUniqueWithoutClassesInput | class_schedulesUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: class_schedulesUpdateManyWithWhereWithoutClassesInput | class_schedulesUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: class_schedulesScalarWhereInput | class_schedulesScalarWhereInput[]
  }

  export type coursesUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<coursesCreateWithoutClassesInput, coursesUncheckedCreateWithoutClassesInput>
    connectOrCreate?: coursesCreateOrConnectWithoutClassesInput
    upsert?: coursesUpsertWithoutClassesInput
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutClassesInput, coursesUpdateWithoutClassesInput>, coursesUncheckedUpdateWithoutClassesInput>
  }

  export type lecturersUpdateOneWithoutClassesNestedInput = {
    create?: XOR<lecturersCreateWithoutClassesInput, lecturersUncheckedCreateWithoutClassesInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutClassesInput
    upsert?: lecturersUpsertWithoutClassesInput
    disconnect?: lecturersWhereInput | boolean
    delete?: lecturersWhereInput | boolean
    connect?: lecturersWhereUniqueInput
    update?: XOR<XOR<lecturersUpdateToOneWithWhereWithoutClassesInput, lecturersUpdateWithoutClassesInput>, lecturersUncheckedUpdateWithoutClassesInput>
  }

  export type enrollmentsUpdateManyWithoutClassesNestedInput = {
    create?: XOR<enrollmentsCreateWithoutClassesInput, enrollmentsUncheckedCreateWithoutClassesInput> | enrollmentsCreateWithoutClassesInput[] | enrollmentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutClassesInput | enrollmentsCreateOrConnectWithoutClassesInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutClassesInput | enrollmentsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: enrollmentsCreateManyClassesInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutClassesInput | enrollmentsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutClassesInput | enrollmentsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type examsUpdateManyWithoutClassesNestedInput = {
    create?: XOR<examsCreateWithoutClassesInput, examsUncheckedCreateWithoutClassesInput> | examsCreateWithoutClassesInput[] | examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: examsCreateOrConnectWithoutClassesInput | examsCreateOrConnectWithoutClassesInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutClassesInput | examsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: examsCreateManyClassesInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutClassesInput | examsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: examsUpdateManyWithWhereWithoutClassesInput | examsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type attendancesUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<attendancesCreateWithoutClassesInput, attendancesUncheckedCreateWithoutClassesInput> | attendancesCreateWithoutClassesInput[] | attendancesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutClassesInput | attendancesCreateOrConnectWithoutClassesInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutClassesInput | attendancesUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: attendancesCreateManyClassesInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutClassesInput | attendancesUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutClassesInput | attendancesUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type class_schedulesUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<class_schedulesCreateWithoutClassesInput, class_schedulesUncheckedCreateWithoutClassesInput> | class_schedulesCreateWithoutClassesInput[] | class_schedulesUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: class_schedulesCreateOrConnectWithoutClassesInput | class_schedulesCreateOrConnectWithoutClassesInput[]
    upsert?: class_schedulesUpsertWithWhereUniqueWithoutClassesInput | class_schedulesUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: class_schedulesCreateManyClassesInputEnvelope
    set?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    disconnect?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    delete?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    connect?: class_schedulesWhereUniqueInput | class_schedulesWhereUniqueInput[]
    update?: class_schedulesUpdateWithWhereUniqueWithoutClassesInput | class_schedulesUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: class_schedulesUpdateManyWithWhereWithoutClassesInput | class_schedulesUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: class_schedulesScalarWhereInput | class_schedulesScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<enrollmentsCreateWithoutClassesInput, enrollmentsUncheckedCreateWithoutClassesInput> | enrollmentsCreateWithoutClassesInput[] | enrollmentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutClassesInput | enrollmentsCreateOrConnectWithoutClassesInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutClassesInput | enrollmentsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: enrollmentsCreateManyClassesInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutClassesInput | enrollmentsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutClassesInput | enrollmentsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type examsUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<examsCreateWithoutClassesInput, examsUncheckedCreateWithoutClassesInput> | examsCreateWithoutClassesInput[] | examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: examsCreateOrConnectWithoutClassesInput | examsCreateOrConnectWithoutClassesInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutClassesInput | examsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: examsCreateManyClassesInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutClassesInput | examsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: examsUpdateManyWithWhereWithoutClassesInput | examsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type classesCreateNestedManyWithoutCoursesInput = {
    create?: XOR<classesCreateWithoutCoursesInput, classesUncheckedCreateWithoutCoursesInput> | classesCreateWithoutCoursesInput[] | classesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutCoursesInput | classesCreateOrConnectWithoutCoursesInput[]
    createMany?: classesCreateManyCoursesInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type classesUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<classesCreateWithoutCoursesInput, classesUncheckedCreateWithoutCoursesInput> | classesCreateWithoutCoursesInput[] | classesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutCoursesInput | classesCreateOrConnectWithoutCoursesInput[]
    createMany?: classesCreateManyCoursesInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type classesUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<classesCreateWithoutCoursesInput, classesUncheckedCreateWithoutCoursesInput> | classesCreateWithoutCoursesInput[] | classesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutCoursesInput | classesCreateOrConnectWithoutCoursesInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutCoursesInput | classesUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: classesCreateManyCoursesInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutCoursesInput | classesUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: classesUpdateManyWithWhereWithoutCoursesInput | classesUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type classesUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<classesCreateWithoutCoursesInput, classesUncheckedCreateWithoutCoursesInput> | classesCreateWithoutCoursesInput[] | classesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutCoursesInput | classesCreateOrConnectWithoutCoursesInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutCoursesInput | classesUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: classesCreateManyCoursesInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutCoursesInput | classesUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: classesUpdateManyWithWhereWithoutCoursesInput | classesUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type classesCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<classesCreateWithoutEnrollmentsInput, classesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: classesCreateOrConnectWithoutEnrollmentsInput
    connect?: classesWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<studentsCreateWithoutEnrollmentsInput, studentsUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutEnrollmentsInput
    connect?: studentsWhereUniqueInput
  }

  export type gradesCreateNestedManyWithoutEnrollmentsInput = {
    create?: XOR<gradesCreateWithoutEnrollmentsInput, gradesUncheckedCreateWithoutEnrollmentsInput> | gradesCreateWithoutEnrollmentsInput[] | gradesUncheckedCreateWithoutEnrollmentsInput[]
    connectOrCreate?: gradesCreateOrConnectWithoutEnrollmentsInput | gradesCreateOrConnectWithoutEnrollmentsInput[]
    createMany?: gradesCreateManyEnrollmentsInputEnvelope
    connect?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
  }

  export type gradesUncheckedCreateNestedManyWithoutEnrollmentsInput = {
    create?: XOR<gradesCreateWithoutEnrollmentsInput, gradesUncheckedCreateWithoutEnrollmentsInput> | gradesCreateWithoutEnrollmentsInput[] | gradesUncheckedCreateWithoutEnrollmentsInput[]
    connectOrCreate?: gradesCreateOrConnectWithoutEnrollmentsInput | gradesCreateOrConnectWithoutEnrollmentsInput[]
    createMany?: gradesCreateManyEnrollmentsInputEnvelope
    connect?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
  }

  export type classesUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<classesCreateWithoutEnrollmentsInput, classesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: classesCreateOrConnectWithoutEnrollmentsInput
    upsert?: classesUpsertWithoutEnrollmentsInput
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutEnrollmentsInput, classesUpdateWithoutEnrollmentsInput>, classesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type studentsUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<studentsCreateWithoutEnrollmentsInput, studentsUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutEnrollmentsInput
    upsert?: studentsUpsertWithoutEnrollmentsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutEnrollmentsInput, studentsUpdateWithoutEnrollmentsInput>, studentsUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type gradesUpdateManyWithoutEnrollmentsNestedInput = {
    create?: XOR<gradesCreateWithoutEnrollmentsInput, gradesUncheckedCreateWithoutEnrollmentsInput> | gradesCreateWithoutEnrollmentsInput[] | gradesUncheckedCreateWithoutEnrollmentsInput[]
    connectOrCreate?: gradesCreateOrConnectWithoutEnrollmentsInput | gradesCreateOrConnectWithoutEnrollmentsInput[]
    upsert?: gradesUpsertWithWhereUniqueWithoutEnrollmentsInput | gradesUpsertWithWhereUniqueWithoutEnrollmentsInput[]
    createMany?: gradesCreateManyEnrollmentsInputEnvelope
    set?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    disconnect?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    delete?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    connect?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    update?: gradesUpdateWithWhereUniqueWithoutEnrollmentsInput | gradesUpdateWithWhereUniqueWithoutEnrollmentsInput[]
    updateMany?: gradesUpdateManyWithWhereWithoutEnrollmentsInput | gradesUpdateManyWithWhereWithoutEnrollmentsInput[]
    deleteMany?: gradesScalarWhereInput | gradesScalarWhereInput[]
  }

  export type gradesUncheckedUpdateManyWithoutEnrollmentsNestedInput = {
    create?: XOR<gradesCreateWithoutEnrollmentsInput, gradesUncheckedCreateWithoutEnrollmentsInput> | gradesCreateWithoutEnrollmentsInput[] | gradesUncheckedCreateWithoutEnrollmentsInput[]
    connectOrCreate?: gradesCreateOrConnectWithoutEnrollmentsInput | gradesCreateOrConnectWithoutEnrollmentsInput[]
    upsert?: gradesUpsertWithWhereUniqueWithoutEnrollmentsInput | gradesUpsertWithWhereUniqueWithoutEnrollmentsInput[]
    createMany?: gradesCreateManyEnrollmentsInputEnvelope
    set?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    disconnect?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    delete?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    connect?: gradesWhereUniqueInput | gradesWhereUniqueInput[]
    update?: gradesUpdateWithWhereUniqueWithoutEnrollmentsInput | gradesUpdateWithWhereUniqueWithoutEnrollmentsInput[]
    updateMany?: gradesUpdateManyWithWhereWithoutEnrollmentsInput | gradesUpdateManyWithWhereWithoutEnrollmentsInput[]
    deleteMany?: gradesScalarWhereInput | gradesScalarWhereInput[]
  }

  export type classesCreateNestedOneWithoutExamsInput = {
    create?: XOR<classesCreateWithoutExamsInput, classesUncheckedCreateWithoutExamsInput>
    connectOrCreate?: classesCreateOrConnectWithoutExamsInput
    connect?: classesWhereUniqueInput
  }

  export type classesUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<classesCreateWithoutExamsInput, classesUncheckedCreateWithoutExamsInput>
    connectOrCreate?: classesCreateOrConnectWithoutExamsInput
    upsert?: classesUpsertWithoutExamsInput
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutExamsInput, classesUpdateWithoutExamsInput>, classesUncheckedUpdateWithoutExamsInput>
  }

  export type studentsCreateNestedOneWithoutFinancial_billsInput = {
    create?: XOR<studentsCreateWithoutFinancial_billsInput, studentsUncheckedCreateWithoutFinancial_billsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutFinancial_billsInput
    connect?: studentsWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type studentsUpdateOneRequiredWithoutFinancial_billsNestedInput = {
    create?: XOR<studentsCreateWithoutFinancial_billsInput, studentsUncheckedCreateWithoutFinancial_billsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutFinancial_billsInput
    upsert?: studentsUpsertWithoutFinancial_billsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutFinancial_billsInput, studentsUpdateWithoutFinancial_billsInput>, studentsUncheckedUpdateWithoutFinancial_billsInput>
  }

  export type enrollmentsCreateNestedOneWithoutGradesInput = {
    create?: XOR<enrollmentsCreateWithoutGradesInput, enrollmentsUncheckedCreateWithoutGradesInput>
    connectOrCreate?: enrollmentsCreateOrConnectWithoutGradesInput
    connect?: enrollmentsWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type enrollmentsUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<enrollmentsCreateWithoutGradesInput, enrollmentsUncheckedCreateWithoutGradesInput>
    connectOrCreate?: enrollmentsCreateOrConnectWithoutGradesInput
    upsert?: enrollmentsUpsertWithoutGradesInput
    connect?: enrollmentsWhereUniqueInput
    update?: XOR<XOR<enrollmentsUpdateToOneWithWhereWithoutGradesInput, enrollmentsUpdateWithoutGradesInput>, enrollmentsUncheckedUpdateWithoutGradesInput>
  }

  export type classesCreateNestedManyWithoutLecturersInput = {
    create?: XOR<classesCreateWithoutLecturersInput, classesUncheckedCreateWithoutLecturersInput> | classesCreateWithoutLecturersInput[] | classesUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutLecturersInput | classesCreateOrConnectWithoutLecturersInput[]
    createMany?: classesCreateManyLecturersInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type classesUncheckedCreateNestedManyWithoutLecturersInput = {
    create?: XOR<classesCreateWithoutLecturersInput, classesUncheckedCreateWithoutLecturersInput> | classesCreateWithoutLecturersInput[] | classesUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutLecturersInput | classesCreateOrConnectWithoutLecturersInput[]
    createMany?: classesCreateManyLecturersInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type classesUpdateManyWithoutLecturersNestedInput = {
    create?: XOR<classesCreateWithoutLecturersInput, classesUncheckedCreateWithoutLecturersInput> | classesCreateWithoutLecturersInput[] | classesUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutLecturersInput | classesCreateOrConnectWithoutLecturersInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutLecturersInput | classesUpsertWithWhereUniqueWithoutLecturersInput[]
    createMany?: classesCreateManyLecturersInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutLecturersInput | classesUpdateWithWhereUniqueWithoutLecturersInput[]
    updateMany?: classesUpdateManyWithWhereWithoutLecturersInput | classesUpdateManyWithWhereWithoutLecturersInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type classesUncheckedUpdateManyWithoutLecturersNestedInput = {
    create?: XOR<classesCreateWithoutLecturersInput, classesUncheckedCreateWithoutLecturersInput> | classesCreateWithoutLecturersInput[] | classesUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutLecturersInput | classesCreateOrConnectWithoutLecturersInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutLecturersInput | classesUpsertWithWhereUniqueWithoutLecturersInput[]
    createMany?: classesCreateManyLecturersInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutLecturersInput | classesUpdateWithWhereUniqueWithoutLecturersInput[]
    updateMany?: classesUpdateManyWithWhereWithoutLecturersInput | classesUpdateManyWithWhereWithoutLecturersInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutResearch_proposalsInput = {
    create?: XOR<studentsCreateWithoutResearch_proposalsInput, studentsUncheckedCreateWithoutResearch_proposalsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutResearch_proposalsInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutResearch_proposalsNestedInput = {
    create?: XOR<studentsCreateWithoutResearch_proposalsInput, studentsUncheckedCreateWithoutResearch_proposalsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutResearch_proposalsInput
    upsert?: studentsUpsertWithoutResearch_proposalsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutResearch_proposalsInput, studentsUpdateWithoutResearch_proposalsInput>, studentsUncheckedUpdateWithoutResearch_proposalsInput>
  }

  export type studentsCreateNestedOneWithoutStudent_profilesInput = {
    create?: XOR<studentsCreateWithoutStudent_profilesInput, studentsUncheckedCreateWithoutStudent_profilesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_profilesInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutStudent_profilesNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_profilesInput, studentsUncheckedCreateWithoutStudent_profilesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_profilesInput
    upsert?: studentsUpsertWithoutStudent_profilesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_profilesInput, studentsUpdateWithoutStudent_profilesInput>, studentsUncheckedUpdateWithoutStudent_profilesInput>
  }

  export type attendancesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type certificate_requestsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<certificate_requestsCreateWithoutStudentsInput, certificate_requestsUncheckedCreateWithoutStudentsInput> | certificate_requestsCreateWithoutStudentsInput[] | certificate_requestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: certificate_requestsCreateOrConnectWithoutStudentsInput | certificate_requestsCreateOrConnectWithoutStudentsInput[]
    createMany?: certificate_requestsCreateManyStudentsInputEnvelope
    connect?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
  }

  export type enrollmentsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<enrollmentsCreateWithoutStudentsInput, enrollmentsUncheckedCreateWithoutStudentsInput> | enrollmentsCreateWithoutStudentsInput[] | enrollmentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutStudentsInput | enrollmentsCreateOrConnectWithoutStudentsInput[]
    createMany?: enrollmentsCreateManyStudentsInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type financial_billsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<financial_billsCreateWithoutStudentsInput, financial_billsUncheckedCreateWithoutStudentsInput> | financial_billsCreateWithoutStudentsInput[] | financial_billsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financial_billsCreateOrConnectWithoutStudentsInput | financial_billsCreateOrConnectWithoutStudentsInput[]
    createMany?: financial_billsCreateManyStudentsInputEnvelope
    connect?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
  }

  export type research_proposalsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<research_proposalsCreateWithoutStudentsInput, research_proposalsUncheckedCreateWithoutStudentsInput> | research_proposalsCreateWithoutStudentsInput[] | research_proposalsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: research_proposalsCreateOrConnectWithoutStudentsInput | research_proposalsCreateOrConnectWithoutStudentsInput[]
    createMany?: research_proposalsCreateManyStudentsInputEnvelope
    connect?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
  }

  export type student_profilesCreateNestedOneWithoutStudentsInput = {
    create?: XOR<student_profilesCreateWithoutStudentsInput, student_profilesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: student_profilesCreateOrConnectWithoutStudentsInput
    connect?: student_profilesWhereUniqueInput
  }

  export type attendancesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<certificate_requestsCreateWithoutStudentsInput, certificate_requestsUncheckedCreateWithoutStudentsInput> | certificate_requestsCreateWithoutStudentsInput[] | certificate_requestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: certificate_requestsCreateOrConnectWithoutStudentsInput | certificate_requestsCreateOrConnectWithoutStudentsInput[]
    createMany?: certificate_requestsCreateManyStudentsInputEnvelope
    connect?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<enrollmentsCreateWithoutStudentsInput, enrollmentsUncheckedCreateWithoutStudentsInput> | enrollmentsCreateWithoutStudentsInput[] | enrollmentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutStudentsInput | enrollmentsCreateOrConnectWithoutStudentsInput[]
    createMany?: enrollmentsCreateManyStudentsInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type financial_billsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<financial_billsCreateWithoutStudentsInput, financial_billsUncheckedCreateWithoutStudentsInput> | financial_billsCreateWithoutStudentsInput[] | financial_billsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financial_billsCreateOrConnectWithoutStudentsInput | financial_billsCreateOrConnectWithoutStudentsInput[]
    createMany?: financial_billsCreateManyStudentsInputEnvelope
    connect?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
  }

  export type research_proposalsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<research_proposalsCreateWithoutStudentsInput, research_proposalsUncheckedCreateWithoutStudentsInput> | research_proposalsCreateWithoutStudentsInput[] | research_proposalsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: research_proposalsCreateOrConnectWithoutStudentsInput | research_proposalsCreateOrConnectWithoutStudentsInput[]
    createMany?: research_proposalsCreateManyStudentsInputEnvelope
    connect?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
  }

  export type student_profilesUncheckedCreateNestedOneWithoutStudentsInput = {
    create?: XOR<student_profilesCreateWithoutStudentsInput, student_profilesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: student_profilesCreateOrConnectWithoutStudentsInput
    connect?: student_profilesWhereUniqueInput
  }

  export type attendancesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutStudentsInput | attendancesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutStudentsInput | attendancesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutStudentsInput | attendancesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type certificate_requestsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<certificate_requestsCreateWithoutStudentsInput, certificate_requestsUncheckedCreateWithoutStudentsInput> | certificate_requestsCreateWithoutStudentsInput[] | certificate_requestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: certificate_requestsCreateOrConnectWithoutStudentsInput | certificate_requestsCreateOrConnectWithoutStudentsInput[]
    upsert?: certificate_requestsUpsertWithWhereUniqueWithoutStudentsInput | certificate_requestsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: certificate_requestsCreateManyStudentsInputEnvelope
    set?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    disconnect?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    delete?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    connect?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    update?: certificate_requestsUpdateWithWhereUniqueWithoutStudentsInput | certificate_requestsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: certificate_requestsUpdateManyWithWhereWithoutStudentsInput | certificate_requestsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: certificate_requestsScalarWhereInput | certificate_requestsScalarWhereInput[]
  }

  export type enrollmentsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<enrollmentsCreateWithoutStudentsInput, enrollmentsUncheckedCreateWithoutStudentsInput> | enrollmentsCreateWithoutStudentsInput[] | enrollmentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutStudentsInput | enrollmentsCreateOrConnectWithoutStudentsInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutStudentsInput | enrollmentsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: enrollmentsCreateManyStudentsInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutStudentsInput | enrollmentsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutStudentsInput | enrollmentsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type financial_billsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<financial_billsCreateWithoutStudentsInput, financial_billsUncheckedCreateWithoutStudentsInput> | financial_billsCreateWithoutStudentsInput[] | financial_billsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financial_billsCreateOrConnectWithoutStudentsInput | financial_billsCreateOrConnectWithoutStudentsInput[]
    upsert?: financial_billsUpsertWithWhereUniqueWithoutStudentsInput | financial_billsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: financial_billsCreateManyStudentsInputEnvelope
    set?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    disconnect?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    delete?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    connect?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    update?: financial_billsUpdateWithWhereUniqueWithoutStudentsInput | financial_billsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: financial_billsUpdateManyWithWhereWithoutStudentsInput | financial_billsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: financial_billsScalarWhereInput | financial_billsScalarWhereInput[]
  }

  export type research_proposalsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<research_proposalsCreateWithoutStudentsInput, research_proposalsUncheckedCreateWithoutStudentsInput> | research_proposalsCreateWithoutStudentsInput[] | research_proposalsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: research_proposalsCreateOrConnectWithoutStudentsInput | research_proposalsCreateOrConnectWithoutStudentsInput[]
    upsert?: research_proposalsUpsertWithWhereUniqueWithoutStudentsInput | research_proposalsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: research_proposalsCreateManyStudentsInputEnvelope
    set?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    disconnect?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    delete?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    connect?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    update?: research_proposalsUpdateWithWhereUniqueWithoutStudentsInput | research_proposalsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: research_proposalsUpdateManyWithWhereWithoutStudentsInput | research_proposalsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: research_proposalsScalarWhereInput | research_proposalsScalarWhereInput[]
  }

  export type student_profilesUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<student_profilesCreateWithoutStudentsInput, student_profilesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: student_profilesCreateOrConnectWithoutStudentsInput
    upsert?: student_profilesUpsertWithoutStudentsInput
    disconnect?: student_profilesWhereInput | boolean
    delete?: student_profilesWhereInput | boolean
    connect?: student_profilesWhereUniqueInput
    update?: XOR<XOR<student_profilesUpdateToOneWithWhereWithoutStudentsInput, student_profilesUpdateWithoutStudentsInput>, student_profilesUncheckedUpdateWithoutStudentsInput>
  }

  export type attendancesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutStudentsInput | attendancesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutStudentsInput | attendancesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutStudentsInput | attendancesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<certificate_requestsCreateWithoutStudentsInput, certificate_requestsUncheckedCreateWithoutStudentsInput> | certificate_requestsCreateWithoutStudentsInput[] | certificate_requestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: certificate_requestsCreateOrConnectWithoutStudentsInput | certificate_requestsCreateOrConnectWithoutStudentsInput[]
    upsert?: certificate_requestsUpsertWithWhereUniqueWithoutStudentsInput | certificate_requestsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: certificate_requestsCreateManyStudentsInputEnvelope
    set?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    disconnect?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    delete?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    connect?: certificate_requestsWhereUniqueInput | certificate_requestsWhereUniqueInput[]
    update?: certificate_requestsUpdateWithWhereUniqueWithoutStudentsInput | certificate_requestsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: certificate_requestsUpdateManyWithWhereWithoutStudentsInput | certificate_requestsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: certificate_requestsScalarWhereInput | certificate_requestsScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<enrollmentsCreateWithoutStudentsInput, enrollmentsUncheckedCreateWithoutStudentsInput> | enrollmentsCreateWithoutStudentsInput[] | enrollmentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutStudentsInput | enrollmentsCreateOrConnectWithoutStudentsInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutStudentsInput | enrollmentsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: enrollmentsCreateManyStudentsInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutStudentsInput | enrollmentsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutStudentsInput | enrollmentsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type financial_billsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<financial_billsCreateWithoutStudentsInput, financial_billsUncheckedCreateWithoutStudentsInput> | financial_billsCreateWithoutStudentsInput[] | financial_billsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financial_billsCreateOrConnectWithoutStudentsInput | financial_billsCreateOrConnectWithoutStudentsInput[]
    upsert?: financial_billsUpsertWithWhereUniqueWithoutStudentsInput | financial_billsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: financial_billsCreateManyStudentsInputEnvelope
    set?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    disconnect?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    delete?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    connect?: financial_billsWhereUniqueInput | financial_billsWhereUniqueInput[]
    update?: financial_billsUpdateWithWhereUniqueWithoutStudentsInput | financial_billsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: financial_billsUpdateManyWithWhereWithoutStudentsInput | financial_billsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: financial_billsScalarWhereInput | financial_billsScalarWhereInput[]
  }

  export type research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<research_proposalsCreateWithoutStudentsInput, research_proposalsUncheckedCreateWithoutStudentsInput> | research_proposalsCreateWithoutStudentsInput[] | research_proposalsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: research_proposalsCreateOrConnectWithoutStudentsInput | research_proposalsCreateOrConnectWithoutStudentsInput[]
    upsert?: research_proposalsUpsertWithWhereUniqueWithoutStudentsInput | research_proposalsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: research_proposalsCreateManyStudentsInputEnvelope
    set?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    disconnect?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    delete?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    connect?: research_proposalsWhereUniqueInput | research_proposalsWhereUniqueInput[]
    update?: research_proposalsUpdateWithWhereUniqueWithoutStudentsInput | research_proposalsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: research_proposalsUpdateManyWithWhereWithoutStudentsInput | research_proposalsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: research_proposalsScalarWhereInput | research_proposalsScalarWhereInput[]
  }

  export type student_profilesUncheckedUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<student_profilesCreateWithoutStudentsInput, student_profilesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: student_profilesCreateOrConnectWithoutStudentsInput
    upsert?: student_profilesUpsertWithoutStudentsInput
    disconnect?: student_profilesWhereInput | boolean
    delete?: student_profilesWhereInput | boolean
    connect?: student_profilesWhereUniqueInput
    update?: XOR<XOR<student_profilesUpdateToOneWithWhereWithoutStudentsInput, student_profilesUpdateWithoutStudentsInput>, student_profilesUncheckedUpdateWithoutStudentsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type classesCreateWithoutAttendancesInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    class_schedules?: class_schedulesCreateNestedManyWithoutClassesInput
    courses: coursesCreateNestedOneWithoutClassesInput
    lecturers?: lecturersCreateNestedOneWithoutClassesInput
    enrollments?: enrollmentsCreateNestedManyWithoutClassesInput
    exams?: examsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutAttendancesInput = {
    id?: string
    tenant_id: string
    course_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    class_schedules?: class_schedulesUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutClassesInput
    exams?: examsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutAttendancesInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutAttendancesInput, classesUncheckedCreateWithoutAttendancesInput>
  }

  export type studentsCreateWithoutAttendancesInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    certificate_requests?: certificate_requestsCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutAttendancesInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    certificate_requests?: certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsUncheckedCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsUncheckedCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesUncheckedCreateNestedOneWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutAttendancesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
  }

  export type classesUpsertWithoutAttendancesInput = {
    update: XOR<classesUpdateWithoutAttendancesInput, classesUncheckedUpdateWithoutAttendancesInput>
    create: XOR<classesCreateWithoutAttendancesInput, classesUncheckedCreateWithoutAttendancesInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutAttendancesInput, classesUncheckedUpdateWithoutAttendancesInput>
  }

  export type classesUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_schedules?: class_schedulesUpdateManyWithoutClassesNestedInput
    courses?: coursesUpdateOneRequiredWithoutClassesNestedInput
    lecturers?: lecturersUpdateOneWithoutClassesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutClassesNestedInput
    exams?: examsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_schedules?: class_schedulesUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutClassesNestedInput
    exams?: examsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type studentsUpsertWithoutAttendancesInput = {
    update: XOR<studentsUpdateWithoutAttendancesInput, studentsUncheckedUpdateWithoutAttendancesInput>
    create: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutAttendancesInput, studentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type studentsUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    certificate_requests?: certificate_requestsUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    certificate_requests?: certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUncheckedUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUncheckedUpdateOneWithoutStudentsNestedInput
  }

  export type studentsCreateWithoutCertificate_requestsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutCertificate_requestsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsUncheckedCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsUncheckedCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesUncheckedCreateNestedOneWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutCertificate_requestsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutCertificate_requestsInput, studentsUncheckedCreateWithoutCertificate_requestsInput>
  }

  export type studentsUpsertWithoutCertificate_requestsInput = {
    update: XOR<studentsUpdateWithoutCertificate_requestsInput, studentsUncheckedUpdateWithoutCertificate_requestsInput>
    create: XOR<studentsCreateWithoutCertificate_requestsInput, studentsUncheckedCreateWithoutCertificate_requestsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutCertificate_requestsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutCertificate_requestsInput, studentsUncheckedUpdateWithoutCertificate_requestsInput>
  }

  export type studentsUpdateWithoutCertificate_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutCertificate_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUncheckedUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUncheckedUpdateOneWithoutStudentsNestedInput
  }

  export type classesCreateWithoutClass_schedulesInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutClassesInput
    courses: coursesCreateNestedOneWithoutClassesInput
    lecturers?: lecturersCreateNestedOneWithoutClassesInput
    enrollments?: enrollmentsCreateNestedManyWithoutClassesInput
    exams?: examsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutClass_schedulesInput = {
    id?: string
    tenant_id: string
    course_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutClassesInput
    exams?: examsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutClass_schedulesInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutClass_schedulesInput, classesUncheckedCreateWithoutClass_schedulesInput>
  }

  export type classesUpsertWithoutClass_schedulesInput = {
    update: XOR<classesUpdateWithoutClass_schedulesInput, classesUncheckedUpdateWithoutClass_schedulesInput>
    create: XOR<classesCreateWithoutClass_schedulesInput, classesUncheckedCreateWithoutClass_schedulesInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutClass_schedulesInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutClass_schedulesInput, classesUncheckedUpdateWithoutClass_schedulesInput>
  }

  export type classesUpdateWithoutClass_schedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutClassesNestedInput
    courses?: coursesUpdateOneRequiredWithoutClassesNestedInput
    lecturers?: lecturersUpdateOneWithoutClassesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutClassesNestedInput
    exams?: examsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutClass_schedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutClassesNestedInput
    exams?: examsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type attendancesCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutAttendancesInput
  }

  export type attendancesUncheckedCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    student_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
  }

  export type attendancesCreateOrConnectWithoutClassesInput = {
    where: attendancesWhereUniqueInput
    create: XOR<attendancesCreateWithoutClassesInput, attendancesUncheckedCreateWithoutClassesInput>
  }

  export type attendancesCreateManyClassesInputEnvelope = {
    data: attendancesCreateManyClassesInput | attendancesCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type class_schedulesCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    day: string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type class_schedulesUncheckedCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    day: string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type class_schedulesCreateOrConnectWithoutClassesInput = {
    where: class_schedulesWhereUniqueInput
    create: XOR<class_schedulesCreateWithoutClassesInput, class_schedulesUncheckedCreateWithoutClassesInput>
  }

  export type class_schedulesCreateManyClassesInputEnvelope = {
    data: class_schedulesCreateManyClassesInput | class_schedulesCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type coursesCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    code: string
    name: string
    credits?: number
    created_at?: Date | string | null
  }

  export type coursesUncheckedCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    code: string
    name: string
    credits?: number
    created_at?: Date | string | null
  }

  export type coursesCreateOrConnectWithoutClassesInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutClassesInput, coursesUncheckedCreateWithoutClassesInput>
  }

  export type lecturersCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_lecturer_number?: string | null
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type lecturersUncheckedCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_lecturer_number?: string | null
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type lecturersCreateOrConnectWithoutClassesInput = {
    where: lecturersWhereUniqueInput
    create: XOR<lecturersCreateWithoutClassesInput, lecturersUncheckedCreateWithoutClassesInput>
  }

  export type enrollmentsCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    status?: string | null
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutEnrollmentsInput
    grades?: gradesCreateNestedManyWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    student_id: string
    status?: string | null
    created_at?: Date | string | null
    grades?: gradesUncheckedCreateNestedManyWithoutEnrollmentsInput
  }

  export type enrollmentsCreateOrConnectWithoutClassesInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutClassesInput, enrollmentsUncheckedCreateWithoutClassesInput>
  }

  export type enrollmentsCreateManyClassesInputEnvelope = {
    data: enrollmentsCreateManyClassesInput | enrollmentsCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    type: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    created_at?: Date | string | null
  }

  export type examsUncheckedCreateWithoutClassesInput = {
    id?: string
    tenant_id: string
    type: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    created_at?: Date | string | null
  }

  export type examsCreateOrConnectWithoutClassesInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutClassesInput, examsUncheckedCreateWithoutClassesInput>
  }

  export type examsCreateManyClassesInputEnvelope = {
    data: examsCreateManyClassesInput | examsCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type attendancesUpsertWithWhereUniqueWithoutClassesInput = {
    where: attendancesWhereUniqueInput
    update: XOR<attendancesUpdateWithoutClassesInput, attendancesUncheckedUpdateWithoutClassesInput>
    create: XOR<attendancesCreateWithoutClassesInput, attendancesUncheckedCreateWithoutClassesInput>
  }

  export type attendancesUpdateWithWhereUniqueWithoutClassesInput = {
    where: attendancesWhereUniqueInput
    data: XOR<attendancesUpdateWithoutClassesInput, attendancesUncheckedUpdateWithoutClassesInput>
  }

  export type attendancesUpdateManyWithWhereWithoutClassesInput = {
    where: attendancesScalarWhereInput
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyWithoutClassesInput>
  }

  export type attendancesScalarWhereInput = {
    AND?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
    OR?: attendancesScalarWhereInput[]
    NOT?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
    id?: UuidFilter<"attendances"> | string
    tenant_id?: UuidFilter<"attendances"> | string
    class_id?: UuidFilter<"attendances"> | string
    student_id?: UuidFilter<"attendances"> | string
    meeting_number?: IntFilter<"attendances"> | number
    status?: StringNullableFilter<"attendances"> | string | null
    created_at?: DateTimeNullableFilter<"attendances"> | Date | string | null
  }

  export type class_schedulesUpsertWithWhereUniqueWithoutClassesInput = {
    where: class_schedulesWhereUniqueInput
    update: XOR<class_schedulesUpdateWithoutClassesInput, class_schedulesUncheckedUpdateWithoutClassesInput>
    create: XOR<class_schedulesCreateWithoutClassesInput, class_schedulesUncheckedCreateWithoutClassesInput>
  }

  export type class_schedulesUpdateWithWhereUniqueWithoutClassesInput = {
    where: class_schedulesWhereUniqueInput
    data: XOR<class_schedulesUpdateWithoutClassesInput, class_schedulesUncheckedUpdateWithoutClassesInput>
  }

  export type class_schedulesUpdateManyWithWhereWithoutClassesInput = {
    where: class_schedulesScalarWhereInput
    data: XOR<class_schedulesUpdateManyMutationInput, class_schedulesUncheckedUpdateManyWithoutClassesInput>
  }

  export type class_schedulesScalarWhereInput = {
    AND?: class_schedulesScalarWhereInput | class_schedulesScalarWhereInput[]
    OR?: class_schedulesScalarWhereInput[]
    NOT?: class_schedulesScalarWhereInput | class_schedulesScalarWhereInput[]
    id?: UuidFilter<"class_schedules"> | string
    tenant_id?: UuidFilter<"class_schedules"> | string
    class_id?: UuidFilter<"class_schedules"> | string
    day?: StringFilter<"class_schedules"> | string
    start_time?: DateTimeFilter<"class_schedules"> | Date | string
    end_time?: DateTimeFilter<"class_schedules"> | Date | string
    room?: StringNullableFilter<"class_schedules"> | string | null
    type?: StringNullableFilter<"class_schedules"> | string | null
    created_at?: DateTimeNullableFilter<"class_schedules"> | Date | string | null
  }

  export type coursesUpsertWithoutClassesInput = {
    update: XOR<coursesUpdateWithoutClassesInput, coursesUncheckedUpdateWithoutClassesInput>
    create: XOR<coursesCreateWithoutClassesInput, coursesUncheckedCreateWithoutClassesInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutClassesInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutClassesInput, coursesUncheckedUpdateWithoutClassesInput>
  }

  export type coursesUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coursesUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lecturersUpsertWithoutClassesInput = {
    update: XOR<lecturersUpdateWithoutClassesInput, lecturersUncheckedUpdateWithoutClassesInput>
    create: XOR<lecturersCreateWithoutClassesInput, lecturersUncheckedCreateWithoutClassesInput>
    where?: lecturersWhereInput
  }

  export type lecturersUpdateToOneWithWhereWithoutClassesInput = {
    where?: lecturersWhereInput
    data: XOR<lecturersUpdateWithoutClassesInput, lecturersUncheckedUpdateWithoutClassesInput>
  }

  export type lecturersUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_lecturer_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lecturersUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_lecturer_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutClassesInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutClassesInput, enrollmentsUncheckedUpdateWithoutClassesInput>
    create: XOR<enrollmentsCreateWithoutClassesInput, enrollmentsUncheckedCreateWithoutClassesInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutClassesInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutClassesInput, enrollmentsUncheckedUpdateWithoutClassesInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutClassesInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutClassesInput>
  }

  export type enrollmentsScalarWhereInput = {
    AND?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
    OR?: enrollmentsScalarWhereInput[]
    NOT?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
    id?: UuidFilter<"enrollments"> | string
    tenant_id?: UuidFilter<"enrollments"> | string
    student_id?: UuidFilter<"enrollments"> | string
    class_id?: UuidFilter<"enrollments"> | string
    status?: StringNullableFilter<"enrollments"> | string | null
    created_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
  }

  export type examsUpsertWithWhereUniqueWithoutClassesInput = {
    where: examsWhereUniqueInput
    update: XOR<examsUpdateWithoutClassesInput, examsUncheckedUpdateWithoutClassesInput>
    create: XOR<examsCreateWithoutClassesInput, examsUncheckedCreateWithoutClassesInput>
  }

  export type examsUpdateWithWhereUniqueWithoutClassesInput = {
    where: examsWhereUniqueInput
    data: XOR<examsUpdateWithoutClassesInput, examsUncheckedUpdateWithoutClassesInput>
  }

  export type examsUpdateManyWithWhereWithoutClassesInput = {
    where: examsScalarWhereInput
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyWithoutClassesInput>
  }

  export type examsScalarWhereInput = {
    AND?: examsScalarWhereInput | examsScalarWhereInput[]
    OR?: examsScalarWhereInput[]
    NOT?: examsScalarWhereInput | examsScalarWhereInput[]
    id?: UuidFilter<"exams"> | string
    tenant_id?: UuidFilter<"exams"> | string
    class_id?: UuidFilter<"exams"> | string
    type?: StringFilter<"exams"> | string
    date?: DateTimeFilter<"exams"> | Date | string
    start_time?: DateTimeFilter<"exams"> | Date | string
    end_time?: DateTimeFilter<"exams"> | Date | string
    room?: StringNullableFilter<"exams"> | string | null
    created_at?: DateTimeNullableFilter<"exams"> | Date | string | null
  }

  export type classesCreateWithoutCoursesInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesCreateNestedManyWithoutClassesInput
    lecturers?: lecturersCreateNestedOneWithoutClassesInput
    enrollments?: enrollmentsCreateNestedManyWithoutClassesInput
    exams?: examsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutCoursesInput = {
    id?: string
    tenant_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutClassesInput
    exams?: examsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutCoursesInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutCoursesInput, classesUncheckedCreateWithoutCoursesInput>
  }

  export type classesCreateManyCoursesInputEnvelope = {
    data: classesCreateManyCoursesInput | classesCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutCoursesInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutCoursesInput, classesUncheckedUpdateWithoutCoursesInput>
    create: XOR<classesCreateWithoutCoursesInput, classesUncheckedCreateWithoutCoursesInput>
  }

  export type classesUpdateWithWhereUniqueWithoutCoursesInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutCoursesInput, classesUncheckedUpdateWithoutCoursesInput>
  }

  export type classesUpdateManyWithWhereWithoutCoursesInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutCoursesInput>
  }

  export type classesScalarWhereInput = {
    AND?: classesScalarWhereInput | classesScalarWhereInput[]
    OR?: classesScalarWhereInput[]
    NOT?: classesScalarWhereInput | classesScalarWhereInput[]
    id?: UuidFilter<"classes"> | string
    tenant_id?: UuidFilter<"classes"> | string
    course_id?: UuidFilter<"classes"> | string
    lecturer_id?: UuidNullableFilter<"classes"> | string | null
    semester?: StringFilter<"classes"> | string
    year?: IntFilter<"classes"> | number
    capacity?: IntNullableFilter<"classes"> | number | null
    created_at?: DateTimeNullableFilter<"classes"> | Date | string | null
  }

  export type classesCreateWithoutEnrollmentsInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesCreateNestedManyWithoutClassesInput
    courses: coursesCreateNestedOneWithoutClassesInput
    lecturers?: lecturersCreateNestedOneWithoutClassesInput
    exams?: examsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    tenant_id: string
    course_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesUncheckedCreateNestedManyWithoutClassesInput
    exams?: examsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutEnrollmentsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutEnrollmentsInput, classesUncheckedCreateWithoutEnrollmentsInput>
  }

  export type studentsCreateWithoutEnrollmentsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsUncheckedCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsUncheckedCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesUncheckedCreateNestedOneWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutEnrollmentsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutEnrollmentsInput, studentsUncheckedCreateWithoutEnrollmentsInput>
  }

  export type gradesCreateWithoutEnrollmentsInput = {
    id?: string
    tenant_id: string
    grade?: string | null
    score?: number | null
    created_at?: Date | string | null
  }

  export type gradesUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    tenant_id: string
    grade?: string | null
    score?: number | null
    created_at?: Date | string | null
  }

  export type gradesCreateOrConnectWithoutEnrollmentsInput = {
    where: gradesWhereUniqueInput
    create: XOR<gradesCreateWithoutEnrollmentsInput, gradesUncheckedCreateWithoutEnrollmentsInput>
  }

  export type gradesCreateManyEnrollmentsInputEnvelope = {
    data: gradesCreateManyEnrollmentsInput | gradesCreateManyEnrollmentsInput[]
    skipDuplicates?: boolean
  }

  export type classesUpsertWithoutEnrollmentsInput = {
    update: XOR<classesUpdateWithoutEnrollmentsInput, classesUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<classesCreateWithoutEnrollmentsInput, classesUncheckedCreateWithoutEnrollmentsInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutEnrollmentsInput, classesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type classesUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUpdateManyWithoutClassesNestedInput
    courses?: coursesUpdateOneRequiredWithoutClassesNestedInput
    lecturers?: lecturersUpdateOneWithoutClassesNestedInput
    exams?: examsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUncheckedUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUncheckedUpdateManyWithoutClassesNestedInput
    exams?: examsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type studentsUpsertWithoutEnrollmentsInput = {
    update: XOR<studentsUpdateWithoutEnrollmentsInput, studentsUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<studentsCreateWithoutEnrollmentsInput, studentsUncheckedCreateWithoutEnrollmentsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutEnrollmentsInput, studentsUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type studentsUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUncheckedUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUncheckedUpdateOneWithoutStudentsNestedInput
  }

  export type gradesUpsertWithWhereUniqueWithoutEnrollmentsInput = {
    where: gradesWhereUniqueInput
    update: XOR<gradesUpdateWithoutEnrollmentsInput, gradesUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<gradesCreateWithoutEnrollmentsInput, gradesUncheckedCreateWithoutEnrollmentsInput>
  }

  export type gradesUpdateWithWhereUniqueWithoutEnrollmentsInput = {
    where: gradesWhereUniqueInput
    data: XOR<gradesUpdateWithoutEnrollmentsInput, gradesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type gradesUpdateManyWithWhereWithoutEnrollmentsInput = {
    where: gradesScalarWhereInput
    data: XOR<gradesUpdateManyMutationInput, gradesUncheckedUpdateManyWithoutEnrollmentsInput>
  }

  export type gradesScalarWhereInput = {
    AND?: gradesScalarWhereInput | gradesScalarWhereInput[]
    OR?: gradesScalarWhereInput[]
    NOT?: gradesScalarWhereInput | gradesScalarWhereInput[]
    id?: UuidFilter<"grades"> | string
    tenant_id?: UuidFilter<"grades"> | string
    enrollment_id?: UuidFilter<"grades"> | string
    grade?: StringNullableFilter<"grades"> | string | null
    score?: FloatNullableFilter<"grades"> | number | null
    created_at?: DateTimeNullableFilter<"grades"> | Date | string | null
  }

  export type classesCreateWithoutExamsInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesCreateNestedManyWithoutClassesInput
    courses: coursesCreateNestedOneWithoutClassesInput
    lecturers?: lecturersCreateNestedOneWithoutClassesInput
    enrollments?: enrollmentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutExamsInput = {
    id?: string
    tenant_id: string
    course_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutExamsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutExamsInput, classesUncheckedCreateWithoutExamsInput>
  }

  export type classesUpsertWithoutExamsInput = {
    update: XOR<classesUpdateWithoutExamsInput, classesUncheckedUpdateWithoutExamsInput>
    create: XOR<classesCreateWithoutExamsInput, classesUncheckedCreateWithoutExamsInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutExamsInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutExamsInput, classesUncheckedUpdateWithoutExamsInput>
  }

  export type classesUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUpdateManyWithoutClassesNestedInput
    courses?: coursesUpdateOneRequiredWithoutClassesNestedInput
    lecturers?: lecturersUpdateOneWithoutClassesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUncheckedUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type studentsCreateWithoutFinancial_billsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutFinancial_billsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsUncheckedCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesUncheckedCreateNestedOneWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutFinancial_billsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutFinancial_billsInput, studentsUncheckedCreateWithoutFinancial_billsInput>
  }

  export type studentsUpsertWithoutFinancial_billsInput = {
    update: XOR<studentsUpdateWithoutFinancial_billsInput, studentsUncheckedUpdateWithoutFinancial_billsInput>
    create: XOR<studentsCreateWithoutFinancial_billsInput, studentsUncheckedCreateWithoutFinancial_billsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutFinancial_billsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutFinancial_billsInput, studentsUncheckedUpdateWithoutFinancial_billsInput>
  }

  export type studentsUpdateWithoutFinancial_billsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutFinancial_billsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUncheckedUpdateOneWithoutStudentsNestedInput
  }

  export type enrollmentsCreateWithoutGradesInput = {
    id?: string
    tenant_id: string
    status?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutEnrollmentsInput
    students: studentsCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutGradesInput = {
    id?: string
    tenant_id: string
    student_id: string
    class_id: string
    status?: string | null
    created_at?: Date | string | null
  }

  export type enrollmentsCreateOrConnectWithoutGradesInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutGradesInput, enrollmentsUncheckedCreateWithoutGradesInput>
  }

  export type enrollmentsUpsertWithoutGradesInput = {
    update: XOR<enrollmentsUpdateWithoutGradesInput, enrollmentsUncheckedUpdateWithoutGradesInput>
    create: XOR<enrollmentsCreateWithoutGradesInput, enrollmentsUncheckedCreateWithoutGradesInput>
    where?: enrollmentsWhereInput
  }

  export type enrollmentsUpdateToOneWithWhereWithoutGradesInput = {
    where?: enrollmentsWhereInput
    data: XOR<enrollmentsUpdateWithoutGradesInput, enrollmentsUncheckedUpdateWithoutGradesInput>
  }

  export type enrollmentsUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutEnrollmentsNestedInput
    students?: studentsUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesCreateWithoutLecturersInput = {
    id?: string
    tenant_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesCreateNestedManyWithoutClassesInput
    courses: coursesCreateNestedOneWithoutClassesInput
    enrollments?: enrollmentsCreateNestedManyWithoutClassesInput
    exams?: examsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutLecturersInput = {
    id?: string
    tenant_id: string
    course_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutClassesInput
    class_schedules?: class_schedulesUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutClassesInput
    exams?: examsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutLecturersInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutLecturersInput, classesUncheckedCreateWithoutLecturersInput>
  }

  export type classesCreateManyLecturersInputEnvelope = {
    data: classesCreateManyLecturersInput | classesCreateManyLecturersInput[]
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutLecturersInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutLecturersInput, classesUncheckedUpdateWithoutLecturersInput>
    create: XOR<classesCreateWithoutLecturersInput, classesUncheckedCreateWithoutLecturersInput>
  }

  export type classesUpdateWithWhereUniqueWithoutLecturersInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutLecturersInput, classesUncheckedUpdateWithoutLecturersInput>
  }

  export type classesUpdateManyWithWhereWithoutLecturersInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutLecturersInput>
  }

  export type studentsCreateWithoutResearch_proposalsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutResearch_proposalsInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsUncheckedCreateNestedManyWithoutStudentsInput
    student_profiles?: student_profilesUncheckedCreateNestedOneWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutResearch_proposalsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutResearch_proposalsInput, studentsUncheckedCreateWithoutResearch_proposalsInput>
  }

  export type studentsUpsertWithoutResearch_proposalsInput = {
    update: XOR<studentsUpdateWithoutResearch_proposalsInput, studentsUncheckedUpdateWithoutResearch_proposalsInput>
    create: XOR<studentsCreateWithoutResearch_proposalsInput, studentsUncheckedCreateWithoutResearch_proposalsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutResearch_proposalsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutResearch_proposalsInput, studentsUncheckedUpdateWithoutResearch_proposalsInput>
  }

  export type studentsUpdateWithoutResearch_proposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutResearch_proposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUncheckedUpdateManyWithoutStudentsNestedInput
    student_profiles?: student_profilesUncheckedUpdateOneWithoutStudentsNestedInput
  }

  export type studentsCreateWithoutStudent_profilesInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_profilesInput = {
    id?: string
    tenant_id: string
    user_id: string
    platform_student_number?: string | null
    name: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    study_program?: string | null
    entry_year?: number | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    certificate_requests?: certificate_requestsUncheckedCreateNestedManyWithoutStudentsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutStudentsInput
    financial_bills?: financial_billsUncheckedCreateNestedManyWithoutStudentsInput
    research_proposals?: research_proposalsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_profilesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_profilesInput, studentsUncheckedCreateWithoutStudent_profilesInput>
  }

  export type studentsUpsertWithoutStudent_profilesInput = {
    update: XOR<studentsUpdateWithoutStudent_profilesInput, studentsUncheckedUpdateWithoutStudent_profilesInput>
    create: XOR<studentsCreateWithoutStudent_profilesInput, studentsUncheckedCreateWithoutStudent_profilesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_profilesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_profilesInput, studentsUncheckedUpdateWithoutStudent_profilesInput>
  }

  export type studentsUpdateWithoutStudent_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    platform_student_number?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study_program?: NullableStringFieldUpdateOperationsInput | string | null
    entry_year?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    certificate_requests?: certificate_requestsUncheckedUpdateManyWithoutStudentsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutStudentsNestedInput
    financial_bills?: financial_billsUncheckedUpdateManyWithoutStudentsNestedInput
    research_proposals?: research_proposalsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type attendancesCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutAttendancesInput
  }

  export type attendancesUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    class_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
  }

  export type attendancesCreateOrConnectWithoutStudentsInput = {
    where: attendancesWhereUniqueInput
    create: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput>
  }

  export type attendancesCreateManyStudentsInputEnvelope = {
    data: attendancesCreateManyStudentsInput | attendancesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type certificate_requestsCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    type: string
    purpose?: string | null
    quantity?: number | null
    notes?: string | null
    status?: string | null
    rejection_reason?: string | null
    download_url?: string | null
    created_at?: Date | string | null
  }

  export type certificate_requestsUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    type: string
    purpose?: string | null
    quantity?: number | null
    notes?: string | null
    status?: string | null
    rejection_reason?: string | null
    download_url?: string | null
    created_at?: Date | string | null
  }

  export type certificate_requestsCreateOrConnectWithoutStudentsInput = {
    where: certificate_requestsWhereUniqueInput
    create: XOR<certificate_requestsCreateWithoutStudentsInput, certificate_requestsUncheckedCreateWithoutStudentsInput>
  }

  export type certificate_requestsCreateManyStudentsInputEnvelope = {
    data: certificate_requestsCreateManyStudentsInput | certificate_requestsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentsCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    status?: string | null
    created_at?: Date | string | null
    classes: classesCreateNestedOneWithoutEnrollmentsInput
    grades?: gradesCreateNestedManyWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    class_id: string
    status?: string | null
    created_at?: Date | string | null
    grades?: gradesUncheckedCreateNestedManyWithoutEnrollmentsInput
  }

  export type enrollmentsCreateOrConnectWithoutStudentsInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutStudentsInput, enrollmentsUncheckedCreateWithoutStudentsInput>
  }

  export type enrollmentsCreateManyStudentsInputEnvelope = {
    data: enrollmentsCreateManyStudentsInput | enrollmentsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type financial_billsCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    is_paid?: boolean | null
    due_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type financial_billsUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    is_paid?: boolean | null
    due_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type financial_billsCreateOrConnectWithoutStudentsInput = {
    where: financial_billsWhereUniqueInput
    create: XOR<financial_billsCreateWithoutStudentsInput, financial_billsUncheckedCreateWithoutStudentsInput>
  }

  export type financial_billsCreateManyStudentsInputEnvelope = {
    data: financial_billsCreateManyStudentsInput | financial_billsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type research_proposalsCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    title: string
    type: string
    description?: string | null
    supervisor_preferred?: string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type research_proposalsUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    title: string
    type: string
    description?: string | null
    supervisor_preferred?: string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type research_proposalsCreateOrConnectWithoutStudentsInput = {
    where: research_proposalsWhereUniqueInput
    create: XOR<research_proposalsCreateWithoutStudentsInput, research_proposalsUncheckedCreateWithoutStudentsInput>
  }

  export type research_proposalsCreateManyStudentsInputEnvelope = {
    data: research_proposalsCreateManyStudentsInput | research_proposalsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type student_profilesCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    gender?: string | null
    place_of_birth?: string | null
    date_of_birth?: Date | string | null
    religion?: string | null
    phone_1?: string | null
    phone_2?: string | null
    whatsapp?: string | null
    job_status?: string | null
    company_name?: string | null
    job_start_year?: number | null
    income_range?: string | null
    ktp_province?: string | null
    ktp_city?: string | null
    ktp_district?: string | null
    ktp_subdistrict?: string | null
    ktp_rt?: string | null
    ktp_rw?: string | null
    ktp_postal_code?: string | null
    ktp_address?: string | null
    current_province?: string | null
    current_city?: string | null
    current_district?: string | null
    current_subdistrict?: string | null
    current_rt?: string | null
    current_rw?: string | null
    current_postal_code?: string | null
    current_address?: string | null
    citizenship?: string | null
    nik?: string | null
    kk_number?: string | null
    living_status?: string | null
    father_nik?: string | null
    father_name?: string | null
    father_living_status?: string | null
    father_phone?: string | null
    father_place_of_birth?: string | null
    father_date_of_birth?: Date | string | null
    father_religion?: string | null
    father_job?: string | null
    father_income_range?: string | null
    father_address?: string | null
    mother_nik?: string | null
    mother_name?: string | null
    mother_living_status?: string | null
    mother_phone?: string | null
    mother_place_of_birth?: string | null
    mother_date_of_birth?: Date | string | null
    mother_religion?: string | null
    mother_job?: string | null
    mother_income_range?: string | null
    mother_address?: string | null
    school_name?: string | null
    school_major?: string | null
    nisn?: string | null
    diploma_number?: string | null
    graduation_year?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_profilesUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenant_id: string
    gender?: string | null
    place_of_birth?: string | null
    date_of_birth?: Date | string | null
    religion?: string | null
    phone_1?: string | null
    phone_2?: string | null
    whatsapp?: string | null
    job_status?: string | null
    company_name?: string | null
    job_start_year?: number | null
    income_range?: string | null
    ktp_province?: string | null
    ktp_city?: string | null
    ktp_district?: string | null
    ktp_subdistrict?: string | null
    ktp_rt?: string | null
    ktp_rw?: string | null
    ktp_postal_code?: string | null
    ktp_address?: string | null
    current_province?: string | null
    current_city?: string | null
    current_district?: string | null
    current_subdistrict?: string | null
    current_rt?: string | null
    current_rw?: string | null
    current_postal_code?: string | null
    current_address?: string | null
    citizenship?: string | null
    nik?: string | null
    kk_number?: string | null
    living_status?: string | null
    father_nik?: string | null
    father_name?: string | null
    father_living_status?: string | null
    father_phone?: string | null
    father_place_of_birth?: string | null
    father_date_of_birth?: Date | string | null
    father_religion?: string | null
    father_job?: string | null
    father_income_range?: string | null
    father_address?: string | null
    mother_nik?: string | null
    mother_name?: string | null
    mother_living_status?: string | null
    mother_phone?: string | null
    mother_place_of_birth?: string | null
    mother_date_of_birth?: Date | string | null
    mother_religion?: string | null
    mother_job?: string | null
    mother_income_range?: string | null
    mother_address?: string | null
    school_name?: string | null
    school_major?: string | null
    nisn?: string | null
    diploma_number?: string | null
    graduation_year?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type student_profilesCreateOrConnectWithoutStudentsInput = {
    where: student_profilesWhereUniqueInput
    create: XOR<student_profilesCreateWithoutStudentsInput, student_profilesUncheckedCreateWithoutStudentsInput>
  }

  export type attendancesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: attendancesWhereUniqueInput
    update: XOR<attendancesUpdateWithoutStudentsInput, attendancesUncheckedUpdateWithoutStudentsInput>
    create: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput>
  }

  export type attendancesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: attendancesWhereUniqueInput
    data: XOR<attendancesUpdateWithoutStudentsInput, attendancesUncheckedUpdateWithoutStudentsInput>
  }

  export type attendancesUpdateManyWithWhereWithoutStudentsInput = {
    where: attendancesScalarWhereInput
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type certificate_requestsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: certificate_requestsWhereUniqueInput
    update: XOR<certificate_requestsUpdateWithoutStudentsInput, certificate_requestsUncheckedUpdateWithoutStudentsInput>
    create: XOR<certificate_requestsCreateWithoutStudentsInput, certificate_requestsUncheckedCreateWithoutStudentsInput>
  }

  export type certificate_requestsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: certificate_requestsWhereUniqueInput
    data: XOR<certificate_requestsUpdateWithoutStudentsInput, certificate_requestsUncheckedUpdateWithoutStudentsInput>
  }

  export type certificate_requestsUpdateManyWithWhereWithoutStudentsInput = {
    where: certificate_requestsScalarWhereInput
    data: XOR<certificate_requestsUpdateManyMutationInput, certificate_requestsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type certificate_requestsScalarWhereInput = {
    AND?: certificate_requestsScalarWhereInput | certificate_requestsScalarWhereInput[]
    OR?: certificate_requestsScalarWhereInput[]
    NOT?: certificate_requestsScalarWhereInput | certificate_requestsScalarWhereInput[]
    id?: UuidFilter<"certificate_requests"> | string
    tenant_id?: UuidFilter<"certificate_requests"> | string
    student_id?: UuidFilter<"certificate_requests"> | string
    type?: StringFilter<"certificate_requests"> | string
    purpose?: StringNullableFilter<"certificate_requests"> | string | null
    quantity?: IntNullableFilter<"certificate_requests"> | number | null
    notes?: StringNullableFilter<"certificate_requests"> | string | null
    status?: StringNullableFilter<"certificate_requests"> | string | null
    rejection_reason?: StringNullableFilter<"certificate_requests"> | string | null
    download_url?: StringNullableFilter<"certificate_requests"> | string | null
    created_at?: DateTimeNullableFilter<"certificate_requests"> | Date | string | null
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutStudentsInput, enrollmentsUncheckedUpdateWithoutStudentsInput>
    create: XOR<enrollmentsCreateWithoutStudentsInput, enrollmentsUncheckedCreateWithoutStudentsInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutStudentsInput, enrollmentsUncheckedUpdateWithoutStudentsInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutStudentsInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type financial_billsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: financial_billsWhereUniqueInput
    update: XOR<financial_billsUpdateWithoutStudentsInput, financial_billsUncheckedUpdateWithoutStudentsInput>
    create: XOR<financial_billsCreateWithoutStudentsInput, financial_billsUncheckedCreateWithoutStudentsInput>
  }

  export type financial_billsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: financial_billsWhereUniqueInput
    data: XOR<financial_billsUpdateWithoutStudentsInput, financial_billsUncheckedUpdateWithoutStudentsInput>
  }

  export type financial_billsUpdateManyWithWhereWithoutStudentsInput = {
    where: financial_billsScalarWhereInput
    data: XOR<financial_billsUpdateManyMutationInput, financial_billsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type financial_billsScalarWhereInput = {
    AND?: financial_billsScalarWhereInput | financial_billsScalarWhereInput[]
    OR?: financial_billsScalarWhereInput[]
    NOT?: financial_billsScalarWhereInput | financial_billsScalarWhereInput[]
    id?: UuidFilter<"financial_bills"> | string
    tenant_id?: UuidFilter<"financial_bills"> | string
    student_id?: UuidFilter<"financial_bills"> | string
    title?: StringFilter<"financial_bills"> | string
    amount?: DecimalFilter<"financial_bills"> | Decimal | DecimalJsLike | number | string
    is_paid?: BoolNullableFilter<"financial_bills"> | boolean | null
    due_date?: DateTimeNullableFilter<"financial_bills"> | Date | string | null
    created_at?: DateTimeNullableFilter<"financial_bills"> | Date | string | null
  }

  export type research_proposalsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: research_proposalsWhereUniqueInput
    update: XOR<research_proposalsUpdateWithoutStudentsInput, research_proposalsUncheckedUpdateWithoutStudentsInput>
    create: XOR<research_proposalsCreateWithoutStudentsInput, research_proposalsUncheckedCreateWithoutStudentsInput>
  }

  export type research_proposalsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: research_proposalsWhereUniqueInput
    data: XOR<research_proposalsUpdateWithoutStudentsInput, research_proposalsUncheckedUpdateWithoutStudentsInput>
  }

  export type research_proposalsUpdateManyWithWhereWithoutStudentsInput = {
    where: research_proposalsScalarWhereInput
    data: XOR<research_proposalsUpdateManyMutationInput, research_proposalsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type research_proposalsScalarWhereInput = {
    AND?: research_proposalsScalarWhereInput | research_proposalsScalarWhereInput[]
    OR?: research_proposalsScalarWhereInput[]
    NOT?: research_proposalsScalarWhereInput | research_proposalsScalarWhereInput[]
    id?: UuidFilter<"research_proposals"> | string
    tenant_id?: UuidFilter<"research_proposals"> | string
    student_id?: UuidFilter<"research_proposals"> | string
    title?: StringFilter<"research_proposals"> | string
    type?: StringFilter<"research_proposals"> | string
    description?: StringNullableFilter<"research_proposals"> | string | null
    supervisor_preferred?: StringNullableFilter<"research_proposals"> | string | null
    status?: StringNullableFilter<"research_proposals"> | string | null
    created_at?: DateTimeNullableFilter<"research_proposals"> | Date | string | null
  }

  export type student_profilesUpsertWithoutStudentsInput = {
    update: XOR<student_profilesUpdateWithoutStudentsInput, student_profilesUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_profilesCreateWithoutStudentsInput, student_profilesUncheckedCreateWithoutStudentsInput>
    where?: student_profilesWhereInput
  }

  export type student_profilesUpdateToOneWithWhereWithoutStudentsInput = {
    where?: student_profilesWhereInput
    data: XOR<student_profilesUpdateWithoutStudentsInput, student_profilesUncheckedUpdateWithoutStudentsInput>
  }

  export type student_profilesUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    job_status?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_start_year?: NullableIntFieldUpdateOperationsInput | number | null
    income_range?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_province?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_city?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_district?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rt?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rw?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_province?: NullableStringFieldUpdateOperationsInput | string | null
    current_city?: NullableStringFieldUpdateOperationsInput | string | null
    current_district?: NullableStringFieldUpdateOperationsInput | string | null
    current_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    current_rt?: NullableStringFieldUpdateOperationsInput | string | null
    current_rw?: NullableStringFieldUpdateOperationsInput | string | null
    current_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    kk_number?: NullableStringFieldUpdateOperationsInput | string | null
    living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_nik?: NullableStringFieldUpdateOperationsInput | string | null
    father_name?: NullableStringFieldUpdateOperationsInput | string | null
    father_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_phone?: NullableStringFieldUpdateOperationsInput | string | null
    father_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    father_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    father_religion?: NullableStringFieldUpdateOperationsInput | string | null
    father_job?: NullableStringFieldUpdateOperationsInput | string | null
    father_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    father_address?: NullableStringFieldUpdateOperationsInput | string | null
    mother_nik?: NullableStringFieldUpdateOperationsInput | string | null
    mother_name?: NullableStringFieldUpdateOperationsInput | string | null
    mother_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    mother_phone?: NullableStringFieldUpdateOperationsInput | string | null
    mother_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    mother_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mother_religion?: NullableStringFieldUpdateOperationsInput | string | null
    mother_job?: NullableStringFieldUpdateOperationsInput | string | null
    mother_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    mother_address?: NullableStringFieldUpdateOperationsInput | string | null
    school_name?: NullableStringFieldUpdateOperationsInput | string | null
    school_major?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    diploma_number?: NullableStringFieldUpdateOperationsInput | string | null
    graduation_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_profilesUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    job_status?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_start_year?: NullableIntFieldUpdateOperationsInput | number | null
    income_range?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_province?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_city?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_district?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rt?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_rw?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    ktp_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_province?: NullableStringFieldUpdateOperationsInput | string | null
    current_city?: NullableStringFieldUpdateOperationsInput | string | null
    current_district?: NullableStringFieldUpdateOperationsInput | string | null
    current_subdistrict?: NullableStringFieldUpdateOperationsInput | string | null
    current_rt?: NullableStringFieldUpdateOperationsInput | string | null
    current_rw?: NullableStringFieldUpdateOperationsInput | string | null
    current_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    kk_number?: NullableStringFieldUpdateOperationsInput | string | null
    living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_nik?: NullableStringFieldUpdateOperationsInput | string | null
    father_name?: NullableStringFieldUpdateOperationsInput | string | null
    father_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    father_phone?: NullableStringFieldUpdateOperationsInput | string | null
    father_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    father_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    father_religion?: NullableStringFieldUpdateOperationsInput | string | null
    father_job?: NullableStringFieldUpdateOperationsInput | string | null
    father_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    father_address?: NullableStringFieldUpdateOperationsInput | string | null
    mother_nik?: NullableStringFieldUpdateOperationsInput | string | null
    mother_name?: NullableStringFieldUpdateOperationsInput | string | null
    mother_living_status?: NullableStringFieldUpdateOperationsInput | string | null
    mother_phone?: NullableStringFieldUpdateOperationsInput | string | null
    mother_place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    mother_date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mother_religion?: NullableStringFieldUpdateOperationsInput | string | null
    mother_job?: NullableStringFieldUpdateOperationsInput | string | null
    mother_income_range?: NullableStringFieldUpdateOperationsInput | string | null
    mother_address?: NullableStringFieldUpdateOperationsInput | string | null
    school_name?: NullableStringFieldUpdateOperationsInput | string | null
    school_major?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    diploma_number?: NullableStringFieldUpdateOperationsInput | string | null
    graduation_year?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesCreateManyClassesInput = {
    id?: string
    tenant_id: string
    student_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
  }

  export type class_schedulesCreateManyClassesInput = {
    id?: string
    tenant_id: string
    day: string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type enrollmentsCreateManyClassesInput = {
    id?: string
    tenant_id: string
    student_id: string
    status?: string | null
    created_at?: Date | string | null
  }

  export type examsCreateManyClassesInput = {
    id?: string
    tenant_id: string
    type: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    room?: string | null
    created_at?: Date | string | null
  }

  export type attendancesUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type attendancesUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesUncheckedUpdateManyWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_schedulesUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_schedulesUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_schedulesUncheckedUpdateManyWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutEnrollmentsNestedInput
    grades?: gradesUpdateManyWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grades?: gradesUncheckedUpdateManyWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateManyWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examsUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examsUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type examsUncheckedUpdateManyWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesCreateManyCoursesInput = {
    id?: string
    tenant_id: string
    lecturer_id?: string | null
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
  }

  export type classesUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUpdateManyWithoutClassesNestedInput
    lecturers?: lecturersUpdateOneWithoutClassesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutClassesNestedInput
    exams?: examsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUncheckedUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutClassesNestedInput
    exams?: examsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    lecturer_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gradesCreateManyEnrollmentsInput = {
    id?: string
    tenant_id: string
    grade?: string | null
    score?: number | null
    created_at?: Date | string | null
  }

  export type gradesUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gradesUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gradesUncheckedUpdateManyWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classesCreateManyLecturersInput = {
    id?: string
    tenant_id: string
    course_id: string
    semester: string
    year: number
    capacity?: number | null
    created_at?: Date | string | null
  }

  export type classesUpdateWithoutLecturersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUpdateManyWithoutClassesNestedInput
    courses?: coursesUpdateOneRequiredWithoutClassesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutClassesNestedInput
    exams?: examsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutLecturersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUncheckedUpdateManyWithoutClassesNestedInput
    class_schedules?: class_schedulesUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutClassesNestedInput
    exams?: examsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutLecturersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesCreateManyStudentsInput = {
    id?: string
    tenant_id: string
    class_id: string
    meeting_number: number
    status?: string | null
    created_at?: Date | string | null
  }

  export type certificate_requestsCreateManyStudentsInput = {
    id?: string
    tenant_id: string
    type: string
    purpose?: string | null
    quantity?: number | null
    notes?: string | null
    status?: string | null
    rejection_reason?: string | null
    download_url?: string | null
    created_at?: Date | string | null
  }

  export type enrollmentsCreateManyStudentsInput = {
    id?: string
    tenant_id: string
    class_id: string
    status?: string | null
    created_at?: Date | string | null
  }

  export type financial_billsCreateManyStudentsInput = {
    id?: string
    tenant_id: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    is_paid?: boolean | null
    due_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type research_proposalsCreateManyStudentsInput = {
    id?: string
    tenant_id: string
    title: string
    type: string
    description?: string | null
    supervisor_preferred?: string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type attendancesUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type attendancesUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    meeting_number?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificate_requestsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificate_requestsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificate_requestsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    download_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateOneRequiredWithoutEnrollmentsNestedInput
    grades?: gradesUpdateManyWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grades?: gradesUncheckedUpdateManyWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type financial_billsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type financial_billsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type financial_billsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type research_proposalsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type research_proposalsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type research_proposalsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_preferred?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}